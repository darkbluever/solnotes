{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"ec12c0c5f7d509f2a8e78c09a43e4595a7bf66b7","modified":1511939201000},{"_id":"source/README.md","hash":"c71e35aa395eec6afa8651bd0b7229e22fa5ee1b","modified":1511939201000},{"_id":"source/CNAME","hash":"c8d8d2e429dc5a3d0a2d10114ce8b0b645f8f795","modified":1511939201000},{"_id":"source/_posts/hello-world.md","hash":"ebb584b12785d5ea7a67a69aa7ce204921891dcc","modified":1511939201000},{"_id":"source/_drafts/php-mysql-async-query-demo.md","hash":"363e1fd5311284faec0057c9313c895433882428","modified":1511939201000},{"_id":"source/_posts/learn-and-try-to-use-quartz.md","hash":"0b9b948cd220f92e23a01bb982d37484f1e492fd","modified":1511939201000},{"_id":"source/_posts/mysql-high-availability-notes-1.md","hash":"5c5cf3f07a99e4fb7aa0b5b3ab81397e13c65972","modified":1511939201000},{"_id":"source/_posts/prime-test.md","hash":"d22ee2d5ff049b3dea992766a4f0ead370831dc5","modified":1511939201000},{"_id":"source/_posts/simple-stats-in-abtesting.md","hash":"f82b15ca772066fce731c83748727ecb3252d544","modified":1511939201000},{"_id":"source/_posts/svn-workflow-management.md","hash":"1f4e68716d7fc5592343f7aac6e4acc967d98430","modified":1511939201000},{"_id":"source/_posts/start-of-2016.md","hash":"10b8e28c10fcf10c7b6ccee0c4675a8279dfb49f","modified":1511939201000},{"_id":"source/_posts/taskgo-dev-note-1.md","hash":"6482af7639a21e7093514ce03f22b726671bff9f","modified":1511939201000},{"_id":"source/_posts/taskgo-dev-note-0.md","hash":"5b84163c285138e976fdbc737a5a2c87d63517cc","modified":1511939201000},{"_id":"source/_posts/tmux-install-and-config.md","hash":"4ce2250f0c1063cfc0ba7cb109b287c003ed39b7","modified":1511939201000},{"_id":"source/_posts/use-composer-and-monolog-in-project.md","hash":"6f9605d913eed6d7afbfdc28d2283f8a562fcdcd","modified":1511939201000},{"_id":"source/about/index.md","hash":"8c7dcfe47c6404e53b89792a696922025bb805d9","modified":1511939201000}],"Category":[{"name":"Life","_id":"cjd9o910o00046bk2hsm0khjb"},{"name":"study","_id":"cjd9o910t00096bk2ryopf3u7"},{"name":"数学","_id":"cjd9o9115000p6bk2s2iednp0"},{"name":"工程","_id":"cjd9o9117000y6bk2vgstbmvg"},{"name":"开发手册","_id":"cjd9o911800146bk2b0oqywmd"}],"Data":[],"Page":[{"_content":"<!doctype html>\n<html lang=\"en\">\n <head>\n  <meta charset=\"UTF-8\">\n  <title>404</title>\n </head>\n <body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://solnotes.com\" homePageName=\"返回主页\"></script>\n </body>\n</html>\n\n","source":"404.html","raw":"<!doctype html>\n<html lang=\"en\">\n <head>\n  <meta charset=\"UTF-8\">\n  <title>404</title>\n </head>\n <body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://solnotes.com\" homePageName=\"返回主页\"></script>\n </body>\n</html>\n\n","date":"2017-11-29T07:06:41.000Z","updated":"2017-11-29T07:06:41.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjd9o910800006bk2zhobnpzb","content":"<!doctype html>\n<html lang=\"en\">\n <head>\n  <meta charset=\"UTF-8\">\n  <title>404</title>\n </head>\n <body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"http://solnotes.com\" homepagename=\"返回主页\"></script>\n </body>\n</html>\n\n","site":{"data":{}},"excerpt":"","more":"<!doctype html>\n<html lang=\"en\">\n <head>\n  <meta charset=\"UTF-8\">\n  <title>404</title>\n </head>\n <body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"http://solnotes.com\" homepagename=\"返回主页\"></script>\n </body>\n</html>\n\n"},{"title":"About","date":"2015-04-14T08:35:08.000Z","_content":"\n#关于我\n\n- 阳关宅男一枚\n- 懒癌晚期\n- 小的时候希望长大了做一名科学家、没有实现\n- 现在业余时间保留着对数学和物理的兴趣\n- 热爱生活、爱运动、爱电影、爱游戏\n- 热爱计算机科学，虽然水平还很有限\n- 信仰道家文化、骑士精神\n- 愿作一名永远守护我家妹子的骑士\n\n![](http://7xiium.com1.z0.glb.clouddn.com/avatar.jpg)\n","source":"about/index.md","raw":"title: \"About\"\ndate: 2015-04-14 16:35:08\n---\n\n#关于我\n\n- 阳关宅男一枚\n- 懒癌晚期\n- 小的时候希望长大了做一名科学家、没有实现\n- 现在业余时间保留着对数学和物理的兴趣\n- 热爱生活、爱运动、爱电影、爱游戏\n- 热爱计算机科学，虽然水平还很有限\n- 信仰道家文化、骑士精神\n- 愿作一名永远守护我家妹子的骑士\n\n![](http://7xiium.com1.z0.glb.clouddn.com/avatar.jpg)\n","updated":"2017-11-29T07:06:41.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjd9o910i00026bk2ge5j1t19","content":"<p>#关于我</p>\n<ul>\n<li>阳关宅男一枚</li>\n<li>懒癌晚期</li>\n<li>小的时候希望长大了做一名科学家、没有实现</li>\n<li>现在业余时间保留着对数学和物理的兴趣</li>\n<li>热爱生活、爱运动、爱电影、爱游戏</li>\n<li>热爱计算机科学，虽然水平还很有限</li>\n<li>信仰道家文化、骑士精神</li>\n<li>愿作一名永远守护我家妹子的骑士</li>\n</ul>\n<p><img src=\"http://7xiium.com1.z0.glb.clouddn.com/avatar.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#关于我</p>\n<ul>\n<li>阳关宅男一枚</li>\n<li>懒癌晚期</li>\n<li>小的时候希望长大了做一名科学家、没有实现</li>\n<li>现在业余时间保留着对数学和物理的兴趣</li>\n<li>热爱生活、爱运动、爱电影、爱游戏</li>\n<li>热爱计算机科学，虽然水平还很有限</li>\n<li>信仰道家文化、骑士精神</li>\n<li>愿作一名永远守护我家妹子的骑士</li>\n</ul>\n<p><img src=\"http://7xiium.com1.z0.glb.clouddn.com/avatar.jpg\" alt=\"\"></p>\n"}],"Post":[{"title":"Hello World","date":"2015-04-14T04:13:42.000Z","_content":"\n## 启\n从工作开始就断断续续的有了写博客的想法，之前也在新浪博客和博客园写过一两篇尝试，但是都没有坚持下来，还是希望能够维护一个自己的博客。这个想法其实从工作开始每过一阵子就会出现一次，但是因为种种原因一直没有付诸于实践。\n<!-- more -->\n每次都没能下定决心，主要的原因有：\n- 太折腾。要搞定域名、博客程序、服务器、数据库等等。\n- 没干货。好吧，其实这个才是重点。\n- 写东西比较慢，文笔不好，也不愿意写太多生活方面的东西，还是希望能写一些技术方面的文章。\n\n## 承\n今天终于下定了决心，经过一番折腾基于Hexo和Github Pages搭建了这个博客。今后会一点一点完善。\n会做这个决定，主要是因为：\n- Github Pages提供了极大的便利，很多静态博客程序进入了我的视线。维护一个简单技术博客的成本降低了很多。\n- 同时我也有了一些时间用来折腾、学习新东西。\n- 维护博客的过程也会学到很多东西。\n- 希望能够将看的书和学习的经历记录下来，多了一个消化的过程，会对学习的东西有更深的认识。\n- 家里妹子的支持和鼓励。\n\n这一篇Hello World也是边改边写，用了一个多小时才写完的。\n不过也没关系，从现在开始一切也都还不晚，不是吗？\n\n2015年 春\n\nTo Be Continued ...\n\n","source":"_posts/hello-world.md","raw":"title: \"Hello World\"\ndate: 2015-04-14 12:13:42\ncategories:\n- Life\ntags:\n- hello world\n---\n\n## 启\n从工作开始就断断续续的有了写博客的想法，之前也在新浪博客和博客园写过一两篇尝试，但是都没有坚持下来，还是希望能够维护一个自己的博客。这个想法其实从工作开始每过一阵子就会出现一次，但是因为种种原因一直没有付诸于实践。\n<!-- more -->\n每次都没能下定决心，主要的原因有：\n- 太折腾。要搞定域名、博客程序、服务器、数据库等等。\n- 没干货。好吧，其实这个才是重点。\n- 写东西比较慢，文笔不好，也不愿意写太多生活方面的东西，还是希望能写一些技术方面的文章。\n\n## 承\n今天终于下定了决心，经过一番折腾基于Hexo和Github Pages搭建了这个博客。今后会一点一点完善。\n会做这个决定，主要是因为：\n- Github Pages提供了极大的便利，很多静态博客程序进入了我的视线。维护一个简单技术博客的成本降低了很多。\n- 同时我也有了一些时间用来折腾、学习新东西。\n- 维护博客的过程也会学到很多东西。\n- 希望能够将看的书和学习的经历记录下来，多了一个消化的过程，会对学习的东西有更深的认识。\n- 家里妹子的支持和鼓励。\n\n这一篇Hello World也是边改边写，用了一个多小时才写完的。\n不过也没关系，从现在开始一切也都还不晚，不是吗？\n\n2015年 春\n\nTo Be Continued ...\n\n","slug":"hello-world","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910f00016bk2sd1fl0me","content":"<h2 id=\"启\"><a href=\"#启\" class=\"headerlink\" title=\"启\"></a>启</h2><p>从工作开始就断断续续的有了写博客的想法，之前也在新浪博客和博客园写过一两篇尝试，但是都没有坚持下来，还是希望能够维护一个自己的博客。这个想法其实从工作开始每过一阵子就会出现一次，但是因为种种原因一直没有付诸于实践。<br><a id=\"more\"></a><br>每次都没能下定决心，主要的原因有：</p>\n<ul>\n<li>太折腾。要搞定域名、博客程序、服务器、数据库等等。</li>\n<li>没干货。好吧，其实这个才是重点。</li>\n<li>写东西比较慢，文笔不好，也不愿意写太多生活方面的东西，还是希望能写一些技术方面的文章。</li>\n</ul>\n<h2 id=\"承\"><a href=\"#承\" class=\"headerlink\" title=\"承\"></a>承</h2><p>今天终于下定了决心，经过一番折腾基于Hexo和Github Pages搭建了这个博客。今后会一点一点完善。<br>会做这个决定，主要是因为：</p>\n<ul>\n<li>Github Pages提供了极大的便利，很多静态博客程序进入了我的视线。维护一个简单技术博客的成本降低了很多。</li>\n<li>同时我也有了一些时间用来折腾、学习新东西。</li>\n<li>维护博客的过程也会学到很多东西。</li>\n<li>希望能够将看的书和学习的经历记录下来，多了一个消化的过程，会对学习的东西有更深的认识。</li>\n<li>家里妹子的支持和鼓励。</li>\n</ul>\n<p>这一篇Hello World也是边改边写，用了一个多小时才写完的。<br>不过也没关系，从现在开始一切也都还不晚，不是吗？</p>\n<p>2015年 春</p>\n<p>To Be Continued …</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"启\"><a href=\"#启\" class=\"headerlink\" title=\"启\"></a>启</h2><p>从工作开始就断断续续的有了写博客的想法，之前也在新浪博客和博客园写过一两篇尝试，但是都没有坚持下来，还是希望能够维护一个自己的博客。这个想法其实从工作开始每过一阵子就会出现一次，但是因为种种原因一直没有付诸于实践。<br>","more":"<br>每次都没能下定决心，主要的原因有：</p>\n<ul>\n<li>太折腾。要搞定域名、博客程序、服务器、数据库等等。</li>\n<li>没干货。好吧，其实这个才是重点。</li>\n<li>写东西比较慢，文笔不好，也不愿意写太多生活方面的东西，还是希望能写一些技术方面的文章。</li>\n</ul>\n<h2 id=\"承\"><a href=\"#承\" class=\"headerlink\" title=\"承\"></a>承</h2><p>今天终于下定了决心，经过一番折腾基于Hexo和Github Pages搭建了这个博客。今后会一点一点完善。<br>会做这个决定，主要是因为：</p>\n<ul>\n<li>Github Pages提供了极大的便利，很多静态博客程序进入了我的视线。维护一个简单技术博客的成本降低了很多。</li>\n<li>同时我也有了一些时间用来折腾、学习新东西。</li>\n<li>维护博客的过程也会学到很多东西。</li>\n<li>希望能够将看的书和学习的经历记录下来，多了一个消化的过程，会对学习的东西有更深的认识。</li>\n<li>家里妹子的支持和鼓励。</li>\n</ul>\n<p>这一篇Hello World也是边改边写，用了一个多小时才写完的。<br>不过也没关系，从现在开始一切也都还不晚，不是吗？</p>\n<p>2015年 春</p>\n<p>To Be Continued …</p>"},{"title":"PHP异步MySQL查询尝试","date":"2016-01-08T01:08:47.000Z","_content":"\n## 背景\n最近在做一个数据统计的项目，同一个接口往往需要获取不同类型的指标数据，处理后在同一个结果集中返回。现有方案是通过反范式化的视图表简化数据查询过程来保证接口响应时间的，不过冗余的数据存储增加了数据维护的工作量和复杂度，因为后端需要处理数据一致性、上下游依赖等问题。\n\n然后我们就想是否可以通过异步化的方式提高查询效率，从而降低对数据视图表的依赖。\n\n## 方案\n考虑到对已有项目的兼容，下述方案基于PHP+MySQL的技术选型。\n1. Model层封装对数据指标的异步查询，通过MySQL异步查询实现。\n2. Model层封装对数据指标的同步查询，API层异步调用多个Model层函数，通过RPC接口实现。\n3. Model层封装对数据指标的同步查询，API层异步调用多个API层接口，通过REST接口实现。\n\n## demo\n基于swoole分别实现方案1和方案2，并进行对比。\n\n## 性能对比\n\n## 总结","source":"_drafts/php-mysql-async-query-demo.md","raw":"title: \"PHP异步MySQL查询尝试\"\ndate: 2016-01-08 09:08:47\ncategories:\n- study\ntags:\n- php\n- mysql\n- swoole\n- workerman\n---\n\n## 背景\n最近在做一个数据统计的项目，同一个接口往往需要获取不同类型的指标数据，处理后在同一个结果集中返回。现有方案是通过反范式化的视图表简化数据查询过程来保证接口响应时间的，不过冗余的数据存储增加了数据维护的工作量和复杂度，因为后端需要处理数据一致性、上下游依赖等问题。\n\n然后我们就想是否可以通过异步化的方式提高查询效率，从而降低对数据视图表的依赖。\n\n## 方案\n考虑到对已有项目的兼容，下述方案基于PHP+MySQL的技术选型。\n1. Model层封装对数据指标的异步查询，通过MySQL异步查询实现。\n2. Model层封装对数据指标的同步查询，API层异步调用多个Model层函数，通过RPC接口实现。\n3. Model层封装对数据指标的同步查询，API层异步调用多个API层接口，通过REST接口实现。\n\n## demo\n基于swoole分别实现方案1和方案2，并进行对比。\n\n## 性能对比\n\n## 总结","slug":"php-mysql-async-query-demo","published":0,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910l00036bk2g5505cm3","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近在做一个数据统计的项目，同一个接口往往需要获取不同类型的指标数据，处理后在同一个结果集中返回。现有方案是通过反范式化的视图表简化数据查询过程来保证接口响应时间的，不过冗余的数据存储增加了数据维护的工作量和复杂度，因为后端需要处理数据一致性、上下游依赖等问题。</p>\n<p>然后我们就想是否可以通过异步化的方式提高查询效率，从而降低对数据视图表的依赖。</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>考虑到对已有项目的兼容，下述方案基于PHP+MySQL的技术选型。</p>\n<ol>\n<li>Model层封装对数据指标的异步查询，通过MySQL异步查询实现。</li>\n<li>Model层封装对数据指标的同步查询，API层异步调用多个Model层函数，通过RPC接口实现。</li>\n<li>Model层封装对数据指标的同步查询，API层异步调用多个API层接口，通过REST接口实现。</li>\n</ol>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>基于swoole分别实现方案1和方案2，并进行对比。</p>\n<h2 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近在做一个数据统计的项目，同一个接口往往需要获取不同类型的指标数据，处理后在同一个结果集中返回。现有方案是通过反范式化的视图表简化数据查询过程来保证接口响应时间的，不过冗余的数据存储增加了数据维护的工作量和复杂度，因为后端需要处理数据一致性、上下游依赖等问题。</p>\n<p>然后我们就想是否可以通过异步化的方式提高查询效率，从而降低对数据视图表的依赖。</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>考虑到对已有项目的兼容，下述方案基于PHP+MySQL的技术选型。</p>\n<ol>\n<li>Model层封装对数据指标的异步查询，通过MySQL异步查询实现。</li>\n<li>Model层封装对数据指标的同步查询，API层异步调用多个Model层函数，通过RPC接口实现。</li>\n<li>Model层封装对数据指标的同步查询，API层异步调用多个API层接口，通过REST接口实现。</li>\n</ol>\n<h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><p>基于swoole分别实现方案1和方案2，并进行对比。</p>\n<h2 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>"},{"title":"Quartz部署及开发学习","date":"2015-10-27T01:51:12.000Z","_content":"\n## 初识\n之前有个项目想做用户自定义规则的定时任务，类似于Crontab的效果。当时调研了一下，基于JAVA的开源作业调度框架Quartz可能是技术和文档最成熟的选择。最近项目中用到了Quartz，所以看了下文档，简单学习了Quartz的部署和开发。\n\n<!-- more -->\n\n## 了解\nQuartz是个作业调度框架，相比于Crontab支持秒级别的时间粒度，还支持作业的持久化和集群化的部署。\nQuartz的主要元素有：\n- Scheduler ：调度器，根据触发器的设置调度作业，和JobStore交互\n- Trigger ：触发器，触发作业，可以在触发的时候覆盖作业的数据\n- Job ：作业，处理具体工作\n- JobDetail ：包含作业数据，定义具体的作业实例\n- Scheduler Listener, Job Listener，Trigger Listener ：各种Listener\n\n![Quartz元素](http://7xiium.com1.z0.glb.clouddn.com/Quartz.png)\n\n## 持久化\nQuartz的项目中有持久化相关的DB建表SQL，我使用的MySQL InnoDB的建表语句，不过项目中的表结构和字段都没有注释，不太方便理解，表的说明还能通过google查到一些，字段的说明就比较少了，我测试了一下Quartz的持久化，结合google到的一些Quartz工作机制，给Quartz的主要字段增加了注释，记录如下。\n```\n--\n-- In your Quartz properties file, you'll need to set\n-- org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate\n--\n--\n-- By: Ron Cordell - roncordell\n--  I didn't see this anywhere, so I thought I'd post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.\n\nDROP TABLE IF EXISTS QRTZ_LOCKS;\nDROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;\nDROP TABLE IF EXISTS QRTZ_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;\nDROP TABLE IF EXISTS QRTZ_CALENDARS;\nDROP TABLE IF EXISTS QRTZ_JOB_DETAILS;\n\nCREATE TABLE QRTZ_LOCKS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称，同一集群下的Scheduler实例名称相同，Instance_Id不同',\nLOCK_NAME VARCHAR(40) NOT NULL COMMENT '锁名称，TRIGGER_ACCESS，STATE_ACCESS，JOB_ACCESS，CALENDAR_ACCESS，MISFIRE_ACCESS',\nPRIMARY KEY (SCHED_NAME,LOCK_NAME))\nENGINE=InnoDB COMMENT '存储锁以及获得锁的调度器名称。获取的锁不存在时创建，获得锁的调度器可以操作相应数据';\n\nCREATE TABLE QRTZ_SCHEDULER_STATE (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nINSTANCE_NAME VARCHAR(200) NOT NULL COMMENT 'Scheduler实例的唯一标识，配置文件中的Instance Id',\nLAST_CHECKIN_TIME BIGINT(13) NOT NULL COMMENT '最后检入时间',\nCHECKIN_INTERVAL BIGINT(13) NOT NULL COMMENT 'Scheduler 实例检入到数据库中的频率，单位毫秒',\nPRIMARY KEY (SCHED_NAME,INSTANCE_NAME))\nENGINE=InnoDB COMMENT '存储少量的有关Scheduler的状态信息，和别的Scheduler实例';\n\nCREATE TABLE QRTZ_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nJOB_NAME VARCHAR(200) NOT NULL COMMENT 'Job key',\nJOB_GROUP VARCHAR(200) NOT NULL COMMENT 'Job group 名称',\nDESCRIPTION VARCHAR(250) NULL COMMENT 'Trigger description， .withDescription()方法传入的string',\nNEXT_FIRE_TIME BIGINT(13) NULL COMMENT '下一次触发时间',\nPREV_FIRE_TIME BIGINT(13) NULL COMMENT '上一次触发时间，默认-1',\nPRIORITY INTEGER NULL COMMENT 'Trigger 优先级，默认5',\nTRIGGER_STATE VARCHAR(16) NOT NULL COMMENT 'Trigger状态，ACQUIRED：正常运行；PAUSED：暂停；BLOCKED：阻塞；ERROR：错误；（待补全） ',\nTRIGGER_TYPE VARCHAR(8) NOT NULL COMMENT 'Cron 或 Simple',\nSTART_TIME BIGINT(13) NOT NULL COMMENT 'Trigger开始i时间',\nEND_TIME BIGINT(13) NULL COMMENT 'Trigger结束时间',\nCALENDAR_NAME VARCHAR(200) NULL COMMENT 'Trigger关联的 Calendar name',\nMISFIRE_INSTR SMALLINT(2) NULL COMMENT 'misfire规则id',\nJOB_DATA BLOB NULL COMMENT '存储Trigger的JobDataMap等',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)\nREFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))\nENGINE=InnoDB COMMENT '存储已配置的Trigger的信息';\n\nCREATE TABLE QRTZ_FIRED_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nENTRY_ID VARCHAR(95) NOT NULL COMMENT '',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nINSTANCE_NAME VARCHAR(200) NOT NULL COMMENT 'Scheduler实例的唯一标识（应该是完成这次调度的Scheduler标识，待多实例环境测试验证）',\nFIRED_TIME BIGINT(13) NOT NULL COMMENT '触发时间',\nSCHED_TIME BIGINT(13) NOT NULL COMMENT '（疑似下一次触发时间，待验证）',\nPRIORITY INTEGER NOT NULL COMMENT 'Trigger 优先级',\nSTATE VARCHAR(16) NOT NULL COMMENT 'Trigger状态',\nJOB_NAME VARCHAR(200) NULL COMMENT 'Job key',\nJOB_GROUP VARCHAR(200) NULL COMMENT 'Job group 名称',\nIS_NONCONCURRENT VARCHAR(1) NULL COMMENT '是否不允许并发',\nREQUESTS_RECOVERY VARCHAR(1) NULL COMMENT 'Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发',\nPRIMARY KEY (SCHED_NAME,ENTRY_ID))\nENGINE=InnoDB COMMENT '存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息';\n\n\nCREATE TABLE QRTZ_SIMPLE_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nREPEAT_COUNT BIGINT(7) NOT NULL COMMENT '重复次数',\nREPEAT_INTERVAL BIGINT(12) NOT NULL COMMENT '重复间隔',\nTIMES_TRIGGERED BIGINT(10) NOT NULL COMMENT '触发次数',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\nREFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储简单的Trigger，包括重复次数、间隔、以及已触的次数';\n\nCREATE TABLE QRTZ_CRON_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nCRON_EXPRESSION VARCHAR(120) NOT NULL COMMENT '调度规则',\nTIME_ZONE_ID VARCHAR(80) COMMENT '时区',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\nREFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储CronTrigger，包括Cron表达式和时区信息';\n\nCREATE TABLE QRTZ_BLOB_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nBLOB_DATA BLOB NULL COMMENT '对于用户自定义的Trigger信息，无法提前设计字段，所以序列化后使用BLOB存储',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nINDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\nREFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储用户自定义的Trigger';\n\nCREATE TABLE QRTZ_SIMPROP_TRIGGERS\n  (\n    SCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\n    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\n    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\n    STR_PROP_1 VARCHAR(512) NULL COMMENT '字符串属性，占位用，下同',\n    STR_PROP_2 VARCHAR(512) NULL,\n    STR_PROP_3 VARCHAR(512) NULL,\n    INT_PROP_1 INT NULL,\n    INT_PROP_2 INT NULL,\n    LONG_PROP_1 BIGINT NULL,\n    LONG_PROP_2 BIGINT NULL,\n    DEC_PROP_1 NUMERIC(13,4) NULL,\n    DEC_PROP_2 NUMERIC(13,4) NULL,\n    BOOL_PROP_1 VARCHAR(1) NULL,\n    BOOL_PROP_2 VARCHAR(1) NULL,\n    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\n    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\n    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储trigger属性信息';\n\nCREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nPRIMARY KEY (SCHED_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储已暂停的Trigger组的信息';\n\nCREATE TABLE QRTZ_CALENDARS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nCALENDAR_NAME VARCHAR(200) NOT NULL COMMENT 'Calendar 名称',\nCALENDAR BLOB NOT NULL COMMENT 'Calendar 数据',\nPRIMARY KEY (SCHED_NAME,CALENDAR_NAME))\nENGINE=InnoDB COMMENT '存储Quartz的Calendar信息';\n\nCREATE TABLE QRTZ_JOB_DETAILS(\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nJOB_NAME VARCHAR(200) NOT NULL COMMENT 'Job key',\nJOB_GROUP VARCHAR(200) NOT NULL COMMENT 'Job group 名称',\nDESCRIPTION VARCHAR(250) NULL COMMENT 'Job 描述， .withDescription()方法传入的string',\nJOB_CLASS_NAME VARCHAR(250) NOT NULL COMMENT '实现Job的类名，trigger触发时调度此类的execute方法',\nIS_DURABLE VARCHAR(1) NOT NULL COMMENT '为true时，Job相关的trigger完成以后，Job数据继续保留',\nIS_NONCONCURRENT VARCHAR(1) NOT NULL COMMENT '是否不允许并发，为true时，如果下一次的触发事件到了，而上一次的job执行还未结束，则后续的触发会放入队列等待',\nIS_UPDATE_DATA VARCHAR(1) NOT NULL COMMENT '是否在多次调度之间更新JobDataMap',\nREQUESTS_RECOVERY VARCHAR(1) NOT NULL COMMENT 'Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发',\nJOB_DATA BLOB NULL COMMENT '存储JobDataMap等',\nPRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP))\nENGINE=InnoDB COMMENT '存储每一个已配置的Job的详细信息';\n\n\nCREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);\nCREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);\n\nCREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);\nCREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);\nCREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);\nCREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);\nCREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);\nCREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);\n\nCREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);\nCREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);\nCREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);\nCREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);\n\ncommit;\n```\n\n## 配置\nSpring的showcase项目中有Quartz集群化配置示例，可以根据项目需要做些调整。\n```\n#============================================================================\n# Configure Main Scheduler Properties\n#============================================================================\norg.quartz.scheduler.instanceName = MyClusteredScheduler\norg.quartz.scheduler.instanceId = AUTO\norg.quartz.scheduler.skipUpdateCheck = true\n#============================================================================\n# Configure ThreadPool\n#============================================================================\norg.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool\norg.quartz.threadPool.threadCount = 25\norg.quartz.threadPool.threadPriority = 5\n#============================================================================\n# Configure JobStore\n#============================================================================\norg.quartz.jobStore.misfireThreshold = 60000\norg.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate\norg.quartz.jobStore.useProperties = false\norg.quartz.jobStore.tablePrefix = QRTZ_\norg.quartz.jobStore.isClustered = true\norg.quartz.jobStore.clusterCheckinInterval = 20000\n#============================================================================\n# Configure DataSources\n#============================================================================\n#defined in applicationContext-quartz.xml\n```\napplicationContext-quartz.xml配置如下：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:util=\"http://www.springframework.org/schema/util\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd\"\n       default-lazy-init=\"false\">\n    <description>Quartz的定时集群任务配置</description>\n\n    <bean id=\"quartzDataSource\" class=\"org.apache.tomcat.jdbc.pool.DataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\n        <property name=\"url\" value=\"${jdbc.url}\" />\n        <property name=\"username\" value=\"${jdbc.username}\" />\n        <property name=\"password\" value=\"${jdbc.password}\" />\n    </bean>\n\n    <!-- Quartz集群Scheduler -->\n    <bean id=\"clusterQuartzScheduler\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n        <!--  quartz配置文件路径-->\n        <property name=\"configLocation\" value=\"classpath:/quartz.properties\" />\n        <!-- 启动时延期3秒开始任务 -->\n        <property name=\"startupDelay\" value=\"2\" />\n        <property name=\"autoStartup\" value=\"true\" />\n        <!-- 保存Job数据到数据库所需的数据源 -->\n        <property name=\"dataSource\" ref=\"quartzDataSource\" />\n        <!-- Job接受applicationContext的成员变量名 -->\n        <property name=\"applicationContextSchedulerContextKey\" value=\"applicationContext\" />\n        <property name=\"overwriteExistingJobs\" value=\"true\" />\n    </bean>\n</beans>\n```\n\n## 集群调度机制\n集群调度机制部分，gklifg的博客<sup>[\\[1\\]](#ref1)</sup>中做了很细致的分析和说明，我在此直接引用部分内容。\n\n![Quartz集群](http://img.blog.csdn.net/20140606160024250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\nQuartz的集群化配置是基于持久化的，需要使用JDBC等持久化到数据库的方式。因为Quartz集群中的各个节点并不感知其他节点的存在,只是通过数据库来进行间接的沟通。\n\n![Quartz集群调度机制](http://img.blog.csdn.net/20140606160208906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n一个调度器实例在执行涉及到分布式问题的数据库操作之前，需要先获取QRTZ_LOCKS表中相应的锁，获取到锁的实例可以进行相应的操作并更新相关数据的状态，事务提交以后，锁释放以供其他实例获取。\n\n通过这样的方式避免多个实例同时修改数据可能引起的问题。\n\n## 疑问\n在单元测试的时候，我发现如果给Quartz设置了startupDelay，那么如果在Quartz开始调度任务之前有Job被添加到了调度器，且Quartz开始调度时恰好有符合触发条件的Trigger，那么最初的1秒内调度器会检测到3次待触发的Trigger，并分配给不同的Worker执行。目前我没有找到原因，也不排除是自己的配置或者测试环境存在问题，这个需要后续跟进观察。\n\n## 总结\n总体来说，Quartz是一个非常强大的作业调度框架，Trigger可以包含JobDataMap的设计方式更是让我眼前一亮，在taskgo的设计和开发过程中会有很多可以借鉴Quartz的地方。\n\n## Update 2016-02-19\n最近看到有一篇文章介绍当当开发的elastic-job项目，目标是无中心化的分布式定时调度框架。重写了Quartz的基于数据库的分布式功能，改用Zookeeper实现注册中心，代码已经在Github开源，有时间可以学习一下。\n\n## reference\n<span id=\"ref1\">1. gklifg [quartz集群调度机制调研及源码分析](http://demo.netfoucs.com/gklifg/article/details/27090179) </span>\n2. [Quartz应用与集群原理分析](http://tech.meituan.com/mt-crm-quartz.html)\n3. [详解当当网的分布式作业框架elastic-job](http://www.infoq.com/cn/articles/dangdang-distributed-work-framework-elastic-job)","source":"_posts/learn-and-try-to-use-quartz.md","raw":"title: \"Quartz部署及开发学习\"\ndate: 2015-10-27 09:51:12\ncategories:\n- study\ntags:\n- Quartz\n---\n\n## 初识\n之前有个项目想做用户自定义规则的定时任务，类似于Crontab的效果。当时调研了一下，基于JAVA的开源作业调度框架Quartz可能是技术和文档最成熟的选择。最近项目中用到了Quartz，所以看了下文档，简单学习了Quartz的部署和开发。\n\n<!-- more -->\n\n## 了解\nQuartz是个作业调度框架，相比于Crontab支持秒级别的时间粒度，还支持作业的持久化和集群化的部署。\nQuartz的主要元素有：\n- Scheduler ：调度器，根据触发器的设置调度作业，和JobStore交互\n- Trigger ：触发器，触发作业，可以在触发的时候覆盖作业的数据\n- Job ：作业，处理具体工作\n- JobDetail ：包含作业数据，定义具体的作业实例\n- Scheduler Listener, Job Listener，Trigger Listener ：各种Listener\n\n![Quartz元素](http://7xiium.com1.z0.glb.clouddn.com/Quartz.png)\n\n## 持久化\nQuartz的项目中有持久化相关的DB建表SQL，我使用的MySQL InnoDB的建表语句，不过项目中的表结构和字段都没有注释，不太方便理解，表的说明还能通过google查到一些，字段的说明就比较少了，我测试了一下Quartz的持久化，结合google到的一些Quartz工作机制，给Quartz的主要字段增加了注释，记录如下。\n```\n--\n-- In your Quartz properties file, you'll need to set\n-- org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate\n--\n--\n-- By: Ron Cordell - roncordell\n--  I didn't see this anywhere, so I thought I'd post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.\n\nDROP TABLE IF EXISTS QRTZ_LOCKS;\nDROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;\nDROP TABLE IF EXISTS QRTZ_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;\nDROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;\nDROP TABLE IF EXISTS QRTZ_CALENDARS;\nDROP TABLE IF EXISTS QRTZ_JOB_DETAILS;\n\nCREATE TABLE QRTZ_LOCKS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称，同一集群下的Scheduler实例名称相同，Instance_Id不同',\nLOCK_NAME VARCHAR(40) NOT NULL COMMENT '锁名称，TRIGGER_ACCESS，STATE_ACCESS，JOB_ACCESS，CALENDAR_ACCESS，MISFIRE_ACCESS',\nPRIMARY KEY (SCHED_NAME,LOCK_NAME))\nENGINE=InnoDB COMMENT '存储锁以及获得锁的调度器名称。获取的锁不存在时创建，获得锁的调度器可以操作相应数据';\n\nCREATE TABLE QRTZ_SCHEDULER_STATE (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nINSTANCE_NAME VARCHAR(200) NOT NULL COMMENT 'Scheduler实例的唯一标识，配置文件中的Instance Id',\nLAST_CHECKIN_TIME BIGINT(13) NOT NULL COMMENT '最后检入时间',\nCHECKIN_INTERVAL BIGINT(13) NOT NULL COMMENT 'Scheduler 实例检入到数据库中的频率，单位毫秒',\nPRIMARY KEY (SCHED_NAME,INSTANCE_NAME))\nENGINE=InnoDB COMMENT '存储少量的有关Scheduler的状态信息，和别的Scheduler实例';\n\nCREATE TABLE QRTZ_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nJOB_NAME VARCHAR(200) NOT NULL COMMENT 'Job key',\nJOB_GROUP VARCHAR(200) NOT NULL COMMENT 'Job group 名称',\nDESCRIPTION VARCHAR(250) NULL COMMENT 'Trigger description， .withDescription()方法传入的string',\nNEXT_FIRE_TIME BIGINT(13) NULL COMMENT '下一次触发时间',\nPREV_FIRE_TIME BIGINT(13) NULL COMMENT '上一次触发时间，默认-1',\nPRIORITY INTEGER NULL COMMENT 'Trigger 优先级，默认5',\nTRIGGER_STATE VARCHAR(16) NOT NULL COMMENT 'Trigger状态，ACQUIRED：正常运行；PAUSED：暂停；BLOCKED：阻塞；ERROR：错误；（待补全） ',\nTRIGGER_TYPE VARCHAR(8) NOT NULL COMMENT 'Cron 或 Simple',\nSTART_TIME BIGINT(13) NOT NULL COMMENT 'Trigger开始i时间',\nEND_TIME BIGINT(13) NULL COMMENT 'Trigger结束时间',\nCALENDAR_NAME VARCHAR(200) NULL COMMENT 'Trigger关联的 Calendar name',\nMISFIRE_INSTR SMALLINT(2) NULL COMMENT 'misfire规则id',\nJOB_DATA BLOB NULL COMMENT '存储Trigger的JobDataMap等',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)\nREFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))\nENGINE=InnoDB COMMENT '存储已配置的Trigger的信息';\n\nCREATE TABLE QRTZ_FIRED_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nENTRY_ID VARCHAR(95) NOT NULL COMMENT '',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nINSTANCE_NAME VARCHAR(200) NOT NULL COMMENT 'Scheduler实例的唯一标识（应该是完成这次调度的Scheduler标识，待多实例环境测试验证）',\nFIRED_TIME BIGINT(13) NOT NULL COMMENT '触发时间',\nSCHED_TIME BIGINT(13) NOT NULL COMMENT '（疑似下一次触发时间，待验证）',\nPRIORITY INTEGER NOT NULL COMMENT 'Trigger 优先级',\nSTATE VARCHAR(16) NOT NULL COMMENT 'Trigger状态',\nJOB_NAME VARCHAR(200) NULL COMMENT 'Job key',\nJOB_GROUP VARCHAR(200) NULL COMMENT 'Job group 名称',\nIS_NONCONCURRENT VARCHAR(1) NULL COMMENT '是否不允许并发',\nREQUESTS_RECOVERY VARCHAR(1) NULL COMMENT 'Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发',\nPRIMARY KEY (SCHED_NAME,ENTRY_ID))\nENGINE=InnoDB COMMENT '存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息';\n\n\nCREATE TABLE QRTZ_SIMPLE_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nREPEAT_COUNT BIGINT(7) NOT NULL COMMENT '重复次数',\nREPEAT_INTERVAL BIGINT(12) NOT NULL COMMENT '重复间隔',\nTIMES_TRIGGERED BIGINT(10) NOT NULL COMMENT '触发次数',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\nREFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储简单的Trigger，包括重复次数、间隔、以及已触的次数';\n\nCREATE TABLE QRTZ_CRON_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nCRON_EXPRESSION VARCHAR(120) NOT NULL COMMENT '调度规则',\nTIME_ZONE_ID VARCHAR(80) COMMENT '时区',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\nREFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储CronTrigger，包括Cron表达式和时区信息';\n\nCREATE TABLE QRTZ_BLOB_TRIGGERS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nBLOB_DATA BLOB NULL COMMENT '对于用户自定义的Trigger信息，无法提前设计字段，所以序列化后使用BLOB存储',\nPRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\nINDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),\nFOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\nREFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储用户自定义的Trigger';\n\nCREATE TABLE QRTZ_SIMPROP_TRIGGERS\n  (\n    SCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\n    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT 'Trigger key',\n    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\n    STR_PROP_1 VARCHAR(512) NULL COMMENT '字符串属性，占位用，下同',\n    STR_PROP_2 VARCHAR(512) NULL,\n    STR_PROP_3 VARCHAR(512) NULL,\n    INT_PROP_1 INT NULL,\n    INT_PROP_2 INT NULL,\n    LONG_PROP_1 BIGINT NULL,\n    LONG_PROP_2 BIGINT NULL,\n    DEC_PROP_1 NUMERIC(13,4) NULL,\n    DEC_PROP_2 NUMERIC(13,4) NULL,\n    BOOL_PROP_1 VARCHAR(1) NULL,\n    BOOL_PROP_2 VARCHAR(1) NULL,\n    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),\n    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)\n    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储trigger属性信息';\n\nCREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nTRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT 'Trigger group 名称',\nPRIMARY KEY (SCHED_NAME,TRIGGER_GROUP))\nENGINE=InnoDB COMMENT '存储已暂停的Trigger组的信息';\n\nCREATE TABLE QRTZ_CALENDARS (\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nCALENDAR_NAME VARCHAR(200) NOT NULL COMMENT 'Calendar 名称',\nCALENDAR BLOB NOT NULL COMMENT 'Calendar 数据',\nPRIMARY KEY (SCHED_NAME,CALENDAR_NAME))\nENGINE=InnoDB COMMENT '存储Quartz的Calendar信息';\n\nCREATE TABLE QRTZ_JOB_DETAILS(\nSCHED_NAME VARCHAR(120) NOT NULL COMMENT 'Scheduler名称',\nJOB_NAME VARCHAR(200) NOT NULL COMMENT 'Job key',\nJOB_GROUP VARCHAR(200) NOT NULL COMMENT 'Job group 名称',\nDESCRIPTION VARCHAR(250) NULL COMMENT 'Job 描述， .withDescription()方法传入的string',\nJOB_CLASS_NAME VARCHAR(250) NOT NULL COMMENT '实现Job的类名，trigger触发时调度此类的execute方法',\nIS_DURABLE VARCHAR(1) NOT NULL COMMENT '为true时，Job相关的trigger完成以后，Job数据继续保留',\nIS_NONCONCURRENT VARCHAR(1) NOT NULL COMMENT '是否不允许并发，为true时，如果下一次的触发事件到了，而上一次的job执行还未结束，则后续的触发会放入队列等待',\nIS_UPDATE_DATA VARCHAR(1) NOT NULL COMMENT '是否在多次调度之间更新JobDataMap',\nREQUESTS_RECOVERY VARCHAR(1) NOT NULL COMMENT 'Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发',\nJOB_DATA BLOB NULL COMMENT '存储JobDataMap等',\nPRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP))\nENGINE=InnoDB COMMENT '存储每一个已配置的Job的详细信息';\n\n\nCREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);\nCREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);\n\nCREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);\nCREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);\nCREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);\nCREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);\nCREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);\nCREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);\nCREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);\n\nCREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);\nCREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);\nCREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);\nCREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);\nCREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);\n\ncommit;\n```\n\n## 配置\nSpring的showcase项目中有Quartz集群化配置示例，可以根据项目需要做些调整。\n```\n#============================================================================\n# Configure Main Scheduler Properties\n#============================================================================\norg.quartz.scheduler.instanceName = MyClusteredScheduler\norg.quartz.scheduler.instanceId = AUTO\norg.quartz.scheduler.skipUpdateCheck = true\n#============================================================================\n# Configure ThreadPool\n#============================================================================\norg.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool\norg.quartz.threadPool.threadCount = 25\norg.quartz.threadPool.threadPriority = 5\n#============================================================================\n# Configure JobStore\n#============================================================================\norg.quartz.jobStore.misfireThreshold = 60000\norg.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate\norg.quartz.jobStore.useProperties = false\norg.quartz.jobStore.tablePrefix = QRTZ_\norg.quartz.jobStore.isClustered = true\norg.quartz.jobStore.clusterCheckinInterval = 20000\n#============================================================================\n# Configure DataSources\n#============================================================================\n#defined in applicationContext-quartz.xml\n```\napplicationContext-quartz.xml配置如下：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:util=\"http://www.springframework.org/schema/util\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd\"\n       default-lazy-init=\"false\">\n    <description>Quartz的定时集群任务配置</description>\n\n    <bean id=\"quartzDataSource\" class=\"org.apache.tomcat.jdbc.pool.DataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\n        <property name=\"url\" value=\"${jdbc.url}\" />\n        <property name=\"username\" value=\"${jdbc.username}\" />\n        <property name=\"password\" value=\"${jdbc.password}\" />\n    </bean>\n\n    <!-- Quartz集群Scheduler -->\n    <bean id=\"clusterQuartzScheduler\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n        <!--  quartz配置文件路径-->\n        <property name=\"configLocation\" value=\"classpath:/quartz.properties\" />\n        <!-- 启动时延期3秒开始任务 -->\n        <property name=\"startupDelay\" value=\"2\" />\n        <property name=\"autoStartup\" value=\"true\" />\n        <!-- 保存Job数据到数据库所需的数据源 -->\n        <property name=\"dataSource\" ref=\"quartzDataSource\" />\n        <!-- Job接受applicationContext的成员变量名 -->\n        <property name=\"applicationContextSchedulerContextKey\" value=\"applicationContext\" />\n        <property name=\"overwriteExistingJobs\" value=\"true\" />\n    </bean>\n</beans>\n```\n\n## 集群调度机制\n集群调度机制部分，gklifg的博客<sup>[\\[1\\]](#ref1)</sup>中做了很细致的分析和说明，我在此直接引用部分内容。\n\n![Quartz集群](http://img.blog.csdn.net/20140606160024250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\nQuartz的集群化配置是基于持久化的，需要使用JDBC等持久化到数据库的方式。因为Quartz集群中的各个节点并不感知其他节点的存在,只是通过数据库来进行间接的沟通。\n\n![Quartz集群调度机制](http://img.blog.csdn.net/20140606160208906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n一个调度器实例在执行涉及到分布式问题的数据库操作之前，需要先获取QRTZ_LOCKS表中相应的锁，获取到锁的实例可以进行相应的操作并更新相关数据的状态，事务提交以后，锁释放以供其他实例获取。\n\n通过这样的方式避免多个实例同时修改数据可能引起的问题。\n\n## 疑问\n在单元测试的时候，我发现如果给Quartz设置了startupDelay，那么如果在Quartz开始调度任务之前有Job被添加到了调度器，且Quartz开始调度时恰好有符合触发条件的Trigger，那么最初的1秒内调度器会检测到3次待触发的Trigger，并分配给不同的Worker执行。目前我没有找到原因，也不排除是自己的配置或者测试环境存在问题，这个需要后续跟进观察。\n\n## 总结\n总体来说，Quartz是一个非常强大的作业调度框架，Trigger可以包含JobDataMap的设计方式更是让我眼前一亮，在taskgo的设计和开发过程中会有很多可以借鉴Quartz的地方。\n\n## Update 2016-02-19\n最近看到有一篇文章介绍当当开发的elastic-job项目，目标是无中心化的分布式定时调度框架。重写了Quartz的基于数据库的分布式功能，改用Zookeeper实现注册中心，代码已经在Github开源，有时间可以学习一下。\n\n## reference\n<span id=\"ref1\">1. gklifg [quartz集群调度机制调研及源码分析](http://demo.netfoucs.com/gklifg/article/details/27090179) </span>\n2. [Quartz应用与集群原理分析](http://tech.meituan.com/mt-crm-quartz.html)\n3. [详解当当网的分布式作业框架elastic-job](http://www.infoq.com/cn/articles/dangdang-distributed-work-framework-elastic-job)","slug":"learn-and-try-to-use-quartz","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910p00066bk247c4oals","content":"<h2 id=\"初识\"><a href=\"#初识\" class=\"headerlink\" title=\"初识\"></a>初识</h2><p>之前有个项目想做用户自定义规则的定时任务，类似于Crontab的效果。当时调研了一下，基于JAVA的开源作业调度框架Quartz可能是技术和文档最成熟的选择。最近项目中用到了Quartz，所以看了下文档，简单学习了Quartz的部署和开发。</p>\n<a id=\"more\"></a>\n<h2 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h2><p>Quartz是个作业调度框架，相比于Crontab支持秒级别的时间粒度，还支持作业的持久化和集群化的部署。<br>Quartz的主要元素有：</p>\n<ul>\n<li>Scheduler ：调度器，根据触发器的设置调度作业，和JobStore交互</li>\n<li>Trigger ：触发器，触发作业，可以在触发的时候覆盖作业的数据</li>\n<li>Job ：作业，处理具体工作</li>\n<li>JobDetail ：包含作业数据，定义具体的作业实例</li>\n<li>Scheduler Listener, Job Listener，Trigger Listener ：各种Listener</li>\n</ul>\n<p><img src=\"http://7xiium.com1.z0.glb.clouddn.com/Quartz.png\" alt=\"Quartz元素\"></p>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>Quartz的项目中有持久化相关的DB建表SQL，我使用的MySQL InnoDB的建表语句，不过项目中的表结构和字段都没有注释，不太方便理解，表的说明还能通过google查到一些，字段的说明就比较少了，我测试了一下Quartz的持久化，结合google到的一些Quartz工作机制，给Quartz的主要字段增加了注释，记录如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--</span><br><span class=\"line\">-- In your Quartz properties file, you&apos;ll need to set</span><br><span class=\"line\">-- org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class=\"line\">--</span><br><span class=\"line\">--</span><br><span class=\"line\">-- By: Ron Cordell - roncordell</span><br><span class=\"line\">--  I didn&apos;t see this anywhere, so I thought I&apos;d post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.</span><br><span class=\"line\"></span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_LOCKS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_CALENDARS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_LOCKS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称，同一集群下的Scheduler实例名称相同，Instance_Id不同&apos;,</span><br><span class=\"line\">LOCK_NAME VARCHAR(40) NOT NULL COMMENT &apos;锁名称，TRIGGER_ACCESS，STATE_ACCESS，JOB_ACCESS，CALENDAR_ACCESS，MISFIRE_ACCESS&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,LOCK_NAME))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储锁以及获得锁的调度器名称。获取的锁不存在时创建，获得锁的调度器可以操作相应数据&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_SCHEDULER_STATE (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT &apos;Scheduler实例的唯一标识，配置文件中的Instance Id&apos;,</span><br><span class=\"line\">LAST_CHECKIN_TIME BIGINT(13) NOT NULL COMMENT &apos;最后检入时间&apos;,</span><br><span class=\"line\">CHECKIN_INTERVAL BIGINT(13) NOT NULL COMMENT &apos;Scheduler 实例检入到数据库中的频率，单位毫秒&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,INSTANCE_NAME))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储少量的有关Scheduler的状态信息，和别的Scheduler实例&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">JOB_NAME VARCHAR(200) NOT NULL COMMENT &apos;Job key&apos;,</span><br><span class=\"line\">JOB_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Job group 名称&apos;,</span><br><span class=\"line\">DESCRIPTION VARCHAR(250) NULL COMMENT &apos;Trigger description， .withDescription()方法传入的string&apos;,</span><br><span class=\"line\">NEXT_FIRE_TIME BIGINT(13) NULL COMMENT &apos;下一次触发时间&apos;,</span><br><span class=\"line\">PREV_FIRE_TIME BIGINT(13) NULL COMMENT &apos;上一次触发时间，默认-1&apos;,</span><br><span class=\"line\">PRIORITY INTEGER NULL COMMENT &apos;Trigger 优先级，默认5&apos;,</span><br><span class=\"line\">TRIGGER_STATE VARCHAR(16) NOT NULL COMMENT &apos;Trigger状态，ACQUIRED：正常运行；PAUSED：暂停；BLOCKED：阻塞；ERROR：错误；（待补全） &apos;,</span><br><span class=\"line\">TRIGGER_TYPE VARCHAR(8) NOT NULL COMMENT &apos;Cron 或 Simple&apos;,</span><br><span class=\"line\">START_TIME BIGINT(13) NOT NULL COMMENT &apos;Trigger开始i时间&apos;,</span><br><span class=\"line\">END_TIME BIGINT(13) NULL COMMENT &apos;Trigger结束时间&apos;,</span><br><span class=\"line\">CALENDAR_NAME VARCHAR(200) NULL COMMENT &apos;Trigger关联的 Calendar name&apos;,</span><br><span class=\"line\">MISFIRE_INSTR SMALLINT(2) NULL COMMENT &apos;misfire规则id&apos;,</span><br><span class=\"line\">JOB_DATA BLOB NULL COMMENT &apos;存储Trigger的JobDataMap等&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储已配置的Trigger的信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_FIRED_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">ENTRY_ID VARCHAR(95) NOT NULL COMMENT &apos;&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT &apos;Scheduler实例的唯一标识（应该是完成这次调度的Scheduler标识，待多实例环境测试验证）&apos;,</span><br><span class=\"line\">FIRED_TIME BIGINT(13) NOT NULL COMMENT &apos;触发时间&apos;,</span><br><span class=\"line\">SCHED_TIME BIGINT(13) NOT NULL COMMENT &apos;（疑似下一次触发时间，待验证）&apos;,</span><br><span class=\"line\">PRIORITY INTEGER NOT NULL COMMENT &apos;Trigger 优先级&apos;,</span><br><span class=\"line\">STATE VARCHAR(16) NOT NULL COMMENT &apos;Trigger状态&apos;,</span><br><span class=\"line\">JOB_NAME VARCHAR(200) NULL COMMENT &apos;Job key&apos;,</span><br><span class=\"line\">JOB_GROUP VARCHAR(200) NULL COMMENT &apos;Job group 名称&apos;,</span><br><span class=\"line\">IS_NONCONCURRENT VARCHAR(1) NULL COMMENT &apos;是否不允许并发&apos;,</span><br><span class=\"line\">REQUESTS_RECOVERY VARCHAR(1) NULL COMMENT &apos;Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,ENTRY_ID))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_SIMPLE_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">REPEAT_COUNT BIGINT(7) NOT NULL COMMENT &apos;重复次数&apos;,</span><br><span class=\"line\">REPEAT_INTERVAL BIGINT(12) NOT NULL COMMENT &apos;重复间隔&apos;,</span><br><span class=\"line\">TIMES_TRIGGERED BIGINT(10) NOT NULL COMMENT &apos;触发次数&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储简单的Trigger，包括重复次数、间隔、以及已触的次数&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_CRON_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">CRON_EXPRESSION VARCHAR(120) NOT NULL COMMENT &apos;调度规则&apos;,</span><br><span class=\"line\">TIME_ZONE_ID VARCHAR(80) COMMENT &apos;时区&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储CronTrigger，包括Cron表达式和时区信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_BLOB_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">BLOB_DATA BLOB NULL COMMENT &apos;对于用户自定义的Trigger信息，无法提前设计字段，所以序列化后使用BLOB存储&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">INDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储用户自定义的Trigger&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_SIMPROP_TRIGGERS</span><br><span class=\"line\">  (</span><br><span class=\"line\">    SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">    STR_PROP_1 VARCHAR(512) NULL COMMENT &apos;字符串属性，占位用，下同&apos;,</span><br><span class=\"line\">    STR_PROP_2 VARCHAR(512) NULL,</span><br><span class=\"line\">    STR_PROP_3 VARCHAR(512) NULL,</span><br><span class=\"line\">    INT_PROP_1 INT NULL,</span><br><span class=\"line\">    INT_PROP_2 INT NULL,</span><br><span class=\"line\">    LONG_PROP_1 BIGINT NULL,</span><br><span class=\"line\">    LONG_PROP_2 BIGINT NULL,</span><br><span class=\"line\">    DEC_PROP_1 NUMERIC(13,4) NULL,</span><br><span class=\"line\">    DEC_PROP_2 NUMERIC(13,4) NULL,</span><br><span class=\"line\">    BOOL_PROP_1 VARCHAR(1) NULL,</span><br><span class=\"line\">    BOOL_PROP_2 VARCHAR(1) NULL,</span><br><span class=\"line\">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储trigger属性信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储已暂停的Trigger组的信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_CALENDARS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">CALENDAR_NAME VARCHAR(200) NOT NULL COMMENT &apos;Calendar 名称&apos;,</span><br><span class=\"line\">CALENDAR BLOB NOT NULL COMMENT &apos;Calendar 数据&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,CALENDAR_NAME))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储Quartz的Calendar信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_JOB_DETAILS(</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">JOB_NAME VARCHAR(200) NOT NULL COMMENT &apos;Job key&apos;,</span><br><span class=\"line\">JOB_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Job group 名称&apos;,</span><br><span class=\"line\">DESCRIPTION VARCHAR(250) NULL COMMENT &apos;Job 描述， .withDescription()方法传入的string&apos;,</span><br><span class=\"line\">JOB_CLASS_NAME VARCHAR(250) NOT NULL COMMENT &apos;实现Job的类名，trigger触发时调度此类的execute方法&apos;,</span><br><span class=\"line\">IS_DURABLE VARCHAR(1) NOT NULL COMMENT &apos;为true时，Job相关的trigger完成以后，Job数据继续保留&apos;,</span><br><span class=\"line\">IS_NONCONCURRENT VARCHAR(1) NOT NULL COMMENT &apos;是否不允许并发，为true时，如果下一次的触发事件到了，而上一次的job执行还未结束，则后续的触发会放入队列等待&apos;,</span><br><span class=\"line\">IS_UPDATE_DATA VARCHAR(1) NOT NULL COMMENT &apos;是否在多次调度之间更新JobDataMap&apos;,</span><br><span class=\"line\">REQUESTS_RECOVERY VARCHAR(1) NOT NULL COMMENT &apos;Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发&apos;,</span><br><span class=\"line\">JOB_DATA BLOB NULL COMMENT &apos;存储JobDataMap等&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储每一个已配置的Job的详细信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span><br><span class=\"line\"></span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Spring的showcase项目中有Quartz集群化配置示例，可以根据项目需要做些调整。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure Main Scheduler Properties</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.scheduler.instanceName = MyClusteredScheduler</span><br><span class=\"line\">org.quartz.scheduler.instanceId = AUTO</span><br><span class=\"line\">org.quartz.scheduler.skipUpdateCheck = true</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure ThreadPool</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool</span><br><span class=\"line\">org.quartz.threadPool.threadCount = 25</span><br><span class=\"line\">org.quartz.threadPool.threadPriority = 5</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure JobStore</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.jobStore.misfireThreshold = 60000</span><br><span class=\"line\">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class=\"line\">org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class=\"line\">org.quartz.jobStore.useProperties = false</span><br><span class=\"line\">org.quartz.jobStore.tablePrefix = QRTZ_</span><br><span class=\"line\">org.quartz.jobStore.isClustered = true</span><br><span class=\"line\">org.quartz.jobStore.clusterCheckinInterval = 20000</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure DataSources</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">#defined in applicationContext-quartz.xml</span><br></pre></td></tr></table></figure></p>\n<p>applicationContext-quartz.xml配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class=\"line\">                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;</span><br><span class=\"line\">       default-lazy-init=&quot;false&quot;&gt;</span><br><span class=\"line\">    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;quartzDataSource&quot; class=&quot;org.apache.tomcat.jdbc.pool.DataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- Quartz集群Scheduler --&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;clusterQuartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class=\"line\">        &lt;!--  quartz配置文件路径--&gt;</span><br><span class=\"line\">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:/quartz.properties&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- 启动时延期3秒开始任务 --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;startupDelay&quot; value=&quot;2&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;autoStartup&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;dataSource&quot; ref=&quot;quartzDataSource&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- Job接受applicationContext的成员变量名 --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContext&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"集群调度机制\"><a href=\"#集群调度机制\" class=\"headerlink\" title=\"集群调度机制\"></a>集群调度机制</h2><p>集群调度机制部分，gklifg的博客<sup><a href=\"#ref1\">[1]</a></sup>中做了很细致的分析和说明，我在此直接引用部分内容。</p>\n<p><img src=\"http://img.blog.csdn.net/20140606160024250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Quartz集群\"><br>Quartz的集群化配置是基于持久化的，需要使用JDBC等持久化到数据库的方式。因为Quartz集群中的各个节点并不感知其他节点的存在,只是通过数据库来进行间接的沟通。</p>\n<p><img src=\"http://img.blog.csdn.net/20140606160208906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Quartz集群调度机制\"><br>一个调度器实例在执行涉及到分布式问题的数据库操作之前，需要先获取QRTZ_LOCKS表中相应的锁，获取到锁的实例可以进行相应的操作并更新相关数据的状态，事务提交以后，锁释放以供其他实例获取。</p>\n<p>通过这样的方式避免多个实例同时修改数据可能引起的问题。</p>\n<h2 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h2><p>在单元测试的时候，我发现如果给Quartz设置了startupDelay，那么如果在Quartz开始调度任务之前有Job被添加到了调度器，且Quartz开始调度时恰好有符合触发条件的Trigger，那么最初的1秒内调度器会检测到3次待触发的Trigger，并分配给不同的Worker执行。目前我没有找到原因，也不排除是自己的配置或者测试环境存在问题，这个需要后续跟进观察。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总体来说，Quartz是一个非常强大的作业调度框架，Trigger可以包含JobDataMap的设计方式更是让我眼前一亮，在taskgo的设计和开发过程中会有很多可以借鉴Quartz的地方。</p>\n<h2 id=\"Update-2016-02-19\"><a href=\"#Update-2016-02-19\" class=\"headerlink\" title=\"Update 2016-02-19\"></a>Update 2016-02-19</h2><p>最近看到有一篇文章介绍当当开发的elastic-job项目，目标是无中心化的分布式定时调度框架。重写了Quartz的基于数据库的分布式功能，改用Zookeeper实现注册中心，代码已经在Github开源，有时间可以学习一下。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><span id=\"ref1\">1. gklifg <a href=\"http://demo.netfoucs.com/gklifg/article/details/27090179\" target=\"_blank\" rel=\"noopener\">quartz集群调度机制调研及源码分析</a> </span></p>\n<ol>\n<li><a href=\"http://tech.meituan.com/mt-crm-quartz.html\" target=\"_blank\" rel=\"noopener\">Quartz应用与集群原理分析</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/dangdang-distributed-work-framework-elastic-job\" target=\"_blank\" rel=\"noopener\">详解当当网的分布式作业框架elastic-job</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"初识\"><a href=\"#初识\" class=\"headerlink\" title=\"初识\"></a>初识</h2><p>之前有个项目想做用户自定义规则的定时任务，类似于Crontab的效果。当时调研了一下，基于JAVA的开源作业调度框架Quartz可能是技术和文档最成熟的选择。最近项目中用到了Quartz，所以看了下文档，简单学习了Quartz的部署和开发。</p>","more":"<h2 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h2><p>Quartz是个作业调度框架，相比于Crontab支持秒级别的时间粒度，还支持作业的持久化和集群化的部署。<br>Quartz的主要元素有：</p>\n<ul>\n<li>Scheduler ：调度器，根据触发器的设置调度作业，和JobStore交互</li>\n<li>Trigger ：触发器，触发作业，可以在触发的时候覆盖作业的数据</li>\n<li>Job ：作业，处理具体工作</li>\n<li>JobDetail ：包含作业数据，定义具体的作业实例</li>\n<li>Scheduler Listener, Job Listener，Trigger Listener ：各种Listener</li>\n</ul>\n<p><img src=\"http://7xiium.com1.z0.glb.clouddn.com/Quartz.png\" alt=\"Quartz元素\"></p>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><p>Quartz的项目中有持久化相关的DB建表SQL，我使用的MySQL InnoDB的建表语句，不过项目中的表结构和字段都没有注释，不太方便理解，表的说明还能通过google查到一些，字段的说明就比较少了，我测试了一下Quartz的持久化，结合google到的一些Quartz工作机制，给Quartz的主要字段增加了注释，记录如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--</span><br><span class=\"line\">-- In your Quartz properties file, you&apos;ll need to set</span><br><span class=\"line\">-- org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class=\"line\">--</span><br><span class=\"line\">--</span><br><span class=\"line\">-- By: Ron Cordell - roncordell</span><br><span class=\"line\">--  I didn&apos;t see this anywhere, so I thought I&apos;d post it here. This is the script from Quartz to create the tables in a MySQL database, modified to use INNODB instead of MYISAM.</span><br><span class=\"line\"></span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_LOCKS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_CALENDARS;</span><br><span class=\"line\">DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_LOCKS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称，同一集群下的Scheduler实例名称相同，Instance_Id不同&apos;,</span><br><span class=\"line\">LOCK_NAME VARCHAR(40) NOT NULL COMMENT &apos;锁名称，TRIGGER_ACCESS，STATE_ACCESS，JOB_ACCESS，CALENDAR_ACCESS，MISFIRE_ACCESS&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,LOCK_NAME))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储锁以及获得锁的调度器名称。获取的锁不存在时创建，获得锁的调度器可以操作相应数据&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_SCHEDULER_STATE (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT &apos;Scheduler实例的唯一标识，配置文件中的Instance Id&apos;,</span><br><span class=\"line\">LAST_CHECKIN_TIME BIGINT(13) NOT NULL COMMENT &apos;最后检入时间&apos;,</span><br><span class=\"line\">CHECKIN_INTERVAL BIGINT(13) NOT NULL COMMENT &apos;Scheduler 实例检入到数据库中的频率，单位毫秒&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,INSTANCE_NAME))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储少量的有关Scheduler的状态信息，和别的Scheduler实例&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">JOB_NAME VARCHAR(200) NOT NULL COMMENT &apos;Job key&apos;,</span><br><span class=\"line\">JOB_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Job group 名称&apos;,</span><br><span class=\"line\">DESCRIPTION VARCHAR(250) NULL COMMENT &apos;Trigger description， .withDescription()方法传入的string&apos;,</span><br><span class=\"line\">NEXT_FIRE_TIME BIGINT(13) NULL COMMENT &apos;下一次触发时间&apos;,</span><br><span class=\"line\">PREV_FIRE_TIME BIGINT(13) NULL COMMENT &apos;上一次触发时间，默认-1&apos;,</span><br><span class=\"line\">PRIORITY INTEGER NULL COMMENT &apos;Trigger 优先级，默认5&apos;,</span><br><span class=\"line\">TRIGGER_STATE VARCHAR(16) NOT NULL COMMENT &apos;Trigger状态，ACQUIRED：正常运行；PAUSED：暂停；BLOCKED：阻塞；ERROR：错误；（待补全） &apos;,</span><br><span class=\"line\">TRIGGER_TYPE VARCHAR(8) NOT NULL COMMENT &apos;Cron 或 Simple&apos;,</span><br><span class=\"line\">START_TIME BIGINT(13) NOT NULL COMMENT &apos;Trigger开始i时间&apos;,</span><br><span class=\"line\">END_TIME BIGINT(13) NULL COMMENT &apos;Trigger结束时间&apos;,</span><br><span class=\"line\">CALENDAR_NAME VARCHAR(200) NULL COMMENT &apos;Trigger关联的 Calendar name&apos;,</span><br><span class=\"line\">MISFIRE_INSTR SMALLINT(2) NULL COMMENT &apos;misfire规则id&apos;,</span><br><span class=\"line\">JOB_DATA BLOB NULL COMMENT &apos;存储Trigger的JobDataMap等&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储已配置的Trigger的信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_FIRED_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">ENTRY_ID VARCHAR(95) NOT NULL COMMENT &apos;&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">INSTANCE_NAME VARCHAR(200) NOT NULL COMMENT &apos;Scheduler实例的唯一标识（应该是完成这次调度的Scheduler标识，待多实例环境测试验证）&apos;,</span><br><span class=\"line\">FIRED_TIME BIGINT(13) NOT NULL COMMENT &apos;触发时间&apos;,</span><br><span class=\"line\">SCHED_TIME BIGINT(13) NOT NULL COMMENT &apos;（疑似下一次触发时间，待验证）&apos;,</span><br><span class=\"line\">PRIORITY INTEGER NOT NULL COMMENT &apos;Trigger 优先级&apos;,</span><br><span class=\"line\">STATE VARCHAR(16) NOT NULL COMMENT &apos;Trigger状态&apos;,</span><br><span class=\"line\">JOB_NAME VARCHAR(200) NULL COMMENT &apos;Job key&apos;,</span><br><span class=\"line\">JOB_GROUP VARCHAR(200) NULL COMMENT &apos;Job group 名称&apos;,</span><br><span class=\"line\">IS_NONCONCURRENT VARCHAR(1) NULL COMMENT &apos;是否不允许并发&apos;,</span><br><span class=\"line\">REQUESTS_RECOVERY VARCHAR(1) NULL COMMENT &apos;Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,ENTRY_ID))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_SIMPLE_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">REPEAT_COUNT BIGINT(7) NOT NULL COMMENT &apos;重复次数&apos;,</span><br><span class=\"line\">REPEAT_INTERVAL BIGINT(12) NOT NULL COMMENT &apos;重复间隔&apos;,</span><br><span class=\"line\">TIMES_TRIGGERED BIGINT(10) NOT NULL COMMENT &apos;触发次数&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储简单的Trigger，包括重复次数、间隔、以及已触的次数&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_CRON_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">CRON_EXPRESSION VARCHAR(120) NOT NULL COMMENT &apos;调度规则&apos;,</span><br><span class=\"line\">TIME_ZONE_ID VARCHAR(80) COMMENT &apos;时区&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储CronTrigger，包括Cron表达式和时区信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_BLOB_TRIGGERS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">BLOB_DATA BLOB NULL COMMENT &apos;对于用户自定义的Trigger信息，无法提前设计字段，所以序列化后使用BLOB存储&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">INDEX (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),</span><br><span class=\"line\">FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储用户自定义的Trigger&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_SIMPROP_TRIGGERS</span><br><span class=\"line\">  (</span><br><span class=\"line\">    SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">    TRIGGER_NAME VARCHAR(200) NOT NULL COMMENT &apos;Trigger key&apos;,</span><br><span class=\"line\">    TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">    STR_PROP_1 VARCHAR(512) NULL COMMENT &apos;字符串属性，占位用，下同&apos;,</span><br><span class=\"line\">    STR_PROP_2 VARCHAR(512) NULL,</span><br><span class=\"line\">    STR_PROP_3 VARCHAR(512) NULL,</span><br><span class=\"line\">    INT_PROP_1 INT NULL,</span><br><span class=\"line\">    INT_PROP_2 INT NULL,</span><br><span class=\"line\">    LONG_PROP_1 BIGINT NULL,</span><br><span class=\"line\">    LONG_PROP_2 BIGINT NULL,</span><br><span class=\"line\">    DEC_PROP_1 NUMERIC(13,4) NULL,</span><br><span class=\"line\">    DEC_PROP_2 NUMERIC(13,4) NULL,</span><br><span class=\"line\">    BOOL_PROP_1 VARCHAR(1) NULL,</span><br><span class=\"line\">    BOOL_PROP_2 VARCHAR(1) NULL,</span><br><span class=\"line\">    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),</span><br><span class=\"line\">    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)</span><br><span class=\"line\">    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储trigger属性信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">TRIGGER_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Trigger group 名称&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储已暂停的Trigger组的信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_CALENDARS (</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">CALENDAR_NAME VARCHAR(200) NOT NULL COMMENT &apos;Calendar 名称&apos;,</span><br><span class=\"line\">CALENDAR BLOB NOT NULL COMMENT &apos;Calendar 数据&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,CALENDAR_NAME))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储Quartz的Calendar信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE QRTZ_JOB_DETAILS(</span><br><span class=\"line\">SCHED_NAME VARCHAR(120) NOT NULL COMMENT &apos;Scheduler名称&apos;,</span><br><span class=\"line\">JOB_NAME VARCHAR(200) NOT NULL COMMENT &apos;Job key&apos;,</span><br><span class=\"line\">JOB_GROUP VARCHAR(200) NOT NULL COMMENT &apos;Job group 名称&apos;,</span><br><span class=\"line\">DESCRIPTION VARCHAR(250) NULL COMMENT &apos;Job 描述， .withDescription()方法传入的string&apos;,</span><br><span class=\"line\">JOB_CLASS_NAME VARCHAR(250) NOT NULL COMMENT &apos;实现Job的类名，trigger触发时调度此类的execute方法&apos;,</span><br><span class=\"line\">IS_DURABLE VARCHAR(1) NOT NULL COMMENT &apos;为true时，Job相关的trigger完成以后，Job数据继续保留&apos;,</span><br><span class=\"line\">IS_NONCONCURRENT VARCHAR(1) NOT NULL COMMENT &apos;是否不允许并发，为true时，如果下一次的触发事件到了，而上一次的job执行还未结束，则后续的触发会放入队列等待&apos;,</span><br><span class=\"line\">IS_UPDATE_DATA VARCHAR(1) NOT NULL COMMENT &apos;是否在多次调度之间更新JobDataMap&apos;,</span><br><span class=\"line\">REQUESTS_RECOVERY VARCHAR(1) NOT NULL COMMENT &apos;Scheduler实例发生故障时，故障恢复节点会检测故障的Scheduler正在调度的任务是否需要recovery，如果需要会添加一个只执行一次的simple trigger重新触发&apos;,</span><br><span class=\"line\">JOB_DATA BLOB NULL COMMENT &apos;存储JobDataMap等&apos;,</span><br><span class=\"line\">PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP))</span><br><span class=\"line\">ENGINE=InnoDB COMMENT &apos;存储每一个已配置的Job的详细信息&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY ON QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_J_GRP ON QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_J ON QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_JG ON QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_C ON QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_G ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_N_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_N_G_STATE ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME ON QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_ST ON QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP ON QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_J_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_JG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_T_G ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);</span><br><span class=\"line\">CREATE INDEX IDX_QRTZ_FT_TG ON QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);</span><br><span class=\"line\"></span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>Spring的showcase项目中有Quartz集群化配置示例，可以根据项目需要做些调整。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure Main Scheduler Properties</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.scheduler.instanceName = MyClusteredScheduler</span><br><span class=\"line\">org.quartz.scheduler.instanceId = AUTO</span><br><span class=\"line\">org.quartz.scheduler.skipUpdateCheck = true</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure ThreadPool</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool</span><br><span class=\"line\">org.quartz.threadPool.threadCount = 25</span><br><span class=\"line\">org.quartz.threadPool.threadPriority = 5</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure JobStore</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.jobStore.misfireThreshold = 60000</span><br><span class=\"line\">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class=\"line\">org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class=\"line\">org.quartz.jobStore.useProperties = false</span><br><span class=\"line\">org.quartz.jobStore.tablePrefix = QRTZ_</span><br><span class=\"line\">org.quartz.jobStore.isClustered = true</span><br><span class=\"line\">org.quartz.jobStore.clusterCheckinInterval = 20000</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure DataSources</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">#defined in applicationContext-quartz.xml</span><br></pre></td></tr></table></figure></p>\n<p>applicationContext-quartz.xml配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class=\"line\">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class=\"line\">                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;</span><br><span class=\"line\">       default-lazy-init=&quot;false&quot;&gt;</span><br><span class=\"line\">    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;quartzDataSource&quot; class=&quot;org.apache.tomcat.jdbc.pool.DataSource&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- Quartz集群Scheduler --&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;clusterQuartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class=\"line\">        &lt;!--  quartz配置文件路径--&gt;</span><br><span class=\"line\">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:/quartz.properties&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- 启动时延期3秒开始任务 --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;startupDelay&quot; value=&quot;2&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;autoStartup&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;dataSource&quot; ref=&quot;quartzDataSource&quot; /&gt;</span><br><span class=\"line\">        &lt;!-- Job接受applicationContext的成员变量名 --&gt;</span><br><span class=\"line\">        &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContext&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"集群调度机制\"><a href=\"#集群调度机制\" class=\"headerlink\" title=\"集群调度机制\"></a>集群调度机制</h2><p>集群调度机制部分，gklifg的博客<sup><a href=\"#ref1\">[1]</a></sup>中做了很细致的分析和说明，我在此直接引用部分内容。</p>\n<p><img src=\"http://img.blog.csdn.net/20140606160024250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Quartz集群\"><br>Quartz的集群化配置是基于持久化的，需要使用JDBC等持久化到数据库的方式。因为Quartz集群中的各个节点并不感知其他节点的存在,只是通过数据库来进行间接的沟通。</p>\n<p><img src=\"http://img.blog.csdn.net/20140606160208906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2tsaWZn/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Quartz集群调度机制\"><br>一个调度器实例在执行涉及到分布式问题的数据库操作之前，需要先获取QRTZ_LOCKS表中相应的锁，获取到锁的实例可以进行相应的操作并更新相关数据的状态，事务提交以后，锁释放以供其他实例获取。</p>\n<p>通过这样的方式避免多个实例同时修改数据可能引起的问题。</p>\n<h2 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h2><p>在单元测试的时候，我发现如果给Quartz设置了startupDelay，那么如果在Quartz开始调度任务之前有Job被添加到了调度器，且Quartz开始调度时恰好有符合触发条件的Trigger，那么最初的1秒内调度器会检测到3次待触发的Trigger，并分配给不同的Worker执行。目前我没有找到原因，也不排除是自己的配置或者测试环境存在问题，这个需要后续跟进观察。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总体来说，Quartz是一个非常强大的作业调度框架，Trigger可以包含JobDataMap的设计方式更是让我眼前一亮，在taskgo的设计和开发过程中会有很多可以借鉴Quartz的地方。</p>\n<h2 id=\"Update-2016-02-19\"><a href=\"#Update-2016-02-19\" class=\"headerlink\" title=\"Update 2016-02-19\"></a>Update 2016-02-19</h2><p>最近看到有一篇文章介绍当当开发的elastic-job项目，目标是无中心化的分布式定时调度框架。重写了Quartz的基于数据库的分布式功能，改用Zookeeper实现注册中心，代码已经在Github开源，有时间可以学习一下。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><span id=\"ref1\">1. gklifg <a href=\"http://demo.netfoucs.com/gklifg/article/details/27090179\" target=\"_blank\" rel=\"noopener\">quartz集群调度机制调研及源码分析</a> </span></p>\n<ol>\n<li><a href=\"http://tech.meituan.com/mt-crm-quartz.html\" target=\"_blank\" rel=\"noopener\">Quartz应用与集群原理分析</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/dangdang-distributed-work-framework-elastic-job\" target=\"_blank\" rel=\"noopener\">详解当当网的分布式作业框架elastic-job</a></li>\n</ol>"},{"title":"MySQL高可用笔记 -1- Replication基础","date":"2016-02-19T03:47:14.000Z","_content":"\n## 前言\nMySQL Replication 可以将 master 节点的所有改变准确的复制到 slave 节点，按照复制方式可以分为 statement-based replication 和 row-based replication。\n\n<!-- statement-based replication 是基于statement的复制，在语句少，数据变更大的时候效果更好，row-based replication 是基于数据行的复制，在语句多，数据变更相对少的时候效果更好。 -->\n\nReplication 作用：\n- 异地多活\n- 水平扩展，负载均衡\n- 使用 slave 节点进行备份、数据分析等\n- 配置 delayed slave，避免误操作的影响\n\n<!-- more -->\n\n## 建立 Replication 的基础步骤\n建立一个最基础的 Replication 需要3个步骤，\n1. 设置 master\n2. 设置 slave\n3. 将 slave 连接到 master\n\n### 设置 master\n最基础的 master 设置是设置server ID 和配置 binlog。server ID 是区分两个 server 的唯一标识，binlog 记录了 master 上的所有变化，通过在 slave 重放 master 的 binlog，可以将 master 的改变更新到 slave。\n\n设置 server ID 和 binlog 需要停止 mysqld 服务，然后修改 my.cnf 配置文件。\n\n一个简单的示例配置如下：\n```\n[mysqld]\n...\nserver-id     = 1\nlog-bin       = master-bin\nlog-bin-index = master-bin.index\n```\n\nlog-bin 设置了 binlog 文件的 basename，如果 log-bin 设置的值中包含了扩展名，那么扩展名部分将被忽略，只有 basename 部分会被使用。log-bin 的默认值是 hostname-bin，如果 server 的 hostname 改变，binlog 的文件名也将变更，不过在 binlog index 文件中会被记录。\n\nlog-bin-index 配置了 binlog index 文件的名称，文件中存储了 binlog 文件的索引。log-bin-index 的默认值是 binlog 文件的 basename，扩展名是 index。如果没有指定 log-bin 的值，那 log-bin-index 的默认值就将是 hostname-bin.index，如果管理员修改了 hostname，那么 mysqld 将找不到之前的 binlog index 文件，并假设其不存在，这样会重新生成新的 binlog 文件，因为之前的已经无法访问到了。\n\nserver ID 是识别server的唯一标识，如果设置重复的话，在 slave 连接到 master 的时候将会触发错误。\n\n设置好以后重启 mysqld 就可以使 Replication 设置生效了。\n\n接下来，slave 就可以连接到这台 master 进行复制了。这时，master server 需要一个具有 replication 相关权限的用户来进行复制相关的操作。\n\n操作示例如下：\n```\nmaster > CREATE USER repl_user;\nmaster > GRANT REPLICATION SLAVE ON *.*\n      -> TO repl_user IDENTIFIED BY 'cptbtptp';\n```\n\n*REPLICATION SLAVE 权限这是赋予了用户获取 master 上的 binlog 的 dump 文件的权利，完全可以将其赋予一个现有用户，不过将 Replication 用户和 app 相关用户分隔开会更加方便安全。*\n\n\n## 设置 slave\n接下来需要配置 slave 的 server ID 和 relay-log相关配置。\n\nrelay-log、relay-log-index 项和 log-bin，log-bin-index 比较像，默认值分别是 hostname-relay-bin 和 hostname-relay-bin.index。在 hostname 变更的时候也会有相同的问题。\n\n简单的示例配置如下：\n```\n[mysqld]\n...\nserver-id       = 2\nrelay-log       = slave-relay-bin\nrelay-log-index = slave-relay-bin.index\n```\n\n\n## 连接 slave 和 master\n最后一步是将 slave 连接到 master，开始复制。\n\n最简单的方式是使用 CHANGE MASTER TO 和 START SLAVE 命令设置并开始复制。CHANGE MASTER TO 命令需要至少4个参数：\n- a hostname\n- a port number\n- a user account on the master with replication slave privileges\n- a password for the user account\n\n简单示例如下：\n```\nslave > CHANGE MASTER TO\n     ->   MASTER_HOST = 'master-1',\n     ->   MASTER_PORT = 3306,\n     ->   MASTER_USER = 'repl_user',\n     ->   MASTER_PASSWORD = 'cptbtptp';\n\nslave > START SLAVE;\n```\n\n其中 MASTER_HOST 参数可以是 hostname 也可以是IP地址，如果是 hostname 会通过 DNS lookup 解析成IP地址。\n\n如果 master 已经运行一段时间并有很多数据了，更好的方式是先创建 master 或 已存在的 slave 的备份，记录备份数据的 binlog position。在 slave 导入备份，并在执行 CHANGE MASTER TO 命令的时候，指明 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，从备份的数据之后进行复制，这样可以减少复制的时间，并降低 master 的压力。\n\n\n## 结语\n通过以上步骤，可以建立最基础的 MySQL Replication，更多的设置还需要参考 MySQL 手册。\n","source":"_posts/mysql-high-availability-notes-1.md","raw":"title: \"MySQL高可用笔记 -1- Replication基础\"\ndate: 2016-02-19 11:47:14\ncategories:\n- study\ntags:\n- mysql\n- mysql replication\n---\n\n## 前言\nMySQL Replication 可以将 master 节点的所有改变准确的复制到 slave 节点，按照复制方式可以分为 statement-based replication 和 row-based replication。\n\n<!-- statement-based replication 是基于statement的复制，在语句少，数据变更大的时候效果更好，row-based replication 是基于数据行的复制，在语句多，数据变更相对少的时候效果更好。 -->\n\nReplication 作用：\n- 异地多活\n- 水平扩展，负载均衡\n- 使用 slave 节点进行备份、数据分析等\n- 配置 delayed slave，避免误操作的影响\n\n<!-- more -->\n\n## 建立 Replication 的基础步骤\n建立一个最基础的 Replication 需要3个步骤，\n1. 设置 master\n2. 设置 slave\n3. 将 slave 连接到 master\n\n### 设置 master\n最基础的 master 设置是设置server ID 和配置 binlog。server ID 是区分两个 server 的唯一标识，binlog 记录了 master 上的所有变化，通过在 slave 重放 master 的 binlog，可以将 master 的改变更新到 slave。\n\n设置 server ID 和 binlog 需要停止 mysqld 服务，然后修改 my.cnf 配置文件。\n\n一个简单的示例配置如下：\n```\n[mysqld]\n...\nserver-id     = 1\nlog-bin       = master-bin\nlog-bin-index = master-bin.index\n```\n\nlog-bin 设置了 binlog 文件的 basename，如果 log-bin 设置的值中包含了扩展名，那么扩展名部分将被忽略，只有 basename 部分会被使用。log-bin 的默认值是 hostname-bin，如果 server 的 hostname 改变，binlog 的文件名也将变更，不过在 binlog index 文件中会被记录。\n\nlog-bin-index 配置了 binlog index 文件的名称，文件中存储了 binlog 文件的索引。log-bin-index 的默认值是 binlog 文件的 basename，扩展名是 index。如果没有指定 log-bin 的值，那 log-bin-index 的默认值就将是 hostname-bin.index，如果管理员修改了 hostname，那么 mysqld 将找不到之前的 binlog index 文件，并假设其不存在，这样会重新生成新的 binlog 文件，因为之前的已经无法访问到了。\n\nserver ID 是识别server的唯一标识，如果设置重复的话，在 slave 连接到 master 的时候将会触发错误。\n\n设置好以后重启 mysqld 就可以使 Replication 设置生效了。\n\n接下来，slave 就可以连接到这台 master 进行复制了。这时，master server 需要一个具有 replication 相关权限的用户来进行复制相关的操作。\n\n操作示例如下：\n```\nmaster > CREATE USER repl_user;\nmaster > GRANT REPLICATION SLAVE ON *.*\n      -> TO repl_user IDENTIFIED BY 'cptbtptp';\n```\n\n*REPLICATION SLAVE 权限这是赋予了用户获取 master 上的 binlog 的 dump 文件的权利，完全可以将其赋予一个现有用户，不过将 Replication 用户和 app 相关用户分隔开会更加方便安全。*\n\n\n## 设置 slave\n接下来需要配置 slave 的 server ID 和 relay-log相关配置。\n\nrelay-log、relay-log-index 项和 log-bin，log-bin-index 比较像，默认值分别是 hostname-relay-bin 和 hostname-relay-bin.index。在 hostname 变更的时候也会有相同的问题。\n\n简单的示例配置如下：\n```\n[mysqld]\n...\nserver-id       = 2\nrelay-log       = slave-relay-bin\nrelay-log-index = slave-relay-bin.index\n```\n\n\n## 连接 slave 和 master\n最后一步是将 slave 连接到 master，开始复制。\n\n最简单的方式是使用 CHANGE MASTER TO 和 START SLAVE 命令设置并开始复制。CHANGE MASTER TO 命令需要至少4个参数：\n- a hostname\n- a port number\n- a user account on the master with replication slave privileges\n- a password for the user account\n\n简单示例如下：\n```\nslave > CHANGE MASTER TO\n     ->   MASTER_HOST = 'master-1',\n     ->   MASTER_PORT = 3306,\n     ->   MASTER_USER = 'repl_user',\n     ->   MASTER_PASSWORD = 'cptbtptp';\n\nslave > START SLAVE;\n```\n\n其中 MASTER_HOST 参数可以是 hostname 也可以是IP地址，如果是 hostname 会通过 DNS lookup 解析成IP地址。\n\n如果 master 已经运行一段时间并有很多数据了，更好的方式是先创建 master 或 已存在的 slave 的备份，记录备份数据的 binlog position。在 slave 导入备份，并在执行 CHANGE MASTER TO 命令的时候，指明 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，从备份的数据之后进行复制，这样可以减少复制的时间，并降低 master 的压力。\n\n\n## 结语\n通过以上步骤，可以建立最基础的 MySQL Replication，更多的设置还需要参考 MySQL 手册。\n","slug":"mysql-high-availability-notes-1","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910r00076bk2zvobuwen","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>MySQL Replication 可以将 master 节点的所有改变准确的复制到 slave 节点，按照复制方式可以分为 statement-based replication 和 row-based replication。</p>\n<!-- statement-based replication 是基于statement的复制，在语句少，数据变更大的时候效果更好，row-based replication 是基于数据行的复制，在语句多，数据变更相对少的时候效果更好。 -->\n<p>Replication 作用：</p>\n<ul>\n<li>异地多活</li>\n<li>水平扩展，负载均衡</li>\n<li>使用 slave 节点进行备份、数据分析等</li>\n<li>配置 delayed slave，避免误操作的影响</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"建立-Replication-的基础步骤\"><a href=\"#建立-Replication-的基础步骤\" class=\"headerlink\" title=\"建立 Replication 的基础步骤\"></a>建立 Replication 的基础步骤</h2><p>建立一个最基础的 Replication 需要3个步骤，</p>\n<ol>\n<li>设置 master</li>\n<li>设置 slave</li>\n<li>将 slave 连接到 master</li>\n</ol>\n<h3 id=\"设置-master\"><a href=\"#设置-master\" class=\"headerlink\" title=\"设置 master\"></a>设置 master</h3><p>最基础的 master 设置是设置server ID 和配置 binlog。server ID 是区分两个 server 的唯一标识，binlog 记录了 master 上的所有变化，通过在 slave 重放 master 的 binlog，可以将 master 的改变更新到 slave。</p>\n<p>设置 server ID 和 binlog 需要停止 mysqld 服务，然后修改 my.cnf 配置文件。</p>\n<p>一个简单的示例配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">...</span><br><span class=\"line\">server-id     = 1</span><br><span class=\"line\">log-bin       = master-bin</span><br><span class=\"line\">log-bin-index = master-bin.index</span><br></pre></td></tr></table></figure></p>\n<p>log-bin 设置了 binlog 文件的 basename，如果 log-bin 设置的值中包含了扩展名，那么扩展名部分将被忽略，只有 basename 部分会被使用。log-bin 的默认值是 hostname-bin，如果 server 的 hostname 改变，binlog 的文件名也将变更，不过在 binlog index 文件中会被记录。</p>\n<p>log-bin-index 配置了 binlog index 文件的名称，文件中存储了 binlog 文件的索引。log-bin-index 的默认值是 binlog 文件的 basename，扩展名是 index。如果没有指定 log-bin 的值，那 log-bin-index 的默认值就将是 hostname-bin.index，如果管理员修改了 hostname，那么 mysqld 将找不到之前的 binlog index 文件，并假设其不存在，这样会重新生成新的 binlog 文件，因为之前的已经无法访问到了。</p>\n<p>server ID 是识别server的唯一标识，如果设置重复的话，在 slave 连接到 master 的时候将会触发错误。</p>\n<p>设置好以后重启 mysqld 就可以使 Replication 设置生效了。</p>\n<p>接下来，slave 就可以连接到这台 master 进行复制了。这时，master server 需要一个具有 replication 相关权限的用户来进行复制相关的操作。</p>\n<p>操作示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master &gt; CREATE USER repl_user;</span><br><span class=\"line\">master &gt; GRANT REPLICATION SLAVE ON *.*</span><br><span class=\"line\">      -&gt; TO repl_user IDENTIFIED BY &apos;cptbtptp&apos;;</span><br></pre></td></tr></table></figure></p>\n<p><em>REPLICATION SLAVE 权限这是赋予了用户获取 master 上的 binlog 的 dump 文件的权利，完全可以将其赋予一个现有用户，不过将 Replication 用户和 app 相关用户分隔开会更加方便安全。</em></p>\n<h2 id=\"设置-slave\"><a href=\"#设置-slave\" class=\"headerlink\" title=\"设置 slave\"></a>设置 slave</h2><p>接下来需要配置 slave 的 server ID 和 relay-log相关配置。</p>\n<p>relay-log、relay-log-index 项和 log-bin，log-bin-index 比较像，默认值分别是 hostname-relay-bin 和 hostname-relay-bin.index。在 hostname 变更的时候也会有相同的问题。</p>\n<p>简单的示例配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">...</span><br><span class=\"line\">server-id       = 2</span><br><span class=\"line\">relay-log       = slave-relay-bin</span><br><span class=\"line\">relay-log-index = slave-relay-bin.index</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"连接-slave-和-master\"><a href=\"#连接-slave-和-master\" class=\"headerlink\" title=\"连接 slave 和 master\"></a>连接 slave 和 master</h2><p>最后一步是将 slave 连接到 master，开始复制。</p>\n<p>最简单的方式是使用 CHANGE MASTER TO 和 START SLAVE 命令设置并开始复制。CHANGE MASTER TO 命令需要至少4个参数：</p>\n<ul>\n<li>a hostname</li>\n<li>a port number</li>\n<li>a user account on the master with replication slave privileges</li>\n<li>a password for the user account</li>\n</ul>\n<p>简单示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slave &gt; CHANGE MASTER TO</span><br><span class=\"line\">     -&gt;   MASTER_HOST = &apos;master-1&apos;,</span><br><span class=\"line\">     -&gt;   MASTER_PORT = 3306,</span><br><span class=\"line\">     -&gt;   MASTER_USER = &apos;repl_user&apos;,</span><br><span class=\"line\">     -&gt;   MASTER_PASSWORD = &apos;cptbtptp&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">slave &gt; START SLAVE;</span><br></pre></td></tr></table></figure></p>\n<p>其中 MASTER_HOST 参数可以是 hostname 也可以是IP地址，如果是 hostname 会通过 DNS lookup 解析成IP地址。</p>\n<p>如果 master 已经运行一段时间并有很多数据了，更好的方式是先创建 master 或 已存在的 slave 的备份，记录备份数据的 binlog position。在 slave 导入备份，并在执行 CHANGE MASTER TO 命令的时候，指明 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，从备份的数据之后进行复制，这样可以减少复制的时间，并降低 master 的压力。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过以上步骤，可以建立最基础的 MySQL Replication，更多的设置还需要参考 MySQL 手册。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>MySQL Replication 可以将 master 节点的所有改变准确的复制到 slave 节点，按照复制方式可以分为 statement-based replication 和 row-based replication。</p>\n<!-- statement-based replication 是基于statement的复制，在语句少，数据变更大的时候效果更好，row-based replication 是基于数据行的复制，在语句多，数据变更相对少的时候效果更好。 -->\n<p>Replication 作用：</p>\n<ul>\n<li>异地多活</li>\n<li>水平扩展，负载均衡</li>\n<li>使用 slave 节点进行备份、数据分析等</li>\n<li>配置 delayed slave，避免误操作的影响</li>\n</ul>","more":"<h2 id=\"建立-Replication-的基础步骤\"><a href=\"#建立-Replication-的基础步骤\" class=\"headerlink\" title=\"建立 Replication 的基础步骤\"></a>建立 Replication 的基础步骤</h2><p>建立一个最基础的 Replication 需要3个步骤，</p>\n<ol>\n<li>设置 master</li>\n<li>设置 slave</li>\n<li>将 slave 连接到 master</li>\n</ol>\n<h3 id=\"设置-master\"><a href=\"#设置-master\" class=\"headerlink\" title=\"设置 master\"></a>设置 master</h3><p>最基础的 master 设置是设置server ID 和配置 binlog。server ID 是区分两个 server 的唯一标识，binlog 记录了 master 上的所有变化，通过在 slave 重放 master 的 binlog，可以将 master 的改变更新到 slave。</p>\n<p>设置 server ID 和 binlog 需要停止 mysqld 服务，然后修改 my.cnf 配置文件。</p>\n<p>一个简单的示例配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">...</span><br><span class=\"line\">server-id     = 1</span><br><span class=\"line\">log-bin       = master-bin</span><br><span class=\"line\">log-bin-index = master-bin.index</span><br></pre></td></tr></table></figure></p>\n<p>log-bin 设置了 binlog 文件的 basename，如果 log-bin 设置的值中包含了扩展名，那么扩展名部分将被忽略，只有 basename 部分会被使用。log-bin 的默认值是 hostname-bin，如果 server 的 hostname 改变，binlog 的文件名也将变更，不过在 binlog index 文件中会被记录。</p>\n<p>log-bin-index 配置了 binlog index 文件的名称，文件中存储了 binlog 文件的索引。log-bin-index 的默认值是 binlog 文件的 basename，扩展名是 index。如果没有指定 log-bin 的值，那 log-bin-index 的默认值就将是 hostname-bin.index，如果管理员修改了 hostname，那么 mysqld 将找不到之前的 binlog index 文件，并假设其不存在，这样会重新生成新的 binlog 文件，因为之前的已经无法访问到了。</p>\n<p>server ID 是识别server的唯一标识，如果设置重复的话，在 slave 连接到 master 的时候将会触发错误。</p>\n<p>设置好以后重启 mysqld 就可以使 Replication 设置生效了。</p>\n<p>接下来，slave 就可以连接到这台 master 进行复制了。这时，master server 需要一个具有 replication 相关权限的用户来进行复制相关的操作。</p>\n<p>操作示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">master &gt; CREATE USER repl_user;</span><br><span class=\"line\">master &gt; GRANT REPLICATION SLAVE ON *.*</span><br><span class=\"line\">      -&gt; TO repl_user IDENTIFIED BY &apos;cptbtptp&apos;;</span><br></pre></td></tr></table></figure></p>\n<p><em>REPLICATION SLAVE 权限这是赋予了用户获取 master 上的 binlog 的 dump 文件的权利，完全可以将其赋予一个现有用户，不过将 Replication 用户和 app 相关用户分隔开会更加方便安全。</em></p>\n<h2 id=\"设置-slave\"><a href=\"#设置-slave\" class=\"headerlink\" title=\"设置 slave\"></a>设置 slave</h2><p>接下来需要配置 slave 的 server ID 和 relay-log相关配置。</p>\n<p>relay-log、relay-log-index 项和 log-bin，log-bin-index 比较像，默认值分别是 hostname-relay-bin 和 hostname-relay-bin.index。在 hostname 变更的时候也会有相同的问题。</p>\n<p>简单的示例配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">...</span><br><span class=\"line\">server-id       = 2</span><br><span class=\"line\">relay-log       = slave-relay-bin</span><br><span class=\"line\">relay-log-index = slave-relay-bin.index</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"连接-slave-和-master\"><a href=\"#连接-slave-和-master\" class=\"headerlink\" title=\"连接 slave 和 master\"></a>连接 slave 和 master</h2><p>最后一步是将 slave 连接到 master，开始复制。</p>\n<p>最简单的方式是使用 CHANGE MASTER TO 和 START SLAVE 命令设置并开始复制。CHANGE MASTER TO 命令需要至少4个参数：</p>\n<ul>\n<li>a hostname</li>\n<li>a port number</li>\n<li>a user account on the master with replication slave privileges</li>\n<li>a password for the user account</li>\n</ul>\n<p>简单示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slave &gt; CHANGE MASTER TO</span><br><span class=\"line\">     -&gt;   MASTER_HOST = &apos;master-1&apos;,</span><br><span class=\"line\">     -&gt;   MASTER_PORT = 3306,</span><br><span class=\"line\">     -&gt;   MASTER_USER = &apos;repl_user&apos;,</span><br><span class=\"line\">     -&gt;   MASTER_PASSWORD = &apos;cptbtptp&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">slave &gt; START SLAVE;</span><br></pre></td></tr></table></figure></p>\n<p>其中 MASTER_HOST 参数可以是 hostname 也可以是IP地址，如果是 hostname 会通过 DNS lookup 解析成IP地址。</p>\n<p>如果 master 已经运行一段时间并有很多数据了，更好的方式是先创建 master 或 已存在的 slave 的备份，记录备份数据的 binlog position。在 slave 导入备份，并在执行 CHANGE MASTER TO 命令的时候，指明 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，从备份的数据之后进行复制，这样可以减少复制的时间，并降低 master 的压力。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过以上步骤，可以建立最基础的 MySQL Replication，更多的设置还需要参考 MySQL 手册。</p>"},{"title":"也谈素性测试","date":"2015-04-21T07:48:05.000Z","mathjax":true,"_content":"\n## 前言\n很早之前读过 Matrix67的[素数与素性测试](http://www.matrix67.com/blog/archives/234)和 张洋的[聊聊如何检测素数](http://blog.codinglabs.org/articles/prime-test.html)，读了之后获益匪浅，不过一直没有自己动手写一次试试。\n\n最近和朋友聊天，谈到如何找到距离某个数最近的素数，勾起了我的兴趣。遂重新读了这两篇博客，又查阅了一些其他的资料，自己动手写了一个简单的素数检测程序。下面记录了一些这次实践的经历以及脑洞。\n<!-- more -->\n\n## 素数定义\n既然是素性测试，首先要明确素数的定义：\n> A natural number (i.e. 1, 2, 3, 4, 5, 6, etc.) is called a prime number (or a prime) if it has exactly two positive divisors, 1 and the number itself.[1]\n> Natural numbers greater than 1 that are not prime are called composite.\n> -- [wikipedia](http://en.wikipedia.org/wiki/Prime_number)\n\n即，一个自然数如果只能被1和它自身整除，那么这个自然数是素数。\n大于1的自然数不是素数就是合数。\n\n例如：\n- 2是素数，因为它只能被1和2整除。\n- 3是素数。\n- 4不是素数，因为它可以被2整除。\n- 5是素数。\n- 6不是素数，因为它可以被2和3整除。\n\n因此，还有一个结论，以十进制书写时，大于5的素数都是以1、3、7、9结尾的。可以用于快速判断一个数是否 ***不是*** 素数。\n\n## 1的素性\n我一直有一个疑问，1到底是素数还是合数。以前一直是因为看到的素数定义里面都指明了大于1的自然数作为前提，也就没有深究。1这个自然数就一直作为素数定义中的特例被我接受了下来。\n\n这次认真看了下wiki，里面单独提及到了1的素性说明。\n> Most early Greeks did not even consider 1 to be a number,[4] and so they did not consider it a prime. In the 19th century, however, many mathematicians did consider the number 1 a prime. For example, Derrick Norman Lehmer's list of primes up to 10,006,721, reprinted as late as 1956,[5] started with 1 as its first prime.[6] Henri Lebesgue is said to be the last professional mathematician to call 1 prime.[7]\n>\n> Although a large body of mathematical work would still be valid when calling 1 a prime, the fundamental theorem of arithmetic (mentioned above) would not hold as stated. For example, the number 15 can be factored as 3 · 5 and 1 · 3 · 5; if 1 were admitted as a prime, these two presentations would be considered different factorizations of 15 into prime numbers, so the statement of that theorem would have to be modified. Similarly, the sieve of Eratosthenes would not work correctly if 1 were considered a prime: a modified version of the sieve that considers 1 as prime would eliminate all multiples of 1 (that is, all numbers) and produce as output only the single number 1. Furthermore, the prime numbers have several properties that the number 1 lacks, such as the relationship of the number to its corresponding value of Euler's totient function or the sum of divisors function.\n\n原来在19世纪有一些数学教认为1是素数。只不过很多数学成果在1是素数的条件下会有问题。例如：\n- 算术基本定理（[Fundamental theorem of arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)），又称为正整数的唯一分解定理，即：每个大于1的自然数均可写为素数的积，而且这些素因子按大小排列之后，写法仅有一种方式。例如: $6936 = 2^3 \\times 3 \\times 17^2，1200 = 2^4 \\times 3 \\times 5^2$。\n如果1也是素数的话，15可以写成 $3 \\times 5$，也可以写成 $1 \\times 3 \\times 5$。这两个表达式是不同的，这样算数基本定理就需要修改了。\n- 埃拉托斯特尼筛法（[sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)），简称埃氏筛，是一种公元前250年由古希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。\n它通过从2的倍数开始，迭代地将每一个素数的倍数标记为合数来筛选出某个范围中的素数。\n例如，如果要找出小于等于n的所有素数，埃拉托斯特尼的方法是：\n1.创建一个从2到n的连续数列。\n2.首先，令p等于2，即第一个素数。\n3.将数列中等于p的倍数的自然数标记为合数，p本身不标记。\n4.找到未被标记的大于p的第一个数，如果没有这样的数，方法结束。否则，令p等于找到的新数（就是下一个素数），然后重复步骤3。\n![sieve of Eratosthenes](http://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif)\n当这个方法结束时，所有未被标记的数就是素数。\n还有一个优化方式，在第4步中，若$p^2$大于n，则可以直接结束而不必寻找大于p的新数。因为小于等于$p^2$的数中的合数都已经标记过了。\n如果1也是素数的话，在第三步结束后，列表中就只剩下1了。这样这个筛选法也需要修改。\n\n另外，素数的一些特性1也没有，比如[欧拉函数](http://en.wikipedia.org/wiki/Euler%27s_totient_function)和[除数函数](http://en.wikipedia.org/wiki/Divisor_function)中的一些性质。关于1是否是素数的争论一直没有结束，只不过大多数人都倾向于1不是素数，因为1实在太特殊了，对很多理论都有影响。\n\n写到这里发现这个坑太深了，欧拉函数和除数函数我没有仔细往下看，因为越往深追溯遇到的不知道的理论越多。看来这个坑不是一天两天能填上的，我决定先补一下数学基础再说T_T。如果对此感兴趣的朋友可以看下[What is the Smallest Prime?](https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell1/cald5.html)和[The History of the Primality of One: A Selection of Sources](https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell2/cald6.html)。\n\n## 素性测试\n### 试除法（Trial division）\n试除法是判断一个给定整数n是否是素数的最基本的方法。该方法判断所有大于1且小于等于$\\sqrt{n}$的整数是否可以整除n，如果有可以整除的数，则n是合数，否则判断n为素数。因为如果$n = a \\times b, a \\leq b$，则$a \\leq \\sqrt{n}$，所以只要试除到小于等于$\\sqrt{n}$的整数即可。\n\n有一种实现起来更高效的方式，只要试除2到$\\sqrt{n}$之间的所有素数，即可判断出n是否是素数。因为合数都可以写成更小的素数的乘积（参考上面提到的算术基本定理）。\n\n虽然试除法逻辑简单，实现比较容易，但是在面对大整数的时候，需要试除的素数数量会极速增长。根据[素数计数函数](http://en.wikipedia.org/wiki/Prime-counting_function), 小于$\\sqrt{n}$的素数数量约等于 $\\sqrt{n} / \\ln(\\sqrt{n})$，所以试除法需要至少判断这些数是否能整除n。如果 $n = 10^{20}$，则需要试除4亿多个素数。这在现实工程中是难以接受的。\n<br />\n\n### 费马素性测试（[Fermat_primality_test](http://en.wikipedia.org/wiki/Fermat_primality_test)）\n既然试除法的效率无法接受，那么就需要寻找其他的替代方法。基于费马小定理，人们提出了一种基于随机化算法的检测方法来判断一个数是合数还是 ***可能是*** 素数，即费马素性测试。\n\n首先我们还是先看一下理论基础，[费马小定理](http://en.wikipedia.org/wiki/Fermat%27s_little_theorem)：\n***如果p是素数，a是小于p的正整数，那么 $a^{p-1} \\equiv 1 \\pmod p$。***\n\n（关于费马小定理， Matrix67写得深入浅出，我应该不会写得比这个更好了，所以这部分直接引用自 Matrix67同学的[素数与素性测试](http://www.matrix67.com/blog/archives/234)）\n> 这个证明就有点麻烦了。\n> 首先我们证明这样一个结论：如果 $p$ 是一个素数的话，那么对任意一个小于 $p$ 的正整数$a$，$a, 2a, 3a, ..., (p-1)a$ 除以 $p$ 的余数正好是一个 $1$ 到 $p-1$ 的排列。例如，5是素数，3, 6, 9, 12除以5的余数分别为3, 1, 4, 2，正好就是1到4这四个数。\n>\n> 反证法，假如结论不成立的话，那么就是说有两个小于 $p$ 的正整数 $m$ 和 $n$ 使得 $na$ 和 $ma$ 除以 $p$ 的余数相同。不妨假设 $n > m$，则 $p$ 可以整除 $a(n-m)$。但 $p$ 是素数，那么 $a$ 和 $n-m$ 中至少有一个含有因子 $p$。这显然是不可能的，因为 $a$ 和 $n-m$ 都比 $p$ 小。\n>\n> 用同余式表述，我们证明了：\n> $(p-1)! \\equiv a \\times 2a \\times 3a \\times ... \\times (p-1)a \\pmod p$\n> 也即：\n> $(p-1)! \\equiv (p-1)! \\times a^{p-1} \\pmod p$\n> 两边同时除以 $(p-1)!$，就得到了我们的最终结论：\n> $1 ≡ a^{p-1} \\pmod p$\n\n\n费马素性测试，即选取小于p的正整数a，测试费马小定理是否成立，如果不成立，则p一定不是素数，如果成立，则p可能是素数。将上述过程重复n次，每次随机选取整数a进行测试。一般情况下，选取的a越多，测试结果越准确。\n\n而有一些合数p，对于所有大于1且小于p的正整数都符合费马小定理，这样的数p称为卡迈克尔数（[Carmichael number](http://en.wikipedia.org/wiki/Carmichael_number)）。保罗·艾狄胥猜想有无限个卡迈克尔数，1994年 William Alford 、 Andrew Granville 及 Carl Pomerance 证明了这个命题。最小的卡迈克尔数是561。因为这些数的存在，使得费马素性检验变得不可靠。\n<br />\n\n### 米勒-拉宾素性测试（[Miller–Rabin_primality_test](http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)）\n米勒-拉宾素性测试也是一个基于随机化算法的素性测试方法，判断了一个数是合数还是 ***可能是*** 素数。和费马素性测试相似，米勒-拉宾素性测试也是通过判断一组对素数成立的等式是否对我们想测试的数也成立来实现素性测试的。\n\n这个方法的原始版本来自卡内基梅隆大学的计算机系教授Gary Lee Miller，他首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。\n<br />\n\n#### 定理\n米勒-拉宾素性测试基于下面的定理：\n如果对模 $n$ 存在 $1$ 的非平凡平方根，则 $n$ 是合数。即对方程 $x^2 \\equiv 1 \\pmod n$，方程的解除了 $1$ 和 $n-1$ 两个平凡根之外，还有其它的根，那么 $n$ 肯定是合数。\n\n假设 $p$是大于2的素数， $x$ 是摸 $p$ 等于1的平方根，则：\n$x^2 \\equiv 1 \\pmod p$ ，即 $ (x - 1)( x + 1) \\equiv 0 \\pmod{p}$\n也就是说素数 $p$ 整除 $(x - 1)( x + 1)$，因为 $p$ 是素数，它只能被 1 和 $p$ 整除，所以一定有 $x - 1 \\equiv 0 \\pmod p$ 或 $x - 1 \\equiv 0 \\pmod p$，所以 $x$ 模 $p$ 等于 1 或者 $p - 1$。\n<br />\n\n#### 方法\n假设 $n$ 是素数，且 $n > 2$，则 $n - 1$是偶数，我们可以将其写为 $2^s \\times d$ 的形式，其中 $s$ 和 $d$ 都是正整数，$d$ 是奇数。\n\n结合费马小定理，$a^{p-1} \\equiv 1 \\pmod p$。如果 $p$ 是素数，则 $p - 1$是偶数，我们不断计算 $a^{p-1}$的平方根，那么最后一定会得到 1 或者 $p - 1$。\n\n根据以上的理论，米勒-拉宾素性测试的等效表达为：\n1.把 $n-1$ 表示成 $d \\times 2^s$\n2.计算 $a^{d \\times 2^r} \\pmod n ( 0 \\leq r \\leq s - 1 )$，（$r = s$ 时，此算式等效于费马小定理）\n3.若结果是 1 和 $n-1$ 以外的值，测试结束，$n$是合数\n4.若结果是 $n-1$，那么测试结束， $n$可能是素数，可以换一个底数 $a$ 进行下一轮计算\n5.若结果是 1，那么仍然符合费马小定理，继续计算开方的值。即令 $r = r - 1$，$r \\neq 0$ 的情况下回到第2步\n6.直到计算到 $r = 0$，即 $a^d \\pmod n$\n7.若结果是 1 或 $n-1$，那么$n$可能是素数，可以换一个底数 $a$ 进行下一轮计算。否则测试结束，$n$是合数。\n\n所以如果 $n$ 是一个素数，那么或者 $a^d \\equiv 1 \\pmod n$，或者存在某个 $r$ 使得 $a^{d \\times 2^r} \\equiv n-1 \\pmod n ( 0 \\leq r \\leq s-1 )$。\n<br />\n\n以上面提到的卡迈克尔数 561为例，我们来看一下米勒-拉宾素性测试的实际应用：\n1.560可以表示成 $35 \\times 2^4$, 我们知道 $2^{560} = 1 \\pmod {561}$。\n2.计算得到 $2^{35 \\times 2 ^ 3} = 1 \\pmod {561}$\n3.结果仍然符合费马小定理，继续计算，得到 $2^{35 \\times 2 ^ 2} = 67 \\pmod {561}$\n4.测试结束，561是合数\n\n下面引用 Matrix67同学的[素数与素性测试](http://www.matrix67.com/blog/archives/234)补充说明：\n> Miller-Rabin素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。\n>\n> 对于大数的素性判断，目前Miller-Rabin算法应用最广泛。一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于4 759 123 141，那么只需要测试三个底数2, 7和61就足够了。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11, 13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用2, 3, 7, 61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255 981。这样的一些结论使得Miller-Rabin算法在OI中非常实用。\n>\n> 通常认为，Miller-Rabin素性测试的正确率可以令人接受，随机选取k个底数进行测试算法的失误率大概为 $4^{-k}$。\n\n<br />\n### AKS素数测试\n> AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法。由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal 和 Nitin Saxena 提出，在2002年8月6日发表于一篇题为 PRIMES is in P 的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的 Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。\n>\n> AKS最关键的重要性在于它是第一个被发表的**一般的**、**多项式的**、**确定性的**和**无仰赖的**素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。\n>\n> AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。\n> 算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。\n> 算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。\n> AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。\n> -- [wikipedia](http://zh.wikipedia.org/wiki/AKS%E8%B3%AA%E6%95%B8%E6%B8%AC%E8%A9%A6)\n\n此处留坑，有生之年。。。\n[PRIMES is in P](http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf)\n<br />\n\n### 模幂运算（[Modular exponentiation](http://en.wikipedia.org/wiki/Modular_exponentiation)）\n上面提到的费马素性测试和米勒-拉宾素性测试都涉及到了大量的模幂运算。\n模幂运算计算了正整数 $b$ 的 $e$ 次方除以正整数 $m$ 的余数。用符号表示为，给定底数 $b$, 指数 $e$, 和模数 $m$, 模幂运算就是 $ c \\equiv b^e \\pmod{m}$。\n<br />\n\n#### 直接计算\n最基础的办法就是直接计算 $ b^e $，然后对 $m$ 取余。假设 $b = 4, e = 13, m = 497$，则 $ c \\equiv 4^{13} \\pmod{497} $。计算得到 $ 4^{13} $ 等于67,108,864，对497取模计算出 $c$, 为445。\n\n这个例子中 $b$ 和 $e$ 都是一位数，计算得到的 $ b^e $ 却是8位数。如果判断一个大数是否是素数的时候，$b$ 和 $e$ 都会很大，直接计算的计算效率将变得无法接受，所以需要更高效的计算方法。\n<br />\n\n#### 内存优化计算方法\n这个方法相比于直接计算，计算次数增多了，但是因为每次计算大大节省了内存的使用，所以总的计算速度还是比直接计算更快。\n\n这个方法的理论基础是，\n$ c \\equiv (a \\cdot b) \\pmod{m} $ 等价于 $ c \\equiv (a \\cdot (b\\ (\\mbox{mod}\\ m))) \\pmod{m} $\n这样，不直接计算 $ b^e $，而是计算 $ \\prod\\_{i=0}^{e} b $，这样就可以根据上面的等式将每次乘以 $b$ 以后的结果取余，从而使计算过程中的中间变量一直小于模数 $m$，确保了内存使用效率。\n\n具体的步骤如下：\n1.令结果 $c = 1, e′ = 0.$\n2.令 $ e′ = e′ + 1 $\n3.计算 $ c \\equiv (b \\cdot c) \\pmod{m} $\n4.如果 $ e′ < e $，回到第二步；否则计算结束，此时 $ c \\equiv b^e \\pmod{m} $。\n\n我们还用上面的例子来展示计算的具体过程：\n$b = 4, e = 13, m = 497$\n- $ e′ = 1. c = (1 \\times 4) \\pmod {497} = 4 \\pmod {497} = 4.$\n- $ e′ = 2. c = (4 \\times 4) \\pmod {497} = 16 \\pmod {497} = 16.$\n- $ e′ = 3. c = (16 \\times 4) \\pmod {497} = 64 \\pmod {497} = 64.$\n- $ e′ = 4. c = (64 \\times 4) \\pmod {497} = 256 \\pmod {497} = 256.$\n- $ e′ = 5. c = (256 \\times 4) \\pmod {497} = 1024 \\pmod {497} = 30.$\n- $ e′ = 6. c = (30 \\times 4) \\pmod {497} = 120 \\pmod {497} = 120.$\n- $ e′ = 7. c = (120 \\times 4) \\pmod {497} = 480 \\pmod {497} = 480.$\n- $ e′ = 8. c = (480 \\times 4) \\pmod {497} = 1920 \\pmod {497} = 429.$\n- $ e′ = 9. c = (429 \\times 4) \\pmod {497} = 1716 \\pmod {497} = 225.$\n- $ e′ = 10. c = (225 \\times 4) \\pmod {497} = 900 \\pmod {497} = 403.$\n- $ e′ = 11. c = (403 \\times 4) \\pmod {497} = 1612 \\pmod {497} = 121.$\n- $ e′ = 12. c = (121 \\times 4) \\pmod {497} = 484 \\pmod {497} = 484.$\n- $ e′ = 13. c = (484 \\times 4) \\pmod {497} = 1936 \\pmod {497} = 445.$\n\n最终计算得到 $ c = 445 $，和直接计算的结果相同。\n这种方法的时间复杂度是 O(e)。\n<br />\n\n#### 位运算方法\n这个方法大大减少了模幂运算的计算次数，并保持了和上一种方法一致的内存使用，是上面两种方法的结合。\n\n首先，需要把指数 $e$ 写成二进制，即\n$ e = \\sum\\_{i=0}^{n-1} a\\_i \\cdot 2^i $\n\n其中， $e$ 可写为 $n$ 位的二进制数，$ a\\_i $ 可以等于 0 或者 1，$0 ≤ i < n - 1$, 默认 $ a\\_{n-1} = 1$。\n于是，$ b^e $可以改写如下：\n$ b^e = b^{\\left( \\sum\\_{i=0}^{n-1} a\\_i \\cdot 2^i \\right)} = \\prod\\_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a\\_i}$\n\n所以，最后 $c$ 可写为：\n$ c \\equiv \\prod\\_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a\\_i}\\ (\\mbox{mod}\\ m)$\n<br />\n\n如果 $e$ 很大的话，$n$ 也会比较大，此时 $b^{2^i}$ 仍然是一个比较耗费资源的幂运算。所以需要进一步优化：\n$ \\left({b^{2^i}}\\right) ^ {a\\_i} =\n\\begin{cases}\n1 & \\text{ if } a\\_i = 0 \\\\\\\\\nb^{2^i} = ({b^2})^{2^{i-1}} = ({b^2} \\cdot {b^2}) ^ {2^{i-2}} \\pmod m & \\text{ if } a\\_i = 1\n\\end{cases}\n$\n\n这样，通过将幂运算转化为底数 $b$ 的模幂运算，在保证了底数不大于 $m$ 的前提下，使得原公式中的 $2^i$ 部分始终等于1，就避免了高次幂运算。\n例如：(此处我们暂不考虑 $a\\_i$ )\n- $i=0$ 时，$b^{2^i} = b ^ 1 = b \\pmod m = b\\_0$\n- $i=1$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = b ^ 2 \\pmod m = b\\_0^2 \\pmod m = b\\_1$\n- $i=2$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b ^ 2) ^ 2 = b\\_1 ^ 2 \\pmod m = b\\_2$\n- $i=3$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b\\_1^2) ^ 2 = b\\_2 ^ 2 \\pmod m = b\\_3$\n\n这样就可以将 $c$ 改写为：\n$ c \\equiv \\prod\\_{i=0}^{n-1} \\left( b\\_i \\right) ^ {a\\_i}\\ (\\mbox{mod}\\ m), b\\_i = b\\_{i-1}^2 \\pmod m$\n<br />\n\n我们还以上面的例子展示计算过程：\n$b = 4, e = 13 = 1101_{[2]}, m = 497$\n- 令$c = 1$，此时 $i = 0, a\\_i = 1$，所以 $c = (1 \\times 4) \\pmod {497} = 4 , b = (4 \\times 4) \\pmod {497} = 16$\n- $i = 1, a\\_i = 0$，所以 $c$ 不变，$ b = (16 \\times 16) \\pmod {497} = 256$\n- $i = 2, a\\_i = 1$，所以 $c = (4 \\times 256) \\pmod {497} = 30 , b = (256 \\times 256) \\pmod {497} = 429$\n- $i = 3, a\\_i = 1$，所以 $c = (30 \\times 429) \\pmod {497} = 445 , b = (429 \\times 429) \\pmod {497} = 151$，计算结束。\n最终计算得到 $ c = 445 $，和上面的方法计算结果相同。\n\n这个方法的时间复杂度由 O(e) 降为 O(log e).\n\n\n## 结语\n通过这次实践，又挖出了很多坑，发现了很多自己的不足之处。有一些坑还没能填上，留到以后数学水平提高了再回来填吧。另外，通过整理这些素性测试方法，对他们的理解也更深了一些。\n\n纸上得来终觉浅，须知此事要躬行。\n\n\n## References\n1.Matrix67 [素数与素性测试](http://www.matrix67.com/blog/archives/234)\n2.张洋 [聊聊如何检测素数](http://blog.codinglabs.org/articles/prime-test.html)\n3.bindog [RSA周边——大素数是怎样生成的？](http://bindog.github.io/blog/2014/07/19/how-to-generate-big-primes/)\n4.[wikipedia](http://en.wikipedia.org/wiki/Prime_number)\n","source":"_posts/prime-test.md","raw":"title: \"也谈素性测试\"\ndate: 2015-04-21 15:48:05\ncategories:\n- 数学\ntags:\n- 素数\n- 数学\nmathjax: true\n---\n\n## 前言\n很早之前读过 Matrix67的[素数与素性测试](http://www.matrix67.com/blog/archives/234)和 张洋的[聊聊如何检测素数](http://blog.codinglabs.org/articles/prime-test.html)，读了之后获益匪浅，不过一直没有自己动手写一次试试。\n\n最近和朋友聊天，谈到如何找到距离某个数最近的素数，勾起了我的兴趣。遂重新读了这两篇博客，又查阅了一些其他的资料，自己动手写了一个简单的素数检测程序。下面记录了一些这次实践的经历以及脑洞。\n<!-- more -->\n\n## 素数定义\n既然是素性测试，首先要明确素数的定义：\n> A natural number (i.e. 1, 2, 3, 4, 5, 6, etc.) is called a prime number (or a prime) if it has exactly two positive divisors, 1 and the number itself.[1]\n> Natural numbers greater than 1 that are not prime are called composite.\n> -- [wikipedia](http://en.wikipedia.org/wiki/Prime_number)\n\n即，一个自然数如果只能被1和它自身整除，那么这个自然数是素数。\n大于1的自然数不是素数就是合数。\n\n例如：\n- 2是素数，因为它只能被1和2整除。\n- 3是素数。\n- 4不是素数，因为它可以被2整除。\n- 5是素数。\n- 6不是素数，因为它可以被2和3整除。\n\n因此，还有一个结论，以十进制书写时，大于5的素数都是以1、3、7、9结尾的。可以用于快速判断一个数是否 ***不是*** 素数。\n\n## 1的素性\n我一直有一个疑问，1到底是素数还是合数。以前一直是因为看到的素数定义里面都指明了大于1的自然数作为前提，也就没有深究。1这个自然数就一直作为素数定义中的特例被我接受了下来。\n\n这次认真看了下wiki，里面单独提及到了1的素性说明。\n> Most early Greeks did not even consider 1 to be a number,[4] and so they did not consider it a prime. In the 19th century, however, many mathematicians did consider the number 1 a prime. For example, Derrick Norman Lehmer's list of primes up to 10,006,721, reprinted as late as 1956,[5] started with 1 as its first prime.[6] Henri Lebesgue is said to be the last professional mathematician to call 1 prime.[7]\n>\n> Although a large body of mathematical work would still be valid when calling 1 a prime, the fundamental theorem of arithmetic (mentioned above) would not hold as stated. For example, the number 15 can be factored as 3 · 5 and 1 · 3 · 5; if 1 were admitted as a prime, these two presentations would be considered different factorizations of 15 into prime numbers, so the statement of that theorem would have to be modified. Similarly, the sieve of Eratosthenes would not work correctly if 1 were considered a prime: a modified version of the sieve that considers 1 as prime would eliminate all multiples of 1 (that is, all numbers) and produce as output only the single number 1. Furthermore, the prime numbers have several properties that the number 1 lacks, such as the relationship of the number to its corresponding value of Euler's totient function or the sum of divisors function.\n\n原来在19世纪有一些数学教认为1是素数。只不过很多数学成果在1是素数的条件下会有问题。例如：\n- 算术基本定理（[Fundamental theorem of arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)），又称为正整数的唯一分解定理，即：每个大于1的自然数均可写为素数的积，而且这些素因子按大小排列之后，写法仅有一种方式。例如: $6936 = 2^3 \\times 3 \\times 17^2，1200 = 2^4 \\times 3 \\times 5^2$。\n如果1也是素数的话，15可以写成 $3 \\times 5$，也可以写成 $1 \\times 3 \\times 5$。这两个表达式是不同的，这样算数基本定理就需要修改了。\n- 埃拉托斯特尼筛法（[sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)），简称埃氏筛，是一种公元前250年由古希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。\n它通过从2的倍数开始，迭代地将每一个素数的倍数标记为合数来筛选出某个范围中的素数。\n例如，如果要找出小于等于n的所有素数，埃拉托斯特尼的方法是：\n1.创建一个从2到n的连续数列。\n2.首先，令p等于2，即第一个素数。\n3.将数列中等于p的倍数的自然数标记为合数，p本身不标记。\n4.找到未被标记的大于p的第一个数，如果没有这样的数，方法结束。否则，令p等于找到的新数（就是下一个素数），然后重复步骤3。\n![sieve of Eratosthenes](http://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif)\n当这个方法结束时，所有未被标记的数就是素数。\n还有一个优化方式，在第4步中，若$p^2$大于n，则可以直接结束而不必寻找大于p的新数。因为小于等于$p^2$的数中的合数都已经标记过了。\n如果1也是素数的话，在第三步结束后，列表中就只剩下1了。这样这个筛选法也需要修改。\n\n另外，素数的一些特性1也没有，比如[欧拉函数](http://en.wikipedia.org/wiki/Euler%27s_totient_function)和[除数函数](http://en.wikipedia.org/wiki/Divisor_function)中的一些性质。关于1是否是素数的争论一直没有结束，只不过大多数人都倾向于1不是素数，因为1实在太特殊了，对很多理论都有影响。\n\n写到这里发现这个坑太深了，欧拉函数和除数函数我没有仔细往下看，因为越往深追溯遇到的不知道的理论越多。看来这个坑不是一天两天能填上的，我决定先补一下数学基础再说T_T。如果对此感兴趣的朋友可以看下[What is the Smallest Prime?](https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell1/cald5.html)和[The History of the Primality of One: A Selection of Sources](https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell2/cald6.html)。\n\n## 素性测试\n### 试除法（Trial division）\n试除法是判断一个给定整数n是否是素数的最基本的方法。该方法判断所有大于1且小于等于$\\sqrt{n}$的整数是否可以整除n，如果有可以整除的数，则n是合数，否则判断n为素数。因为如果$n = a \\times b, a \\leq b$，则$a \\leq \\sqrt{n}$，所以只要试除到小于等于$\\sqrt{n}$的整数即可。\n\n有一种实现起来更高效的方式，只要试除2到$\\sqrt{n}$之间的所有素数，即可判断出n是否是素数。因为合数都可以写成更小的素数的乘积（参考上面提到的算术基本定理）。\n\n虽然试除法逻辑简单，实现比较容易，但是在面对大整数的时候，需要试除的素数数量会极速增长。根据[素数计数函数](http://en.wikipedia.org/wiki/Prime-counting_function), 小于$\\sqrt{n}$的素数数量约等于 $\\sqrt{n} / \\ln(\\sqrt{n})$，所以试除法需要至少判断这些数是否能整除n。如果 $n = 10^{20}$，则需要试除4亿多个素数。这在现实工程中是难以接受的。\n<br />\n\n### 费马素性测试（[Fermat_primality_test](http://en.wikipedia.org/wiki/Fermat_primality_test)）\n既然试除法的效率无法接受，那么就需要寻找其他的替代方法。基于费马小定理，人们提出了一种基于随机化算法的检测方法来判断一个数是合数还是 ***可能是*** 素数，即费马素性测试。\n\n首先我们还是先看一下理论基础，[费马小定理](http://en.wikipedia.org/wiki/Fermat%27s_little_theorem)：\n***如果p是素数，a是小于p的正整数，那么 $a^{p-1} \\equiv 1 \\pmod p$。***\n\n（关于费马小定理， Matrix67写得深入浅出，我应该不会写得比这个更好了，所以这部分直接引用自 Matrix67同学的[素数与素性测试](http://www.matrix67.com/blog/archives/234)）\n> 这个证明就有点麻烦了。\n> 首先我们证明这样一个结论：如果 $p$ 是一个素数的话，那么对任意一个小于 $p$ 的正整数$a$，$a, 2a, 3a, ..., (p-1)a$ 除以 $p$ 的余数正好是一个 $1$ 到 $p-1$ 的排列。例如，5是素数，3, 6, 9, 12除以5的余数分别为3, 1, 4, 2，正好就是1到4这四个数。\n>\n> 反证法，假如结论不成立的话，那么就是说有两个小于 $p$ 的正整数 $m$ 和 $n$ 使得 $na$ 和 $ma$ 除以 $p$ 的余数相同。不妨假设 $n > m$，则 $p$ 可以整除 $a(n-m)$。但 $p$ 是素数，那么 $a$ 和 $n-m$ 中至少有一个含有因子 $p$。这显然是不可能的，因为 $a$ 和 $n-m$ 都比 $p$ 小。\n>\n> 用同余式表述，我们证明了：\n> $(p-1)! \\equiv a \\times 2a \\times 3a \\times ... \\times (p-1)a \\pmod p$\n> 也即：\n> $(p-1)! \\equiv (p-1)! \\times a^{p-1} \\pmod p$\n> 两边同时除以 $(p-1)!$，就得到了我们的最终结论：\n> $1 ≡ a^{p-1} \\pmod p$\n\n\n费马素性测试，即选取小于p的正整数a，测试费马小定理是否成立，如果不成立，则p一定不是素数，如果成立，则p可能是素数。将上述过程重复n次，每次随机选取整数a进行测试。一般情况下，选取的a越多，测试结果越准确。\n\n而有一些合数p，对于所有大于1且小于p的正整数都符合费马小定理，这样的数p称为卡迈克尔数（[Carmichael number](http://en.wikipedia.org/wiki/Carmichael_number)）。保罗·艾狄胥猜想有无限个卡迈克尔数，1994年 William Alford 、 Andrew Granville 及 Carl Pomerance 证明了这个命题。最小的卡迈克尔数是561。因为这些数的存在，使得费马素性检验变得不可靠。\n<br />\n\n### 米勒-拉宾素性测试（[Miller–Rabin_primality_test](http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)）\n米勒-拉宾素性测试也是一个基于随机化算法的素性测试方法，判断了一个数是合数还是 ***可能是*** 素数。和费马素性测试相似，米勒-拉宾素性测试也是通过判断一组对素数成立的等式是否对我们想测试的数也成立来实现素性测试的。\n\n这个方法的原始版本来自卡内基梅隆大学的计算机系教授Gary Lee Miller，他首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。\n<br />\n\n#### 定理\n米勒-拉宾素性测试基于下面的定理：\n如果对模 $n$ 存在 $1$ 的非平凡平方根，则 $n$ 是合数。即对方程 $x^2 \\equiv 1 \\pmod n$，方程的解除了 $1$ 和 $n-1$ 两个平凡根之外，还有其它的根，那么 $n$ 肯定是合数。\n\n假设 $p$是大于2的素数， $x$ 是摸 $p$ 等于1的平方根，则：\n$x^2 \\equiv 1 \\pmod p$ ，即 $ (x - 1)( x + 1) \\equiv 0 \\pmod{p}$\n也就是说素数 $p$ 整除 $(x - 1)( x + 1)$，因为 $p$ 是素数，它只能被 1 和 $p$ 整除，所以一定有 $x - 1 \\equiv 0 \\pmod p$ 或 $x - 1 \\equiv 0 \\pmod p$，所以 $x$ 模 $p$ 等于 1 或者 $p - 1$。\n<br />\n\n#### 方法\n假设 $n$ 是素数，且 $n > 2$，则 $n - 1$是偶数，我们可以将其写为 $2^s \\times d$ 的形式，其中 $s$ 和 $d$ 都是正整数，$d$ 是奇数。\n\n结合费马小定理，$a^{p-1} \\equiv 1 \\pmod p$。如果 $p$ 是素数，则 $p - 1$是偶数，我们不断计算 $a^{p-1}$的平方根，那么最后一定会得到 1 或者 $p - 1$。\n\n根据以上的理论，米勒-拉宾素性测试的等效表达为：\n1.把 $n-1$ 表示成 $d \\times 2^s$\n2.计算 $a^{d \\times 2^r} \\pmod n ( 0 \\leq r \\leq s - 1 )$，（$r = s$ 时，此算式等效于费马小定理）\n3.若结果是 1 和 $n-1$ 以外的值，测试结束，$n$是合数\n4.若结果是 $n-1$，那么测试结束， $n$可能是素数，可以换一个底数 $a$ 进行下一轮计算\n5.若结果是 1，那么仍然符合费马小定理，继续计算开方的值。即令 $r = r - 1$，$r \\neq 0$ 的情况下回到第2步\n6.直到计算到 $r = 0$，即 $a^d \\pmod n$\n7.若结果是 1 或 $n-1$，那么$n$可能是素数，可以换一个底数 $a$ 进行下一轮计算。否则测试结束，$n$是合数。\n\n所以如果 $n$ 是一个素数，那么或者 $a^d \\equiv 1 \\pmod n$，或者存在某个 $r$ 使得 $a^{d \\times 2^r} \\equiv n-1 \\pmod n ( 0 \\leq r \\leq s-1 )$。\n<br />\n\n以上面提到的卡迈克尔数 561为例，我们来看一下米勒-拉宾素性测试的实际应用：\n1.560可以表示成 $35 \\times 2^4$, 我们知道 $2^{560} = 1 \\pmod {561}$。\n2.计算得到 $2^{35 \\times 2 ^ 3} = 1 \\pmod {561}$\n3.结果仍然符合费马小定理，继续计算，得到 $2^{35 \\times 2 ^ 2} = 67 \\pmod {561}$\n4.测试结束，561是合数\n\n下面引用 Matrix67同学的[素数与素性测试](http://www.matrix67.com/blog/archives/234)补充说明：\n> Miller-Rabin素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。\n>\n> 对于大数的素性判断，目前Miller-Rabin算法应用最广泛。一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于4 759 123 141，那么只需要测试三个底数2, 7和61就足够了。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11, 13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用2, 3, 7, 61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255 981。这样的一些结论使得Miller-Rabin算法在OI中非常实用。\n>\n> 通常认为，Miller-Rabin素性测试的正确率可以令人接受，随机选取k个底数进行测试算法的失误率大概为 $4^{-k}$。\n\n<br />\n### AKS素数测试\n> AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法。由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal 和 Nitin Saxena 提出，在2002年8月6日发表于一篇题为 PRIMES is in P 的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的 Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。\n>\n> AKS最关键的重要性在于它是第一个被发表的**一般的**、**多项式的**、**确定性的**和**无仰赖的**素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。\n>\n> AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。\n> 算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。\n> 算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。\n> AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。\n> -- [wikipedia](http://zh.wikipedia.org/wiki/AKS%E8%B3%AA%E6%95%B8%E6%B8%AC%E8%A9%A6)\n\n此处留坑，有生之年。。。\n[PRIMES is in P](http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf)\n<br />\n\n### 模幂运算（[Modular exponentiation](http://en.wikipedia.org/wiki/Modular_exponentiation)）\n上面提到的费马素性测试和米勒-拉宾素性测试都涉及到了大量的模幂运算。\n模幂运算计算了正整数 $b$ 的 $e$ 次方除以正整数 $m$ 的余数。用符号表示为，给定底数 $b$, 指数 $e$, 和模数 $m$, 模幂运算就是 $ c \\equiv b^e \\pmod{m}$。\n<br />\n\n#### 直接计算\n最基础的办法就是直接计算 $ b^e $，然后对 $m$ 取余。假设 $b = 4, e = 13, m = 497$，则 $ c \\equiv 4^{13} \\pmod{497} $。计算得到 $ 4^{13} $ 等于67,108,864，对497取模计算出 $c$, 为445。\n\n这个例子中 $b$ 和 $e$ 都是一位数，计算得到的 $ b^e $ 却是8位数。如果判断一个大数是否是素数的时候，$b$ 和 $e$ 都会很大，直接计算的计算效率将变得无法接受，所以需要更高效的计算方法。\n<br />\n\n#### 内存优化计算方法\n这个方法相比于直接计算，计算次数增多了，但是因为每次计算大大节省了内存的使用，所以总的计算速度还是比直接计算更快。\n\n这个方法的理论基础是，\n$ c \\equiv (a \\cdot b) \\pmod{m} $ 等价于 $ c \\equiv (a \\cdot (b\\ (\\mbox{mod}\\ m))) \\pmod{m} $\n这样，不直接计算 $ b^e $，而是计算 $ \\prod\\_{i=0}^{e} b $，这样就可以根据上面的等式将每次乘以 $b$ 以后的结果取余，从而使计算过程中的中间变量一直小于模数 $m$，确保了内存使用效率。\n\n具体的步骤如下：\n1.令结果 $c = 1, e′ = 0.$\n2.令 $ e′ = e′ + 1 $\n3.计算 $ c \\equiv (b \\cdot c) \\pmod{m} $\n4.如果 $ e′ < e $，回到第二步；否则计算结束，此时 $ c \\equiv b^e \\pmod{m} $。\n\n我们还用上面的例子来展示计算的具体过程：\n$b = 4, e = 13, m = 497$\n- $ e′ = 1. c = (1 \\times 4) \\pmod {497} = 4 \\pmod {497} = 4.$\n- $ e′ = 2. c = (4 \\times 4) \\pmod {497} = 16 \\pmod {497} = 16.$\n- $ e′ = 3. c = (16 \\times 4) \\pmod {497} = 64 \\pmod {497} = 64.$\n- $ e′ = 4. c = (64 \\times 4) \\pmod {497} = 256 \\pmod {497} = 256.$\n- $ e′ = 5. c = (256 \\times 4) \\pmod {497} = 1024 \\pmod {497} = 30.$\n- $ e′ = 6. c = (30 \\times 4) \\pmod {497} = 120 \\pmod {497} = 120.$\n- $ e′ = 7. c = (120 \\times 4) \\pmod {497} = 480 \\pmod {497} = 480.$\n- $ e′ = 8. c = (480 \\times 4) \\pmod {497} = 1920 \\pmod {497} = 429.$\n- $ e′ = 9. c = (429 \\times 4) \\pmod {497} = 1716 \\pmod {497} = 225.$\n- $ e′ = 10. c = (225 \\times 4) \\pmod {497} = 900 \\pmod {497} = 403.$\n- $ e′ = 11. c = (403 \\times 4) \\pmod {497} = 1612 \\pmod {497} = 121.$\n- $ e′ = 12. c = (121 \\times 4) \\pmod {497} = 484 \\pmod {497} = 484.$\n- $ e′ = 13. c = (484 \\times 4) \\pmod {497} = 1936 \\pmod {497} = 445.$\n\n最终计算得到 $ c = 445 $，和直接计算的结果相同。\n这种方法的时间复杂度是 O(e)。\n<br />\n\n#### 位运算方法\n这个方法大大减少了模幂运算的计算次数，并保持了和上一种方法一致的内存使用，是上面两种方法的结合。\n\n首先，需要把指数 $e$ 写成二进制，即\n$ e = \\sum\\_{i=0}^{n-1} a\\_i \\cdot 2^i $\n\n其中， $e$ 可写为 $n$ 位的二进制数，$ a\\_i $ 可以等于 0 或者 1，$0 ≤ i < n - 1$, 默认 $ a\\_{n-1} = 1$。\n于是，$ b^e $可以改写如下：\n$ b^e = b^{\\left( \\sum\\_{i=0}^{n-1} a\\_i \\cdot 2^i \\right)} = \\prod\\_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a\\_i}$\n\n所以，最后 $c$ 可写为：\n$ c \\equiv \\prod\\_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a\\_i}\\ (\\mbox{mod}\\ m)$\n<br />\n\n如果 $e$ 很大的话，$n$ 也会比较大，此时 $b^{2^i}$ 仍然是一个比较耗费资源的幂运算。所以需要进一步优化：\n$ \\left({b^{2^i}}\\right) ^ {a\\_i} =\n\\begin{cases}\n1 & \\text{ if } a\\_i = 0 \\\\\\\\\nb^{2^i} = ({b^2})^{2^{i-1}} = ({b^2} \\cdot {b^2}) ^ {2^{i-2}} \\pmod m & \\text{ if } a\\_i = 1\n\\end{cases}\n$\n\n这样，通过将幂运算转化为底数 $b$ 的模幂运算，在保证了底数不大于 $m$ 的前提下，使得原公式中的 $2^i$ 部分始终等于1，就避免了高次幂运算。\n例如：(此处我们暂不考虑 $a\\_i$ )\n- $i=0$ 时，$b^{2^i} = b ^ 1 = b \\pmod m = b\\_0$\n- $i=1$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = b ^ 2 \\pmod m = b\\_0^2 \\pmod m = b\\_1$\n- $i=2$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b ^ 2) ^ 2 = b\\_1 ^ 2 \\pmod m = b\\_2$\n- $i=3$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b\\_1^2) ^ 2 = b\\_2 ^ 2 \\pmod m = b\\_3$\n\n这样就可以将 $c$ 改写为：\n$ c \\equiv \\prod\\_{i=0}^{n-1} \\left( b\\_i \\right) ^ {a\\_i}\\ (\\mbox{mod}\\ m), b\\_i = b\\_{i-1}^2 \\pmod m$\n<br />\n\n我们还以上面的例子展示计算过程：\n$b = 4, e = 13 = 1101_{[2]}, m = 497$\n- 令$c = 1$，此时 $i = 0, a\\_i = 1$，所以 $c = (1 \\times 4) \\pmod {497} = 4 , b = (4 \\times 4) \\pmod {497} = 16$\n- $i = 1, a\\_i = 0$，所以 $c$ 不变，$ b = (16 \\times 16) \\pmod {497} = 256$\n- $i = 2, a\\_i = 1$，所以 $c = (4 \\times 256) \\pmod {497} = 30 , b = (256 \\times 256) \\pmod {497} = 429$\n- $i = 3, a\\_i = 1$，所以 $c = (30 \\times 429) \\pmod {497} = 445 , b = (429 \\times 429) \\pmod {497} = 151$，计算结束。\n最终计算得到 $ c = 445 $，和上面的方法计算结果相同。\n\n这个方法的时间复杂度由 O(e) 降为 O(log e).\n\n\n## 结语\n通过这次实践，又挖出了很多坑，发现了很多自己的不足之处。有一些坑还没能填上，留到以后数学水平提高了再回来填吧。另外，通过整理这些素性测试方法，对他们的理解也更深了一些。\n\n纸上得来终觉浅，须知此事要躬行。\n\n\n## References\n1.Matrix67 [素数与素性测试](http://www.matrix67.com/blog/archives/234)\n2.张洋 [聊聊如何检测素数](http://blog.codinglabs.org/articles/prime-test.html)\n3.bindog [RSA周边——大素数是怎样生成的？](http://bindog.github.io/blog/2014/07/19/how-to-generate-big-primes/)\n4.[wikipedia](http://en.wikipedia.org/wiki/Prime_number)\n","slug":"prime-test","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910s00086bk2i820083t","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很早之前读过 Matrix67的<a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a>和 张洋的<a href=\"http://blog.codinglabs.org/articles/prime-test.html\" target=\"_blank\" rel=\"noopener\">聊聊如何检测素数</a>，读了之后获益匪浅，不过一直没有自己动手写一次试试。</p>\n<p>最近和朋友聊天，谈到如何找到距离某个数最近的素数，勾起了我的兴趣。遂重新读了这两篇博客，又查阅了一些其他的资料，自己动手写了一个简单的素数检测程序。下面记录了一些这次实践的经历以及脑洞。<br><a id=\"more\"></a></p>\n<h2 id=\"素数定义\"><a href=\"#素数定义\" class=\"headerlink\" title=\"素数定义\"></a>素数定义</h2><p>既然是素性测试，首先要明确素数的定义：</p>\n<blockquote>\n<p>A natural number (i.e. 1, 2, 3, 4, 5, 6, etc.) is called a prime number (or a prime) if it has exactly two positive divisors, 1 and the number itself.[1]<br>Natural numbers greater than 1 that are not prime are called composite.<br>– <a href=\"http://en.wikipedia.org/wiki/Prime_number\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>\n</blockquote>\n<p>即，一个自然数如果只能被1和它自身整除，那么这个自然数是素数。<br>大于1的自然数不是素数就是合数。</p>\n<p>例如：</p>\n<ul>\n<li>2是素数，因为它只能被1和2整除。</li>\n<li>3是素数。</li>\n<li>4不是素数，因为它可以被2整除。</li>\n<li>5是素数。</li>\n<li>6不是素数，因为它可以被2和3整除。</li>\n</ul>\n<p>因此，还有一个结论，以十进制书写时，大于5的素数都是以1、3、7、9结尾的。可以用于快速判断一个数是否 <strong><em>不是</em></strong> 素数。</p>\n<h2 id=\"1的素性\"><a href=\"#1的素性\" class=\"headerlink\" title=\"1的素性\"></a>1的素性</h2><p>我一直有一个疑问，1到底是素数还是合数。以前一直是因为看到的素数定义里面都指明了大于1的自然数作为前提，也就没有深究。1这个自然数就一直作为素数定义中的特例被我接受了下来。</p>\n<p>这次认真看了下wiki，里面单独提及到了1的素性说明。</p>\n<blockquote>\n<p>Most early Greeks did not even consider 1 to be a number,[4] and so they did not consider it a prime. In the 19th century, however, many mathematicians did consider the number 1 a prime. For example, Derrick Norman Lehmer’s list of primes up to 10,006,721, reprinted as late as 1956,[5] started with 1 as its first prime.[6] Henri Lebesgue is said to be the last professional mathematician to call 1 prime.[7]</p>\n<p>Although a large body of mathematical work would still be valid when calling 1 a prime, the fundamental theorem of arithmetic (mentioned above) would not hold as stated. For example, the number 15 can be factored as 3 · 5 and 1 · 3 · 5; if 1 were admitted as a prime, these two presentations would be considered different factorizations of 15 into prime numbers, so the statement of that theorem would have to be modified. Similarly, the sieve of Eratosthenes would not work correctly if 1 were considered a prime: a modified version of the sieve that considers 1 as prime would eliminate all multiples of 1 (that is, all numbers) and produce as output only the single number 1. Furthermore, the prime numbers have several properties that the number 1 lacks, such as the relationship of the number to its corresponding value of Euler’s totient function or the sum of divisors function.</p>\n</blockquote>\n<p>原来在19世纪有一些数学教认为1是素数。只不过很多数学成果在1是素数的条件下会有问题。例如：</p>\n<ul>\n<li>算术基本定理（<a href=\"http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\" target=\"_blank\" rel=\"noopener\">Fundamental theorem of arithmetic</a>），又称为正整数的唯一分解定理，即：每个大于1的自然数均可写为素数的积，而且这些素因子按大小排列之后，写法仅有一种方式。例如: $6936 = 2^3 \\times 3 \\times 17^2，1200 = 2^4 \\times 3 \\times 5^2$。<br>如果1也是素数的话，15可以写成 $3 \\times 5$，也可以写成 $1 \\times 3 \\times 5$。这两个表达式是不同的，这样算数基本定理就需要修改了。</li>\n<li>埃拉托斯特尼筛法（<a href=\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\" target=\"_blank\" rel=\"noopener\">sieve of Eratosthenes</a>），简称埃氏筛，是一种公元前250年由古希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。<br>它通过从2的倍数开始，迭代地将每一个素数的倍数标记为合数来筛选出某个范围中的素数。<br>例如，如果要找出小于等于n的所有素数，埃拉托斯特尼的方法是：<br>1.创建一个从2到n的连续数列。<br>2.首先，令p等于2，即第一个素数。<br>3.将数列中等于p的倍数的自然数标记为合数，p本身不标记。<br>4.找到未被标记的大于p的第一个数，如果没有这样的数，方法结束。否则，令p等于找到的新数（就是下一个素数），然后重复步骤3。<br><img src=\"http://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\" alt=\"sieve of Eratosthenes\"><br>当这个方法结束时，所有未被标记的数就是素数。<br>还有一个优化方式，在第4步中，若$p^2$大于n，则可以直接结束而不必寻找大于p的新数。因为小于等于$p^2$的数中的合数都已经标记过了。<br>如果1也是素数的话，在第三步结束后，列表中就只剩下1了。这样这个筛选法也需要修改。</li>\n</ul>\n<p>另外，素数的一些特性1也没有，比如<a href=\"http://en.wikipedia.org/wiki/Euler%27s_totient_function\" target=\"_blank\" rel=\"noopener\">欧拉函数</a>和<a href=\"http://en.wikipedia.org/wiki/Divisor_function\" target=\"_blank\" rel=\"noopener\">除数函数</a>中的一些性质。关于1是否是素数的争论一直没有结束，只不过大多数人都倾向于1不是素数，因为1实在太特殊了，对很多理论都有影响。</p>\n<p>写到这里发现这个坑太深了，欧拉函数和除数函数我没有仔细往下看，因为越往深追溯遇到的不知道的理论越多。看来这个坑不是一天两天能填上的，我决定先补一下数学基础再说T_T。如果对此感兴趣的朋友可以看下<a href=\"https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell1/cald5.html\" target=\"_blank\" rel=\"noopener\">What is the Smallest Prime?</a>和<a href=\"https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell2/cald6.html\" target=\"_blank\" rel=\"noopener\">The History of the Primality of One: A Selection of Sources</a>。</p>\n<h2 id=\"素性测试\"><a href=\"#素性测试\" class=\"headerlink\" title=\"素性测试\"></a>素性测试</h2><h3 id=\"试除法（Trial-division）\"><a href=\"#试除法（Trial-division）\" class=\"headerlink\" title=\"试除法（Trial division）\"></a>试除法（Trial division）</h3><p>试除法是判断一个给定整数n是否是素数的最基本的方法。该方法判断所有大于1且小于等于$\\sqrt{n}$的整数是否可以整除n，如果有可以整除的数，则n是合数，否则判断n为素数。因为如果$n = a \\times b, a \\leq b$，则$a \\leq \\sqrt{n}$，所以只要试除到小于等于$\\sqrt{n}$的整数即可。</p>\n<p>有一种实现起来更高效的方式，只要试除2到$\\sqrt{n}$之间的所有素数，即可判断出n是否是素数。因为合数都可以写成更小的素数的乘积（参考上面提到的算术基本定理）。</p>\n<p>虽然试除法逻辑简单，实现比较容易，但是在面对大整数的时候，需要试除的素数数量会极速增长。根据<a href=\"http://en.wikipedia.org/wiki/Prime-counting_function\" target=\"_blank\" rel=\"noopener\">素数计数函数</a>, 小于$\\sqrt{n}$的素数数量约等于 $\\sqrt{n} / \\ln(\\sqrt{n})$，所以试除法需要至少判断这些数是否能整除n。如果 $n = 10^{20}$，则需要试除4亿多个素数。这在现实工程中是难以接受的。<br><br></p>\n<h3 id=\"费马素性测试（Fermat-primality-test）\"><a href=\"#费马素性测试（Fermat-primality-test）\" class=\"headerlink\" title=\"费马素性测试（Fermat_primality_test）\"></a>费马素性测试（<a href=\"http://en.wikipedia.org/wiki/Fermat_primality_test\" target=\"_blank\" rel=\"noopener\">Fermat_primality_test</a>）</h3><p>既然试除法的效率无法接受，那么就需要寻找其他的替代方法。基于费马小定理，人们提出了一种基于随机化算法的检测方法来判断一个数是合数还是 <strong><em>可能是</em></strong> 素数，即费马素性测试。</p>\n<p>首先我们还是先看一下理论基础，<a href=\"http://en.wikipedia.org/wiki/Fermat%27s_little_theorem\" target=\"_blank\" rel=\"noopener\">费马小定理</a>：<br><strong><em>如果p是素数，a是小于p的正整数，那么 $a^{p-1} \\equiv 1 \\pmod p$。</em></strong></p>\n<p>（关于费马小定理， Matrix67写得深入浅出，我应该不会写得比这个更好了，所以这部分直接引用自 Matrix67同学的<a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a>）</p>\n<blockquote>\n<p>这个证明就有点麻烦了。<br>首先我们证明这样一个结论：如果 $p$ 是一个素数的话，那么对任意一个小于 $p$ 的正整数$a$，$a, 2a, 3a, …, (p-1)a$ 除以 $p$ 的余数正好是一个 $1$ 到 $p-1$ 的排列。例如，5是素数，3, 6, 9, 12除以5的余数分别为3, 1, 4, 2，正好就是1到4这四个数。</p>\n<p>反证法，假如结论不成立的话，那么就是说有两个小于 $p$ 的正整数 $m$ 和 $n$ 使得 $na$ 和 $ma$ 除以 $p$ 的余数相同。不妨假设 $n &gt; m$，则 $p$ 可以整除 $a(n-m)$。但 $p$ 是素数，那么 $a$ 和 $n-m$ 中至少有一个含有因子 $p$。这显然是不可能的，因为 $a$ 和 $n-m$ 都比 $p$ 小。</p>\n<p>用同余式表述，我们证明了：<br>$(p-1)! \\equiv a \\times 2a \\times 3a \\times … \\times (p-1)a \\pmod p$<br>也即：<br>$(p-1)! \\equiv (p-1)! \\times a^{p-1} \\pmod p$<br>两边同时除以 $(p-1)!$，就得到了我们的最终结论：<br>$1 ≡ a^{p-1} \\pmod p$</p>\n</blockquote>\n<p>费马素性测试，即选取小于p的正整数a，测试费马小定理是否成立，如果不成立，则p一定不是素数，如果成立，则p可能是素数。将上述过程重复n次，每次随机选取整数a进行测试。一般情况下，选取的a越多，测试结果越准确。</p>\n<p>而有一些合数p，对于所有大于1且小于p的正整数都符合费马小定理，这样的数p称为卡迈克尔数（<a href=\"http://en.wikipedia.org/wiki/Carmichael_number\" target=\"_blank\" rel=\"noopener\">Carmichael number</a>）。保罗·艾狄胥猜想有无限个卡迈克尔数，1994年 William Alford 、 Andrew Granville 及 Carl Pomerance 证明了这个命题。最小的卡迈克尔数是561。因为这些数的存在，使得费马素性检验变得不可靠。<br><br></p>\n<h3 id=\"米勒-拉宾素性测试（Miller–Rabin-primality-test）\"><a href=\"#米勒-拉宾素性测试（Miller–Rabin-primality-test）\" class=\"headerlink\" title=\"米勒-拉宾素性测试（Miller–Rabin_primality_test）\"></a>米勒-拉宾素性测试（<a href=\"http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\" target=\"_blank\" rel=\"noopener\">Miller–Rabin_primality_test</a>）</h3><p>米勒-拉宾素性测试也是一个基于随机化算法的素性测试方法，判断了一个数是合数还是 <strong><em>可能是</em></strong> 素数。和费马素性测试相似，米勒-拉宾素性测试也是通过判断一组对素数成立的等式是否对我们想测试的数也成立来实现素性测试的。</p>\n<p>这个方法的原始版本来自卡内基梅隆大学的计算机系教授Gary Lee Miller，他首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。<br><br></p>\n<h4 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h4><p>米勒-拉宾素性测试基于下面的定理：<br>如果对模 $n$ 存在 $1$ 的非平凡平方根，则 $n$ 是合数。即对方程 $x^2 \\equiv 1 \\pmod n$，方程的解除了 $1$ 和 $n-1$ 两个平凡根之外，还有其它的根，那么 $n$ 肯定是合数。</p>\n<p>假设 $p$是大于2的素数， $x$ 是摸 $p$ 等于1的平方根，则：<br>$x^2 \\equiv 1 \\pmod p$ ，即 $ (x - 1)( x + 1) \\equiv 0 \\pmod{p}$<br>也就是说素数 $p$ 整除 $(x - 1)( x + 1)$，因为 $p$ 是素数，它只能被 1 和 $p$ 整除，所以一定有 $x - 1 \\equiv 0 \\pmod p$ 或 $x - 1 \\equiv 0 \\pmod p$，所以 $x$ 模 $p$ 等于 1 或者 $p - 1$。<br><br></p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>假设 $n$ 是素数，且 $n &gt; 2$，则 $n - 1$是偶数，我们可以将其写为 $2^s \\times d$ 的形式，其中 $s$ 和 $d$ 都是正整数，$d$ 是奇数。</p>\n<p>结合费马小定理，$a^{p-1} \\equiv 1 \\pmod p$。如果 $p$ 是素数，则 $p - 1$是偶数，我们不断计算 $a^{p-1}$的平方根，那么最后一定会得到 1 或者 $p - 1$。</p>\n<p>根据以上的理论，米勒-拉宾素性测试的等效表达为：<br>1.把 $n-1$ 表示成 $d \\times 2^s$<br>2.计算 $a^{d \\times 2^r} \\pmod n ( 0 \\leq r \\leq s - 1 )$，（$r = s$ 时，此算式等效于费马小定理）<br>3.若结果是 1 和 $n-1$ 以外的值，测试结束，$n$是合数<br>4.若结果是 $n-1$，那么测试结束， $n$可能是素数，可以换一个底数 $a$ 进行下一轮计算<br>5.若结果是 1，那么仍然符合费马小定理，继续计算开方的值。即令 $r = r - 1$，$r \\neq 0$ 的情况下回到第2步<br>6.直到计算到 $r = 0$，即 $a^d \\pmod n$<br>7.若结果是 1 或 $n-1$，那么$n$可能是素数，可以换一个底数 $a$ 进行下一轮计算。否则测试结束，$n$是合数。</p>\n<p>所以如果 $n$ 是一个素数，那么或者 $a^d \\equiv 1 \\pmod n$，或者存在某个 $r$ 使得 $a^{d \\times 2^r} \\equiv n-1 \\pmod n ( 0 \\leq r \\leq s-1 )$。<br><br></p>\n<p>以上面提到的卡迈克尔数 561为例，我们来看一下米勒-拉宾素性测试的实际应用：<br>1.560可以表示成 $35 \\times 2^4$, 我们知道 $2^{560} = 1 \\pmod {561}$。<br>2.计算得到 $2^{35 \\times 2 ^ 3} = 1 \\pmod {561}$<br>3.结果仍然符合费马小定理，继续计算，得到 $2^{35 \\times 2 ^ 2} = 67 \\pmod {561}$<br>4.测试结束，561是合数</p>\n<p>下面引用 Matrix67同学的<a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a>补充说明：</p>\n<blockquote>\n<p>Miller-Rabin素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。</p>\n<p>对于大数的素性判断，目前Miller-Rabin算法应用最广泛。一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于4 759 123 141，那么只需要测试三个底数2, 7和61就足够了。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11, 13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用2, 3, 7, 61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255 981。这样的一些结论使得Miller-Rabin算法在OI中非常实用。</p>\n<p>通常认为，Miller-Rabin素性测试的正确率可以令人接受，随机选取k个底数进行测试算法的失误率大概为 $4^{-k}$。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"AKS素数测试\"><a href=\"#AKS素数测试\" class=\"headerlink\" title=\"AKS素数测试\"></a>AKS素数测试</h3><blockquote>\n<p>AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法。由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal 和 Nitin Saxena 提出，在2002年8月6日发表于一篇题为 PRIMES is in P 的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的 Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。</p>\n<p>AKS最关键的重要性在于它是第一个被发表的<strong>一般的</strong>、<strong>多项式的</strong>、<strong>确定性的</strong>和<strong>无仰赖的</strong>素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。</p>\n<p>AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。<br>算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。<br>算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。<br>AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。<br>– <a href=\"http://zh.wikipedia.org/wiki/AKS%E8%B3%AA%E6%95%B8%E6%B8%AC%E8%A9%A6\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>\n</blockquote>\n<p>此处留坑，有生之年。。。<br><a href=\"http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf\" target=\"_blank\" rel=\"noopener\">PRIMES is in P</a><br><br></p>\n<h3 id=\"模幂运算（Modular-exponentiation）\"><a href=\"#模幂运算（Modular-exponentiation）\" class=\"headerlink\" title=\"模幂运算（Modular exponentiation）\"></a>模幂运算（<a href=\"http://en.wikipedia.org/wiki/Modular_exponentiation\" target=\"_blank\" rel=\"noopener\">Modular exponentiation</a>）</h3><p>上面提到的费马素性测试和米勒-拉宾素性测试都涉及到了大量的模幂运算。<br>模幂运算计算了正整数 $b$ 的 $e$ 次方除以正整数 $m$ 的余数。用符号表示为，给定底数 $b$, 指数 $e$, 和模数 $m$, 模幂运算就是 $ c \\equiv b^e \\pmod{m}$。<br><br></p>\n<h4 id=\"直接计算\"><a href=\"#直接计算\" class=\"headerlink\" title=\"直接计算\"></a>直接计算</h4><p>最基础的办法就是直接计算 $ b^e $，然后对 $m$ 取余。假设 $b = 4, e = 13, m = 497$，则 $ c \\equiv 4^{13} \\pmod{497} $。计算得到 $ 4^{13} $ 等于67,108,864，对497取模计算出 $c$, 为445。</p>\n<p>这个例子中 $b$ 和 $e$ 都是一位数，计算得到的 $ b^e $ 却是8位数。如果判断一个大数是否是素数的时候，$b$ 和 $e$ 都会很大，直接计算的计算效率将变得无法接受，所以需要更高效的计算方法。<br><br></p>\n<h4 id=\"内存优化计算方法\"><a href=\"#内存优化计算方法\" class=\"headerlink\" title=\"内存优化计算方法\"></a>内存优化计算方法</h4><p>这个方法相比于直接计算，计算次数增多了，但是因为每次计算大大节省了内存的使用，所以总的计算速度还是比直接计算更快。</p>\n<p>这个方法的理论基础是，<br>$ c \\equiv (a \\cdot b) \\pmod{m} $ 等价于 $ c \\equiv (a \\cdot (b\\ (\\mbox{mod}\\ m))) \\pmod{m} $<br>这样，不直接计算 $ b^e $，而是计算 $ \\prod_{i=0}^{e} b $，这样就可以根据上面的等式将每次乘以 $b$ 以后的结果取余，从而使计算过程中的中间变量一直小于模数 $m$，确保了内存使用效率。</p>\n<p>具体的步骤如下：<br>1.令结果 $c = 1, e′ = 0.$<br>2.令 $ e′ = e′ + 1 $<br>3.计算 $ c \\equiv (b \\cdot c) \\pmod{m} $<br>4.如果 $ e′ &lt; e $，回到第二步；否则计算结束，此时 $ c \\equiv b^e \\pmod{m} $。</p>\n<p>我们还用上面的例子来展示计算的具体过程：<br>$b = 4, e = 13, m = 497$</p>\n<ul>\n<li>$ e′ = 1. c = (1 \\times 4) \\pmod {497} = 4 \\pmod {497} = 4.$</li>\n<li>$ e′ = 2. c = (4 \\times 4) \\pmod {497} = 16 \\pmod {497} = 16.$</li>\n<li>$ e′ = 3. c = (16 \\times 4) \\pmod {497} = 64 \\pmod {497} = 64.$</li>\n<li>$ e′ = 4. c = (64 \\times 4) \\pmod {497} = 256 \\pmod {497} = 256.$</li>\n<li>$ e′ = 5. c = (256 \\times 4) \\pmod {497} = 1024 \\pmod {497} = 30.$</li>\n<li>$ e′ = 6. c = (30 \\times 4) \\pmod {497} = 120 \\pmod {497} = 120.$</li>\n<li>$ e′ = 7. c = (120 \\times 4) \\pmod {497} = 480 \\pmod {497} = 480.$</li>\n<li>$ e′ = 8. c = (480 \\times 4) \\pmod {497} = 1920 \\pmod {497} = 429.$</li>\n<li>$ e′ = 9. c = (429 \\times 4) \\pmod {497} = 1716 \\pmod {497} = 225.$</li>\n<li>$ e′ = 10. c = (225 \\times 4) \\pmod {497} = 900 \\pmod {497} = 403.$</li>\n<li>$ e′ = 11. c = (403 \\times 4) \\pmod {497} = 1612 \\pmod {497} = 121.$</li>\n<li>$ e′ = 12. c = (121 \\times 4) \\pmod {497} = 484 \\pmod {497} = 484.$</li>\n<li>$ e′ = 13. c = (484 \\times 4) \\pmod {497} = 1936 \\pmod {497} = 445.$</li>\n</ul>\n<p>最终计算得到 $ c = 445 $，和直接计算的结果相同。<br>这种方法的时间复杂度是 O(e)。<br><br></p>\n<h4 id=\"位运算方法\"><a href=\"#位运算方法\" class=\"headerlink\" title=\"位运算方法\"></a>位运算方法</h4><p>这个方法大大减少了模幂运算的计算次数，并保持了和上一种方法一致的内存使用，是上面两种方法的结合。</p>\n<p>首先，需要把指数 $e$ 写成二进制，即<br>$ e = \\sum_{i=0}^{n-1} a_i \\cdot 2^i $</p>\n<p>其中， $e$ 可写为 $n$ 位的二进制数，$ a_i $ 可以等于 0 或者 1，$0 ≤ i &lt; n - 1$, 默认 $ a_{n-1} = 1$。<br>于是，$ b^e $可以改写如下：<br>$ b^e = b^{\\left( \\sum_{i=0}^{n-1} a_i \\cdot 2^i \\right)} = \\prod_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a_i}$</p>\n<p>所以，最后 $c$ 可写为：<br>$ c \\equiv \\prod_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a_i}\\ (\\mbox{mod}\\ m)$<br><br></p>\n<p>如果 $e$ 很大的话，$n$ 也会比较大，此时 $b^{2^i}$ 仍然是一个比较耗费资源的幂运算。所以需要进一步优化：<br>$ \\left({b^{2^i}}\\right) ^ {a_i} =<br>\\begin{cases}<br>1 &amp; \\text{ if } a_i = 0 \\\\<br>b^{2^i} = ({b^2})^{2^{i-1}} = ({b^2} \\cdot {b^2}) ^ {2^{i-2}} \\pmod m &amp; \\text{ if } a_i = 1<br>\\end{cases}<br>$</p>\n<p>这样，通过将幂运算转化为底数 $b$ 的模幂运算，在保证了底数不大于 $m$ 的前提下，使得原公式中的 $2^i$ 部分始终等于1，就避免了高次幂运算。<br>例如：(此处我们暂不考虑 $a_i$ )</p>\n<ul>\n<li>$i=0$ 时，$b^{2^i} = b ^ 1 = b \\pmod m = b_0$</li>\n<li>$i=1$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = b ^ 2 \\pmod m = b_0^2 \\pmod m = b_1$</li>\n<li>$i=2$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b ^ 2) ^ 2 = b_1 ^ 2 \\pmod m = b_2$</li>\n<li>$i=3$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b_1^2) ^ 2 = b_2 ^ 2 \\pmod m = b_3$</li>\n</ul>\n<p>这样就可以将 $c$ 改写为：<br>$ c \\equiv \\prod_{i=0}^{n-1} \\left( b_i \\right) ^ {a_i}\\ (\\mbox{mod}\\ m), b_i = b_{i-1}^2 \\pmod m$<br><br></p>\n<p>我们还以上面的例子展示计算过程：<br>$b = 4, e = 13 = 1101_{[2]}, m = 497$</p>\n<ul>\n<li>令$c = 1$，此时 $i = 0, a_i = 1$，所以 $c = (1 \\times 4) \\pmod {497} = 4 , b = (4 \\times 4) \\pmod {497} = 16$</li>\n<li>$i = 1, a_i = 0$，所以 $c$ 不变，$ b = (16 \\times 16) \\pmod {497} = 256$</li>\n<li>$i = 2, a_i = 1$，所以 $c = (4 \\times 256) \\pmod {497} = 30 , b = (256 \\times 256) \\pmod {497} = 429$</li>\n<li>$i = 3, a_i = 1$，所以 $c = (30 \\times 429) \\pmod {497} = 445 , b = (429 \\times 429) \\pmod {497} = 151$，计算结束。<br>最终计算得到 $ c = 445 $，和上面的方法计算结果相同。</li>\n</ul>\n<p>这个方法的时间复杂度由 O(e) 降为 O(log e).</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过这次实践，又挖出了很多坑，发现了很多自己的不足之处。有一些坑还没能填上，留到以后数学水平提高了再回来填吧。另外，通过整理这些素性测试方法，对他们的理解也更深了一些。</p>\n<p>纸上得来终觉浅，须知此事要躬行。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p>1.Matrix67 <a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a><br>2.张洋 <a href=\"http://blog.codinglabs.org/articles/prime-test.html\" target=\"_blank\" rel=\"noopener\">聊聊如何检测素数</a><br>3.bindog <a href=\"http://bindog.github.io/blog/2014/07/19/how-to-generate-big-primes/\" target=\"_blank\" rel=\"noopener\">RSA周边——大素数是怎样生成的？</a><br>4.<a href=\"http://en.wikipedia.org/wiki/Prime_number\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>很早之前读过 Matrix67的<a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a>和 张洋的<a href=\"http://blog.codinglabs.org/articles/prime-test.html\" target=\"_blank\" rel=\"noopener\">聊聊如何检测素数</a>，读了之后获益匪浅，不过一直没有自己动手写一次试试。</p>\n<p>最近和朋友聊天，谈到如何找到距离某个数最近的素数，勾起了我的兴趣。遂重新读了这两篇博客，又查阅了一些其他的资料，自己动手写了一个简单的素数检测程序。下面记录了一些这次实践的经历以及脑洞。<br>","more":"</p>\n<h2 id=\"素数定义\"><a href=\"#素数定义\" class=\"headerlink\" title=\"素数定义\"></a>素数定义</h2><p>既然是素性测试，首先要明确素数的定义：</p>\n<blockquote>\n<p>A natural number (i.e. 1, 2, 3, 4, 5, 6, etc.) is called a prime number (or a prime) if it has exactly two positive divisors, 1 and the number itself.[1]<br>Natural numbers greater than 1 that are not prime are called composite.<br>– <a href=\"http://en.wikipedia.org/wiki/Prime_number\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>\n</blockquote>\n<p>即，一个自然数如果只能被1和它自身整除，那么这个自然数是素数。<br>大于1的自然数不是素数就是合数。</p>\n<p>例如：</p>\n<ul>\n<li>2是素数，因为它只能被1和2整除。</li>\n<li>3是素数。</li>\n<li>4不是素数，因为它可以被2整除。</li>\n<li>5是素数。</li>\n<li>6不是素数，因为它可以被2和3整除。</li>\n</ul>\n<p>因此，还有一个结论，以十进制书写时，大于5的素数都是以1、3、7、9结尾的。可以用于快速判断一个数是否 <strong><em>不是</em></strong> 素数。</p>\n<h2 id=\"1的素性\"><a href=\"#1的素性\" class=\"headerlink\" title=\"1的素性\"></a>1的素性</h2><p>我一直有一个疑问，1到底是素数还是合数。以前一直是因为看到的素数定义里面都指明了大于1的自然数作为前提，也就没有深究。1这个自然数就一直作为素数定义中的特例被我接受了下来。</p>\n<p>这次认真看了下wiki，里面单独提及到了1的素性说明。</p>\n<blockquote>\n<p>Most early Greeks did not even consider 1 to be a number,[4] and so they did not consider it a prime. In the 19th century, however, many mathematicians did consider the number 1 a prime. For example, Derrick Norman Lehmer’s list of primes up to 10,006,721, reprinted as late as 1956,[5] started with 1 as its first prime.[6] Henri Lebesgue is said to be the last professional mathematician to call 1 prime.[7]</p>\n<p>Although a large body of mathematical work would still be valid when calling 1 a prime, the fundamental theorem of arithmetic (mentioned above) would not hold as stated. For example, the number 15 can be factored as 3 · 5 and 1 · 3 · 5; if 1 were admitted as a prime, these two presentations would be considered different factorizations of 15 into prime numbers, so the statement of that theorem would have to be modified. Similarly, the sieve of Eratosthenes would not work correctly if 1 were considered a prime: a modified version of the sieve that considers 1 as prime would eliminate all multiples of 1 (that is, all numbers) and produce as output only the single number 1. Furthermore, the prime numbers have several properties that the number 1 lacks, such as the relationship of the number to its corresponding value of Euler’s totient function or the sum of divisors function.</p>\n</blockquote>\n<p>原来在19世纪有一些数学教认为1是素数。只不过很多数学成果在1是素数的条件下会有问题。例如：</p>\n<ul>\n<li>算术基本定理（<a href=\"http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\" target=\"_blank\" rel=\"noopener\">Fundamental theorem of arithmetic</a>），又称为正整数的唯一分解定理，即：每个大于1的自然数均可写为素数的积，而且这些素因子按大小排列之后，写法仅有一种方式。例如: $6936 = 2^3 \\times 3 \\times 17^2，1200 = 2^4 \\times 3 \\times 5^2$。<br>如果1也是素数的话，15可以写成 $3 \\times 5$，也可以写成 $1 \\times 3 \\times 5$。这两个表达式是不同的，这样算数基本定理就需要修改了。</li>\n<li>埃拉托斯特尼筛法（<a href=\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\" target=\"_blank\" rel=\"noopener\">sieve of Eratosthenes</a>），简称埃氏筛，是一种公元前250年由古希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。<br>它通过从2的倍数开始，迭代地将每一个素数的倍数标记为合数来筛选出某个范围中的素数。<br>例如，如果要找出小于等于n的所有素数，埃拉托斯特尼的方法是：<br>1.创建一个从2到n的连续数列。<br>2.首先，令p等于2，即第一个素数。<br>3.将数列中等于p的倍数的自然数标记为合数，p本身不标记。<br>4.找到未被标记的大于p的第一个数，如果没有这样的数，方法结束。否则，令p等于找到的新数（就是下一个素数），然后重复步骤3。<br><img src=\"http://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif\" alt=\"sieve of Eratosthenes\"><br>当这个方法结束时，所有未被标记的数就是素数。<br>还有一个优化方式，在第4步中，若$p^2$大于n，则可以直接结束而不必寻找大于p的新数。因为小于等于$p^2$的数中的合数都已经标记过了。<br>如果1也是素数的话，在第三步结束后，列表中就只剩下1了。这样这个筛选法也需要修改。</li>\n</ul>\n<p>另外，素数的一些特性1也没有，比如<a href=\"http://en.wikipedia.org/wiki/Euler%27s_totient_function\" target=\"_blank\" rel=\"noopener\">欧拉函数</a>和<a href=\"http://en.wikipedia.org/wiki/Divisor_function\" target=\"_blank\" rel=\"noopener\">除数函数</a>中的一些性质。关于1是否是素数的争论一直没有结束，只不过大多数人都倾向于1不是素数，因为1实在太特殊了，对很多理论都有影响。</p>\n<p>写到这里发现这个坑太深了，欧拉函数和除数函数我没有仔细往下看，因为越往深追溯遇到的不知道的理论越多。看来这个坑不是一天两天能填上的，我决定先补一下数学基础再说T_T。如果对此感兴趣的朋友可以看下<a href=\"https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell1/cald5.html\" target=\"_blank\" rel=\"noopener\">What is the Smallest Prime?</a>和<a href=\"https://cs.uwaterloo.ca/journals/JIS/VOL15/Caldwell2/cald6.html\" target=\"_blank\" rel=\"noopener\">The History of the Primality of One: A Selection of Sources</a>。</p>\n<h2 id=\"素性测试\"><a href=\"#素性测试\" class=\"headerlink\" title=\"素性测试\"></a>素性测试</h2><h3 id=\"试除法（Trial-division）\"><a href=\"#试除法（Trial-division）\" class=\"headerlink\" title=\"试除法（Trial division）\"></a>试除法（Trial division）</h3><p>试除法是判断一个给定整数n是否是素数的最基本的方法。该方法判断所有大于1且小于等于$\\sqrt{n}$的整数是否可以整除n，如果有可以整除的数，则n是合数，否则判断n为素数。因为如果$n = a \\times b, a \\leq b$，则$a \\leq \\sqrt{n}$，所以只要试除到小于等于$\\sqrt{n}$的整数即可。</p>\n<p>有一种实现起来更高效的方式，只要试除2到$\\sqrt{n}$之间的所有素数，即可判断出n是否是素数。因为合数都可以写成更小的素数的乘积（参考上面提到的算术基本定理）。</p>\n<p>虽然试除法逻辑简单，实现比较容易，但是在面对大整数的时候，需要试除的素数数量会极速增长。根据<a href=\"http://en.wikipedia.org/wiki/Prime-counting_function\" target=\"_blank\" rel=\"noopener\">素数计数函数</a>, 小于$\\sqrt{n}$的素数数量约等于 $\\sqrt{n} / \\ln(\\sqrt{n})$，所以试除法需要至少判断这些数是否能整除n。如果 $n = 10^{20}$，则需要试除4亿多个素数。这在现实工程中是难以接受的。<br><br></p>\n<h3 id=\"费马素性测试（Fermat-primality-test）\"><a href=\"#费马素性测试（Fermat-primality-test）\" class=\"headerlink\" title=\"费马素性测试（Fermat_primality_test）\"></a>费马素性测试（<a href=\"http://en.wikipedia.org/wiki/Fermat_primality_test\" target=\"_blank\" rel=\"noopener\">Fermat_primality_test</a>）</h3><p>既然试除法的效率无法接受，那么就需要寻找其他的替代方法。基于费马小定理，人们提出了一种基于随机化算法的检测方法来判断一个数是合数还是 <strong><em>可能是</em></strong> 素数，即费马素性测试。</p>\n<p>首先我们还是先看一下理论基础，<a href=\"http://en.wikipedia.org/wiki/Fermat%27s_little_theorem\" target=\"_blank\" rel=\"noopener\">费马小定理</a>：<br><strong><em>如果p是素数，a是小于p的正整数，那么 $a^{p-1} \\equiv 1 \\pmod p$。</em></strong></p>\n<p>（关于费马小定理， Matrix67写得深入浅出，我应该不会写得比这个更好了，所以这部分直接引用自 Matrix67同学的<a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a>）</p>\n<blockquote>\n<p>这个证明就有点麻烦了。<br>首先我们证明这样一个结论：如果 $p$ 是一个素数的话，那么对任意一个小于 $p$ 的正整数$a$，$a, 2a, 3a, …, (p-1)a$ 除以 $p$ 的余数正好是一个 $1$ 到 $p-1$ 的排列。例如，5是素数，3, 6, 9, 12除以5的余数分别为3, 1, 4, 2，正好就是1到4这四个数。</p>\n<p>反证法，假如结论不成立的话，那么就是说有两个小于 $p$ 的正整数 $m$ 和 $n$ 使得 $na$ 和 $ma$ 除以 $p$ 的余数相同。不妨假设 $n &gt; m$，则 $p$ 可以整除 $a(n-m)$。但 $p$ 是素数，那么 $a$ 和 $n-m$ 中至少有一个含有因子 $p$。这显然是不可能的，因为 $a$ 和 $n-m$ 都比 $p$ 小。</p>\n<p>用同余式表述，我们证明了：<br>$(p-1)! \\equiv a \\times 2a \\times 3a \\times … \\times (p-1)a \\pmod p$<br>也即：<br>$(p-1)! \\equiv (p-1)! \\times a^{p-1} \\pmod p$<br>两边同时除以 $(p-1)!$，就得到了我们的最终结论：<br>$1 ≡ a^{p-1} \\pmod p$</p>\n</blockquote>\n<p>费马素性测试，即选取小于p的正整数a，测试费马小定理是否成立，如果不成立，则p一定不是素数，如果成立，则p可能是素数。将上述过程重复n次，每次随机选取整数a进行测试。一般情况下，选取的a越多，测试结果越准确。</p>\n<p>而有一些合数p，对于所有大于1且小于p的正整数都符合费马小定理，这样的数p称为卡迈克尔数（<a href=\"http://en.wikipedia.org/wiki/Carmichael_number\" target=\"_blank\" rel=\"noopener\">Carmichael number</a>）。保罗·艾狄胥猜想有无限个卡迈克尔数，1994年 William Alford 、 Andrew Granville 及 Carl Pomerance 证明了这个命题。最小的卡迈克尔数是561。因为这些数的存在，使得费马素性检验变得不可靠。<br><br></p>\n<h3 id=\"米勒-拉宾素性测试（Miller–Rabin-primality-test）\"><a href=\"#米勒-拉宾素性测试（Miller–Rabin-primality-test）\" class=\"headerlink\" title=\"米勒-拉宾素性测试（Miller–Rabin_primality_test）\"></a>米勒-拉宾素性测试（<a href=\"http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\" target=\"_blank\" rel=\"noopener\">Miller–Rabin_primality_test</a>）</h3><p>米勒-拉宾素性测试也是一个基于随机化算法的素性测试方法，判断了一个数是合数还是 <strong><em>可能是</em></strong> 素数。和费马素性测试相似，米勒-拉宾素性测试也是通过判断一组对素数成立的等式是否对我们想测试的数也成立来实现素性测试的。</p>\n<p>这个方法的原始版本来自卡内基梅隆大学的计算机系教授Gary Lee Miller，他首先提出了基于广义黎曼猜想的确定性算法，由于广义黎曼猜想并没有被证明，其后由以色列耶路撒冷希伯来大学的Michael O. Rabin教授作出修改，提出了不依赖于该假设的随机化算法。<br><br></p>\n<h4 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h4><p>米勒-拉宾素性测试基于下面的定理：<br>如果对模 $n$ 存在 $1$ 的非平凡平方根，则 $n$ 是合数。即对方程 $x^2 \\equiv 1 \\pmod n$，方程的解除了 $1$ 和 $n-1$ 两个平凡根之外，还有其它的根，那么 $n$ 肯定是合数。</p>\n<p>假设 $p$是大于2的素数， $x$ 是摸 $p$ 等于1的平方根，则：<br>$x^2 \\equiv 1 \\pmod p$ ，即 $ (x - 1)( x + 1) \\equiv 0 \\pmod{p}$<br>也就是说素数 $p$ 整除 $(x - 1)( x + 1)$，因为 $p$ 是素数，它只能被 1 和 $p$ 整除，所以一定有 $x - 1 \\equiv 0 \\pmod p$ 或 $x - 1 \\equiv 0 \\pmod p$，所以 $x$ 模 $p$ 等于 1 或者 $p - 1$。<br><br></p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>假设 $n$ 是素数，且 $n &gt; 2$，则 $n - 1$是偶数，我们可以将其写为 $2^s \\times d$ 的形式，其中 $s$ 和 $d$ 都是正整数，$d$ 是奇数。</p>\n<p>结合费马小定理，$a^{p-1} \\equiv 1 \\pmod p$。如果 $p$ 是素数，则 $p - 1$是偶数，我们不断计算 $a^{p-1}$的平方根，那么最后一定会得到 1 或者 $p - 1$。</p>\n<p>根据以上的理论，米勒-拉宾素性测试的等效表达为：<br>1.把 $n-1$ 表示成 $d \\times 2^s$<br>2.计算 $a^{d \\times 2^r} \\pmod n ( 0 \\leq r \\leq s - 1 )$，（$r = s$ 时，此算式等效于费马小定理）<br>3.若结果是 1 和 $n-1$ 以外的值，测试结束，$n$是合数<br>4.若结果是 $n-1$，那么测试结束， $n$可能是素数，可以换一个底数 $a$ 进行下一轮计算<br>5.若结果是 1，那么仍然符合费马小定理，继续计算开方的值。即令 $r = r - 1$，$r \\neq 0$ 的情况下回到第2步<br>6.直到计算到 $r = 0$，即 $a^d \\pmod n$<br>7.若结果是 1 或 $n-1$，那么$n$可能是素数，可以换一个底数 $a$ 进行下一轮计算。否则测试结束，$n$是合数。</p>\n<p>所以如果 $n$ 是一个素数，那么或者 $a^d \\equiv 1 \\pmod n$，或者存在某个 $r$ 使得 $a^{d \\times 2^r} \\equiv n-1 \\pmod n ( 0 \\leq r \\leq s-1 )$。<br><br></p>\n<p>以上面提到的卡迈克尔数 561为例，我们来看一下米勒-拉宾素性测试的实际应用：<br>1.560可以表示成 $35 \\times 2^4$, 我们知道 $2^{560} = 1 \\pmod {561}$。<br>2.计算得到 $2^{35 \\times 2 ^ 3} = 1 \\pmod {561}$<br>3.结果仍然符合费马小定理，继续计算，得到 $2^{35 \\times 2 ^ 2} = 67 \\pmod {561}$<br>4.测试结束，561是合数</p>\n<p>下面引用 Matrix67同学的<a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a>补充说明：</p>\n<blockquote>\n<p>Miller-Rabin素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。</p>\n<p>对于大数的素性判断，目前Miller-Rabin算法应用最广泛。一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果被测数小于4 759 123 141，那么只需要测试三个底数2, 7和61就足够了。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11, 13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用2, 3, 7, 61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255 981。这样的一些结论使得Miller-Rabin算法在OI中非常实用。</p>\n<p>通常认为，Miller-Rabin素性测试的正确率可以令人接受，随机选取k个底数进行测试算法的失误率大概为 $4^{-k}$。</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"AKS素数测试\"><a href=\"#AKS素数测试\" class=\"headerlink\" title=\"AKS素数测试\"></a>AKS素数测试</h3><blockquote>\n<p>AKS素数测试（又被称为Agrawal–Kayal–Saxena素数测试和Cyclotomic AKS test）是一个决定型素数测试算法。由三个来自印度坎普尔理工学院的计算机科学家，Manindra Agrawal、Neeraj Kayal 和 Nitin Saxena 提出，在2002年8月6日发表于一篇题为 PRIMES is in P 的论文。作者们因此获得了许多奖项，包含了2006年的哥德尔奖和2006年的 Fulkerson Prize。这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。</p>\n<p>AKS最关键的重要性在于它是第一个被发表的<strong>一般的</strong>、<strong>多项式的</strong>、<strong>确定性的</strong>和<strong>无仰赖的</strong>素数判定算法。先前的算法至多达到了其中三点，但从未达到全部四个。</p>\n<p>AKS算法可以被用于检测任何一般的给定数字是否为素数。很多已知的高速判定算法只适用于满足特定条件的素数。例如，卢卡斯-莱默检验法仅对梅森素数适用，而Pépin测试仅对费马数适用。<br>算法的最长运行时间可以被表为一个目标数字长度的多项式。ECPP和APR能够判断一个给定数字是否为素数，但无法对所有输入给出多项式时间范围。<br>算法可以确定性地判断一个给定数字是否为素数。随机测试算法，例如米勒-拉宾检验和Baillie–PSW，可以在多项式时间内对给定数字进行校验，但只能给出概率性的结果。<br>AKS算法并未“仰赖”任何未证明猜想。一个反例是确定性米勒检验：该算法可以在多项式时间内对所有输入给出确定性结果，但其正确性却基于尚未被证明的广义黎曼猜想。<br>– <a href=\"http://zh.wikipedia.org/wiki/AKS%E8%B3%AA%E6%95%B8%E6%B8%AC%E8%A9%A6\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>\n</blockquote>\n<p>此处留坑，有生之年。。。<br><a href=\"http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf\" target=\"_blank\" rel=\"noopener\">PRIMES is in P</a><br><br></p>\n<h3 id=\"模幂运算（Modular-exponentiation）\"><a href=\"#模幂运算（Modular-exponentiation）\" class=\"headerlink\" title=\"模幂运算（Modular exponentiation）\"></a>模幂运算（<a href=\"http://en.wikipedia.org/wiki/Modular_exponentiation\" target=\"_blank\" rel=\"noopener\">Modular exponentiation</a>）</h3><p>上面提到的费马素性测试和米勒-拉宾素性测试都涉及到了大量的模幂运算。<br>模幂运算计算了正整数 $b$ 的 $e$ 次方除以正整数 $m$ 的余数。用符号表示为，给定底数 $b$, 指数 $e$, 和模数 $m$, 模幂运算就是 $ c \\equiv b^e \\pmod{m}$。<br><br></p>\n<h4 id=\"直接计算\"><a href=\"#直接计算\" class=\"headerlink\" title=\"直接计算\"></a>直接计算</h4><p>最基础的办法就是直接计算 $ b^e $，然后对 $m$ 取余。假设 $b = 4, e = 13, m = 497$，则 $ c \\equiv 4^{13} \\pmod{497} $。计算得到 $ 4^{13} $ 等于67,108,864，对497取模计算出 $c$, 为445。</p>\n<p>这个例子中 $b$ 和 $e$ 都是一位数，计算得到的 $ b^e $ 却是8位数。如果判断一个大数是否是素数的时候，$b$ 和 $e$ 都会很大，直接计算的计算效率将变得无法接受，所以需要更高效的计算方法。<br><br></p>\n<h4 id=\"内存优化计算方法\"><a href=\"#内存优化计算方法\" class=\"headerlink\" title=\"内存优化计算方法\"></a>内存优化计算方法</h4><p>这个方法相比于直接计算，计算次数增多了，但是因为每次计算大大节省了内存的使用，所以总的计算速度还是比直接计算更快。</p>\n<p>这个方法的理论基础是，<br>$ c \\equiv (a \\cdot b) \\pmod{m} $ 等价于 $ c \\equiv (a \\cdot (b\\ (\\mbox{mod}\\ m))) \\pmod{m} $<br>这样，不直接计算 $ b^e $，而是计算 $ \\prod_{i=0}^{e} b $，这样就可以根据上面的等式将每次乘以 $b$ 以后的结果取余，从而使计算过程中的中间变量一直小于模数 $m$，确保了内存使用效率。</p>\n<p>具体的步骤如下：<br>1.令结果 $c = 1, e′ = 0.$<br>2.令 $ e′ = e′ + 1 $<br>3.计算 $ c \\equiv (b \\cdot c) \\pmod{m} $<br>4.如果 $ e′ &lt; e $，回到第二步；否则计算结束，此时 $ c \\equiv b^e \\pmod{m} $。</p>\n<p>我们还用上面的例子来展示计算的具体过程：<br>$b = 4, e = 13, m = 497$</p>\n<ul>\n<li>$ e′ = 1. c = (1 \\times 4) \\pmod {497} = 4 \\pmod {497} = 4.$</li>\n<li>$ e′ = 2. c = (4 \\times 4) \\pmod {497} = 16 \\pmod {497} = 16.$</li>\n<li>$ e′ = 3. c = (16 \\times 4) \\pmod {497} = 64 \\pmod {497} = 64.$</li>\n<li>$ e′ = 4. c = (64 \\times 4) \\pmod {497} = 256 \\pmod {497} = 256.$</li>\n<li>$ e′ = 5. c = (256 \\times 4) \\pmod {497} = 1024 \\pmod {497} = 30.$</li>\n<li>$ e′ = 6. c = (30 \\times 4) \\pmod {497} = 120 \\pmod {497} = 120.$</li>\n<li>$ e′ = 7. c = (120 \\times 4) \\pmod {497} = 480 \\pmod {497} = 480.$</li>\n<li>$ e′ = 8. c = (480 \\times 4) \\pmod {497} = 1920 \\pmod {497} = 429.$</li>\n<li>$ e′ = 9. c = (429 \\times 4) \\pmod {497} = 1716 \\pmod {497} = 225.$</li>\n<li>$ e′ = 10. c = (225 \\times 4) \\pmod {497} = 900 \\pmod {497} = 403.$</li>\n<li>$ e′ = 11. c = (403 \\times 4) \\pmod {497} = 1612 \\pmod {497} = 121.$</li>\n<li>$ e′ = 12. c = (121 \\times 4) \\pmod {497} = 484 \\pmod {497} = 484.$</li>\n<li>$ e′ = 13. c = (484 \\times 4) \\pmod {497} = 1936 \\pmod {497} = 445.$</li>\n</ul>\n<p>最终计算得到 $ c = 445 $，和直接计算的结果相同。<br>这种方法的时间复杂度是 O(e)。<br><br></p>\n<h4 id=\"位运算方法\"><a href=\"#位运算方法\" class=\"headerlink\" title=\"位运算方法\"></a>位运算方法</h4><p>这个方法大大减少了模幂运算的计算次数，并保持了和上一种方法一致的内存使用，是上面两种方法的结合。</p>\n<p>首先，需要把指数 $e$ 写成二进制，即<br>$ e = \\sum_{i=0}^{n-1} a_i \\cdot 2^i $</p>\n<p>其中， $e$ 可写为 $n$ 位的二进制数，$ a_i $ 可以等于 0 或者 1，$0 ≤ i &lt; n - 1$, 默认 $ a_{n-1} = 1$。<br>于是，$ b^e $可以改写如下：<br>$ b^e = b^{\\left( \\sum_{i=0}^{n-1} a_i \\cdot 2^i \\right)} = \\prod_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a_i}$</p>\n<p>所以，最后 $c$ 可写为：<br>$ c \\equiv \\prod_{i=0}^{n-1} \\left( b^{2^i} \\right) ^ {a_i}\\ (\\mbox{mod}\\ m)$<br><br></p>\n<p>如果 $e$ 很大的话，$n$ 也会比较大，此时 $b^{2^i}$ 仍然是一个比较耗费资源的幂运算。所以需要进一步优化：<br>$ \\left({b^{2^i}}\\right) ^ {a_i} =<br>\\begin{cases}<br>1 &amp; \\text{ if } a_i = 0 \\\\<br>b^{2^i} = ({b^2})^{2^{i-1}} = ({b^2} \\cdot {b^2}) ^ {2^{i-2}} \\pmod m &amp; \\text{ if } a_i = 1<br>\\end{cases}<br>$</p>\n<p>这样，通过将幂运算转化为底数 $b$ 的模幂运算，在保证了底数不大于 $m$ 的前提下，使得原公式中的 $2^i$ 部分始终等于1，就避免了高次幂运算。<br>例如：(此处我们暂不考虑 $a_i$ )</p>\n<ul>\n<li>$i=0$ 时，$b^{2^i} = b ^ 1 = b \\pmod m = b_0$</li>\n<li>$i=1$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = b ^ 2 \\pmod m = b_0^2 \\pmod m = b_1$</li>\n<li>$i=2$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b ^ 2) ^ 2 = b_1 ^ 2 \\pmod m = b_2$</li>\n<li>$i=3$ 时，$b^{2^i} = (b ^ 2)^{2^{i-1}} = (b_1^2) ^ 2 = b_2 ^ 2 \\pmod m = b_3$</li>\n</ul>\n<p>这样就可以将 $c$ 改写为：<br>$ c \\equiv \\prod_{i=0}^{n-1} \\left( b_i \\right) ^ {a_i}\\ (\\mbox{mod}\\ m), b_i = b_{i-1}^2 \\pmod m$<br><br></p>\n<p>我们还以上面的例子展示计算过程：<br>$b = 4, e = 13 = 1101_{[2]}, m = 497$</p>\n<ul>\n<li>令$c = 1$，此时 $i = 0, a_i = 1$，所以 $c = (1 \\times 4) \\pmod {497} = 4 , b = (4 \\times 4) \\pmod {497} = 16$</li>\n<li>$i = 1, a_i = 0$，所以 $c$ 不变，$ b = (16 \\times 16) \\pmod {497} = 256$</li>\n<li>$i = 2, a_i = 1$，所以 $c = (4 \\times 256) \\pmod {497} = 30 , b = (256 \\times 256) \\pmod {497} = 429$</li>\n<li>$i = 3, a_i = 1$，所以 $c = (30 \\times 429) \\pmod {497} = 445 , b = (429 \\times 429) \\pmod {497} = 151$，计算结束。<br>最终计算得到 $ c = 445 $，和上面的方法计算结果相同。</li>\n</ul>\n<p>这个方法的时间复杂度由 O(e) 降为 O(log e).</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过这次实践，又挖出了很多坑，发现了很多自己的不足之处。有一些坑还没能填上，留到以后数学水平提高了再回来填吧。另外，通过整理这些素性测试方法，对他们的理解也更深了一些。</p>\n<p>纸上得来终觉浅，须知此事要躬行。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p>1.Matrix67 <a href=\"http://www.matrix67.com/blog/archives/234\" target=\"_blank\" rel=\"noopener\">素数与素性测试</a><br>2.张洋 <a href=\"http://blog.codinglabs.org/articles/prime-test.html\" target=\"_blank\" rel=\"noopener\">聊聊如何检测素数</a><br>3.bindog <a href=\"http://bindog.github.io/blog/2014/07/19/how-to-generate-big-primes/\" target=\"_blank\" rel=\"noopener\">RSA周边——大素数是怎样生成的？</a><br>4.<a href=\"http://en.wikipedia.org/wiki/Prime_number\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>"},{"title":"A/B Testing中的统计学简述","date":"2016-10-08T08:16:53.000Z","mathjax":true,"_content":"\n## 引子\n最近做了一个 A/B 测试相关的项目，填补了这部分知识的空白。以前只知道 A/B 测试的大概机制，对原理并没有什么了解，通过这个项目，对 A/B 测试的统计学原理有了一点了解，遂决定记录成文，顺便更新下大半年没动过的博客……\n<!-- more -->\n\n\n## A/B testing\nA/B 测试大家应该都有所了解，所以就简单引用一下定义：\n\n> In marketing and business intelligence, A/B testing is a term for a randomized experiment with two variants, A and B, which are the control and variation in the controlled experiment.[1]\n> A/B testing is a form of statistical hypothesis testing with two variants leading to the technical term, two-sample hypothesis testing, used in the field of statistics.\n> -- [wikipedia](https://en.wikipedia.org/wiki/A/B_testing)\n\n即，A/B 测试是一种两样本的随机对照试验，在统计学上是一种两样本的假设检验。在计算机方面，A/B 测试通常是为了通过评估对照组和实验组之间的差异，决定产品迭代的方向。A/B 测试的概念也被扩展到多样本的实验方式上。\n\n我之前对 A/B 测试的理解仅限于大概流程，实验设计->流量划分->实验进行->数据采集->数据分析->结论产出，但是一直没想过数据分析是如何进行的，这次主要填补的就是这部分的内容。\n\n\n## 总体与样本\n总体即研究对象的某项数量指标的全体。总体中个每个元素称为个体。在A/B测试中，我们产品的所有用户的某项指标构成总体，例如用户的付款转化率等。\n\n实际应用中，通常总体的量级可能会非常大，不适于直接在总体上做实验并分析数据；或者不希望过多的用户参与到 A/B 测试中，避免对大部分用户造成打扰，所以一般做 A/B 测试都是使用小流量进行的，即流量划分这一步会决定哪部分流量进行实验，根据对这一部分流量的实验数据进行分析，将结论推广到全部流量。流量划分即通过抽样来从总体中划定实验范围的过程。\n\n抽样，是指按照一定规则从总体中抽取若干个体进行观察试验，以推断总体的分布及特征等信息的方式。最常用的抽样方法是随机抽样，即从总体中随机抽取n个个体作为样本，使得每一个个体都有相同的概率被抽中。常用于个体间差异较小，且互相独立的情况。此外使用较多的还有分层抽样，即将个体按照某种特征或规则划分为不同的层，然后从不同的层中独立、随机地抽取样本，从而保证样本的结构和总体的结构相近。\n\n抽样最重要的一点就是要尽量保证样本具有代表性，避免样本误差对实验结论的影响，否则根据有偏差的样本得出的数据和结论可能会带来误导。\n\n\n## 统计量及其分布\n在选择完抽样方法后，还需要选择适当的统计指标来评估对照组和实验组的表现。通常，我们选择的都是一维连续随机变量，例如pv、uv、点击率等，随机变量的分布函数描述了随机变量的概率分布的情况。我们实际常用的分布主要是正态分布和t分布。\n\n### 正态分布\n正态分布是一种应用非常广泛的概率分布，正态分布的密度曲线是一条关于 $x = \\mu$ 对称的钟形曲线，方差 $\\sigma ^{2}$ 决定了曲线中峰的陡峭程度。其中，$\\mu$ 是正态分布的数学期望，$\\sigma ^{2}$ 是正态分布的方差，正态分布记为 $X \\sim N(\\mu,\\sigma ^ {2})$。$\\mu = 0$ 且 $\\sigma ^{2} = 1$ 时的正态分布称为标准正态分布，记为 $X \\sim N(0,1)$。\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Normal_Distribution_PDF.svg/350px-Normal_Distribution_PDF.svg.png \"normal distribution\")\n\n根据中心极限定理，一个变量如果是由大量微小的、独立的随机因素叠加的结果，那么当样本量足够大的时候，这个变量近似服从正态分布。\n\n![](https://upload.wikimedia.org/wikipedia/commons/0/06/De_moivre-laplace.gif \"central limit theorem\")\n\n### t分布\n通常情况下，我们无法知道正态分布的总体的方差，只能用样本方差近似的代替总体方差进行计算，当样本量比较大的时候，我们可以取到比较好的近似值，但是当样本量不足的时候，误差较大，所以需要应用t分布来计算。\n\nt分布曲线和标准正态分布曲线非常接近，t分布的最大值比标准正态分布略小，尾部的概率比标准正态分布大一些。样本量越大，t分布的越接近标准正态分布，当样本量充分大的时候，t分布可以近似看作是标准正态分布。\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/TStudent.png/325px-TStudent.png \"student distribution\")\n\n\n## 参数估计\n根据采集到的样本数据，可以计算样本的均值、方差、标准差等分布特征。但是根据对样本数据的计算得到的特征值存在一定的偏差，并不能准确反应总体分布特征，因此需要根据样本特征值对总体进行估计。\n\n参数估计的形式有两种：\n\n- 点估计：根据样本估计参数的近似值\n- 区间估计：根据样本构造一个参数的取值范围，使得待估参数落在这个范围中的可信程度较高\n\n### 置信区间\n置信区间是区间估计的一种，是指在样本量不变的前提下，我们重复抽样，用同样的方法构造置信区间，有95%的置信区间会包含真实值，所以当我们只构造一次置信区间的时候，我们也认为这个区间是可信的，是包含了总体参数真实值的。这个概率也被称为置信度。置信度越高，结果的可靠性也就越高，但是置信度的提高往往伴随着区间的扩大。\n\n![](http://zy.swust.net.cn/14/1/dzclyyb/kcxx/z2/image/5_clip_image011.jpg \"confidence interval\")\n\n\n## 假设检验\n假设检验通常用来根据样本数据推断总体的某些性质，先对总体的参数提出某种假设，然后利用样本数据判断假设是否成立。在A/B测试中，通常我们希望推断的性质是优化指标的总体期望，即实验组对应的总体的某个优化指标的均值是否优于对照组的相应总体指标。\n\n假设检验运用了反证法，其一般流程是\n\n- 提出原假设和备择假设，原假设的内容一般是希望被证明为错误的假设或者需要着重考虑的假设。与原假设相对的是备择假设，即希望被证明是正确的另一种可能\n- 选择检验方法和检验统计量\n- 在原假设下推导统计量的分布，比如正态分布或t分布等\n- 选择显著性水平\n- 计算拒绝域，如果统计量未落在拒绝域，则接受原假设，如果统计量落在拒绝域，则接受备择假设。\n\n### 显著性检验\n拒绝域即拒绝原假设的区域，其概率即为显著性水平。常用显著性水平如5%、1%等，即在原假设成立的条件下，样本值落在拒绝域的概率很低，是一个小概率事件，按照实际推断原理，小概率事件在一次抽样中一般是不会发生的，因为我们有理由认为样本值落在拒绝域的时候，原假设是不成立的。\n\n不过实际推断原理只是说在一次抽样中，小概率事件可以认为是不会发生的，而不能肯定绝对不发生。因此，有一定概率在原假设成立的情况下，统计量落入拒绝域，导致我们拒绝原假设。这种情况实际上是一种错误，在假设检验中，称这种错误为第一类错误，也就是“弃真”错误，发生的概率记作 $\\alpha$，即显著性水平。另一种错误是原假设不成立，但是接受了原假设，称为第二类错误，即“受伪”错误，它发生的概率记作 $\\beta$。\n\n由于抽样的随机性，我们不可能完全排除这两类错误的发生，因此只能把这两类错误控制在一定的范围之内。当样本容量 n 确定之后，犯两类错误的概率不可能同时降低，通常我们会用一个较小的显著性水平 $\\alpha$ 来控制第一类错误的发生，因为原假设一般是结合问题特点提出的，需要着重考虑的假设，不应该轻易拒绝，所以第一类错误的概率要控制得较小。这种只控制犯第一类错误的概率，而不考虑犯第二类错误的概率的检验，称为显著性检验。\n\n### 双侧检验，单侧检验\n实际应用中，我们经常会区分双侧检验和单侧检验，这是根据备择假设的定义选定的，即：\n\n- 双侧检验：如果备择假设没有特定的方向性，这样的检验称为双侧检验，对于正态分布而言，拒绝域分布在曲线的两端\n- 单侧检验：如果备择假设具有特定的方向性，这样的检验称为单侧检验，对于正态分布而言，拒绝域在曲线的一侧\n![](http://course.cau-edu.net.cn/course/Z0193/ch06/se01/content/htmlimages/index_3.gif \"hypothesis testing\")\n\n### 检验方法\n上述流程中，有一步选择检验方法，在A/B测试中，我们通常计算的统计量都服从正态分布或t分布，这里以此为例进行展开。\n\n比较常用的检验方法包括Z检验和t检验，选择取决于总体方差和样本量。\n\n- 总体方差已知：Z检验\n- 总体方差未知，样本量大于30：t检验，或者Z检验，用样本方差近似代替总体方差\n- 总体方差未知，样本量小于30：t检验\n\n\n#### Z检验\nZ检验适用于大样本的两平均数之间差异显著性检验的方法，它是通过计算两个平均数之间差的Z分数来与规定的理论Z值相比较，从而判定两平均数的差异是否显著的一种差异显著性检验方法。\n\nZ统计量的计算公式为：\n$$Z = \\frac{X - \\mu}{\\sigma}$$\n\nZ统计量用来度量观测到的统计量和假设总体参数之间的差值，以标准差为单位，可以看做使用总体的期望和标准差对随机变量 X 进行标准化的结果。当随机变量 X 无法确定时，则为样本的平均数，Z 统计量的计算公式修改为：\n$$Z = \\frac{\\bar X - \\mu}{\\frac{\\sigma}{\\sqrt n}}$$\n\n其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，$\\sigma$ 是总体标准差，n 是样本数量，$\\frac{\\sigma}{\\sqrt n}$ 是样本标准误差。样本的标准误差用来估计来自于同一总体的多个样本所得到的样本均值之间的差异性。使用均值的标准误差可以确定样本均值的评估精确度。标准误差的值越小，表示对总体的评估越精确。\n\n\n#### t检验\nt检验是用t分布理论来推断两个平均数差异的显著性检验。常用于根据小样本来估计呈正态分布且方差未知的总体的均值，如果方差已知，应该用正态分布来估计总体均值。t检验是对Z检验的改进，因为Z检验的前提是总体的标准差已知，虽然在样本数量大(通常是30)的时候，可以用Z检验求得近似值，但样本量小的时候，误差较大，因此要改用t检验以求准确。\n\nt统计量的计算公式为：\n$$t = \\frac{\\bar X - \\mu}{\\frac{S}{\\sqrt n}}$$\n\n其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，n 是样本数量，S 是样本标准差，计算公式为 $S=\\sqrt {\\frac{\\sum_{i=0}^n (x_i - \\bar x)^2}{n-1}}$，$\\frac{S}{\\sqrt n}$ 是样本标准误差。\n\n这个时候，我们说统计量满足自由度为(n-1)的t分布。其中自由度是指当以样本的统计量来估计总体的参数时，样本中能独立或能自由变化的数据的个数。在使用样本均值近似替代总体期望计算样本方差的过程中，因为样本均值已经确定了，所以样本方差的自由度是 n-1 。\n\nt统计量以标准误差的单位度量观测的样本统计量与其假设的总体参数之差，t检验将此观测的t统计量与自由度为 n-1 的 t 分布中的临界值进行比较，以确定估计和假设的总体参数值之差是否在统计意义上显著。\n\n常用t检验的情况：\n\n- 单样本检验：检验一个正态分布的总体的均值是否满足原假设\n- 双样本检验：检验两个正态分布的总体均值之差是否满足原假设\n- 配对t检验：检验一个正态分布的两组配对样本的总体均值之差或一组样本的前后两次测量的总体均值之差是否满足原假设\n\n我们实际应用的时候，对比实验组和对照组的统计量差异的时候，符合配对t检验的情况，此时，t统计量的公式为\n$$t = \\frac{\\bar d - \\mu}{\\frac{S_d}{\\sqrt n}}$$\n\n其中，n是样本数量，n-1是自由度，$d_i = x_{1i} - x_{2i}$ 是样本元素，$\\bar d = \\frac{\\sum_{i=0}^n d_i}{n}$ 是样本均值，$S_d = \\sqrt{\\frac{\\sum_{i=0}^n (d_i - \\bar d)^2}{n-1}}$ 是样本标准差。\n\n\n### p-value\n在假设检验的过程中，我们经常听到 p 值这个名词，它的含义是：在原假设成立的条件下，我们观察到计算所得样本数据特征的概率，通常将 p 值和显著性水平进行比较以判断是否拒绝原假设。如果 p 值小于显著性水平，说明我们在原假设的条件下几乎不会得到这样的数据，所以我们应该拒绝原假设。\n\n![](http://7xiium.com1.z0.glb.clouddn.com/p-value.png)\n\n\n## 示例\n下面我们通过一个例子梳理一下。假设我们设计了一个实验，通过随机抽样选出了样本，经过一段时间的实验，收集到了一批样本的数据。为了比较实验组和对照组的差异，我们首先提出原假设和备择假设：\n\n- 原假设 H0：实验组与对照组的统计指标没有差异，即 $\\mu_d = 0$\n- 备择假设 H1：实验组与对照组的统计指标有明显差异，即 $\\mu_d \\neq 0$\n\n然后我们定义实验组和对照组之间统计量的差异为 $d_i= x_{1i} - x_{2i}$, 现在假设我们的统计量服从正态分布，这样 $d_i$ 也服从正态分布，分布的方差未知。接下来我们根据样本数量选择使用Z检验或者t检验，假设我们样本量不足，使用t检验。这时我们可以先计算得到样本数据的均值 $\\bar d$，然后根据样本均值计算样本方差，公式为：\n$$S^2 = \\frac{\\sum_{i=0}^n (d_i - \\bar d)^2}{n-1}$$\n\n根据样本均值和标准差可以计算t统计量，计算公式为：\n$$t = \\frac{\\bar d - \\mu_0}{\\frac{S_d}{\\sqrt n}}$$\n\n此时，t统计量服从自由度为 n-1 的t分布。因为我们的原假设是 $\\mu_d = 0$，所以此处取 $\\mu_0 = 0$。\n\n然后我们选择显著性水平为5%，即 $\\alpha = 0.05$，根据自由度和显著性水平，我们可以得到，原假设的拒绝域为\n$$ \\lvert t \\rvert = \\left| \\frac{\\bar d}{\\frac{S_d}{\\sqrt n}} \\right| \\gt t_{\\frac{\\alpha}{2}} (n-1) $$\n\n我们查表或者通过t分布的累积概率密度函数计算得到 $t_{\\frac{\\alpha}{2}} (n-1)$ 的值，或者将不等式展开，转化为对 $\\bar d$ 限定的形式：\n$$ \\lvert{\\bar d}\\rvert \\gt \\frac{S_d}{\\sqrt n} \\cdot t_{\\frac{\\alpha}{2}} (n-1)$$\n\n然后我们可以判断是否拒绝原假设。此外，我们可以计算 $\\mu_d$ 的置信区间。假设我们需要计算置信度为95%的置信区间，则 $\\alpha = 0.05$，相应的置信区间为：\n$$ \\bar d \\pm \\frac{S_d}{\\sqrt n} \\cdot t_{\\frac{\\alpha}{2}} (n-1)$$\n\n在实际应用的时候，往往还会需要pm提供一个差异的心里预期值，比如 1% 或 5% 等，通过检查两组数据差异的置信区间是否在预期值之上，可以进一步评估实验的效果。\n\n## 结语\n以上就是我这一段时间接触到的A/B测试中用到的主要统计学原理，主要是针对单个统计量的情况，而实际的实验中我们往往需要通过评估多个统计量的变化来对比两组样本的效果差异。如何根据多个统计指标设计评估模型，是我们面对的下一个问题。\n\n## References\n[A/B Testing](https://en.wikipedia.org/wiki/A/B_testing)\n\n[抽样](https://zh.wikipedia.org/wiki/%E6%8A%BD%E6%A8%A3)\n\n[正态分布](https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83)\n\n[t分布](https://zh.wikipedia.org/wiki/%E5%AD%A6%E7%94%9Ft-%E5%88%86%E5%B8%83)\n\n[吆喝科技帮助手册](http://doc.appadhoc.com/dataDecision/interpret.html)\n\n[什么是t值——Minitab](http://support.minitab.com/zh-cn/minitab/17/topic-library/basic-statistics-and-graphs/hypothesis-tests/tests-of-means/what-is-a-t-value/)\n\n[Hypothesis Testing -- uncfsu](http://faculty.uncfsu.edu/dwallace/shyp.html)\n","source":"_posts/simple-stats-in-abtesting.md","raw":"title: \"A/B Testing中的统计学简述\"\ndate: 2016-10-08 16:16:53\ncategories:\n- 数学\ntags:\n- 统计学\n- 数学\n- A/B testing\nmathjax: true\n---\n\n## 引子\n最近做了一个 A/B 测试相关的项目，填补了这部分知识的空白。以前只知道 A/B 测试的大概机制，对原理并没有什么了解，通过这个项目，对 A/B 测试的统计学原理有了一点了解，遂决定记录成文，顺便更新下大半年没动过的博客……\n<!-- more -->\n\n\n## A/B testing\nA/B 测试大家应该都有所了解，所以就简单引用一下定义：\n\n> In marketing and business intelligence, A/B testing is a term for a randomized experiment with two variants, A and B, which are the control and variation in the controlled experiment.[1]\n> A/B testing is a form of statistical hypothesis testing with two variants leading to the technical term, two-sample hypothesis testing, used in the field of statistics.\n> -- [wikipedia](https://en.wikipedia.org/wiki/A/B_testing)\n\n即，A/B 测试是一种两样本的随机对照试验，在统计学上是一种两样本的假设检验。在计算机方面，A/B 测试通常是为了通过评估对照组和实验组之间的差异，决定产品迭代的方向。A/B 测试的概念也被扩展到多样本的实验方式上。\n\n我之前对 A/B 测试的理解仅限于大概流程，实验设计->流量划分->实验进行->数据采集->数据分析->结论产出，但是一直没想过数据分析是如何进行的，这次主要填补的就是这部分的内容。\n\n\n## 总体与样本\n总体即研究对象的某项数量指标的全体。总体中个每个元素称为个体。在A/B测试中，我们产品的所有用户的某项指标构成总体，例如用户的付款转化率等。\n\n实际应用中，通常总体的量级可能会非常大，不适于直接在总体上做实验并分析数据；或者不希望过多的用户参与到 A/B 测试中，避免对大部分用户造成打扰，所以一般做 A/B 测试都是使用小流量进行的，即流量划分这一步会决定哪部分流量进行实验，根据对这一部分流量的实验数据进行分析，将结论推广到全部流量。流量划分即通过抽样来从总体中划定实验范围的过程。\n\n抽样，是指按照一定规则从总体中抽取若干个体进行观察试验，以推断总体的分布及特征等信息的方式。最常用的抽样方法是随机抽样，即从总体中随机抽取n个个体作为样本，使得每一个个体都有相同的概率被抽中。常用于个体间差异较小，且互相独立的情况。此外使用较多的还有分层抽样，即将个体按照某种特征或规则划分为不同的层，然后从不同的层中独立、随机地抽取样本，从而保证样本的结构和总体的结构相近。\n\n抽样最重要的一点就是要尽量保证样本具有代表性，避免样本误差对实验结论的影响，否则根据有偏差的样本得出的数据和结论可能会带来误导。\n\n\n## 统计量及其分布\n在选择完抽样方法后，还需要选择适当的统计指标来评估对照组和实验组的表现。通常，我们选择的都是一维连续随机变量，例如pv、uv、点击率等，随机变量的分布函数描述了随机变量的概率分布的情况。我们实际常用的分布主要是正态分布和t分布。\n\n### 正态分布\n正态分布是一种应用非常广泛的概率分布，正态分布的密度曲线是一条关于 $x = \\mu$ 对称的钟形曲线，方差 $\\sigma ^{2}$ 决定了曲线中峰的陡峭程度。其中，$\\mu$ 是正态分布的数学期望，$\\sigma ^{2}$ 是正态分布的方差，正态分布记为 $X \\sim N(\\mu,\\sigma ^ {2})$。$\\mu = 0$ 且 $\\sigma ^{2} = 1$ 时的正态分布称为标准正态分布，记为 $X \\sim N(0,1)$。\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Normal_Distribution_PDF.svg/350px-Normal_Distribution_PDF.svg.png \"normal distribution\")\n\n根据中心极限定理，一个变量如果是由大量微小的、独立的随机因素叠加的结果，那么当样本量足够大的时候，这个变量近似服从正态分布。\n\n![](https://upload.wikimedia.org/wikipedia/commons/0/06/De_moivre-laplace.gif \"central limit theorem\")\n\n### t分布\n通常情况下，我们无法知道正态分布的总体的方差，只能用样本方差近似的代替总体方差进行计算，当样本量比较大的时候，我们可以取到比较好的近似值，但是当样本量不足的时候，误差较大，所以需要应用t分布来计算。\n\nt分布曲线和标准正态分布曲线非常接近，t分布的最大值比标准正态分布略小，尾部的概率比标准正态分布大一些。样本量越大，t分布的越接近标准正态分布，当样本量充分大的时候，t分布可以近似看作是标准正态分布。\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/TStudent.png/325px-TStudent.png \"student distribution\")\n\n\n## 参数估计\n根据采集到的样本数据，可以计算样本的均值、方差、标准差等分布特征。但是根据对样本数据的计算得到的特征值存在一定的偏差，并不能准确反应总体分布特征，因此需要根据样本特征值对总体进行估计。\n\n参数估计的形式有两种：\n\n- 点估计：根据样本估计参数的近似值\n- 区间估计：根据样本构造一个参数的取值范围，使得待估参数落在这个范围中的可信程度较高\n\n### 置信区间\n置信区间是区间估计的一种，是指在样本量不变的前提下，我们重复抽样，用同样的方法构造置信区间，有95%的置信区间会包含真实值，所以当我们只构造一次置信区间的时候，我们也认为这个区间是可信的，是包含了总体参数真实值的。这个概率也被称为置信度。置信度越高，结果的可靠性也就越高，但是置信度的提高往往伴随着区间的扩大。\n\n![](http://zy.swust.net.cn/14/1/dzclyyb/kcxx/z2/image/5_clip_image011.jpg \"confidence interval\")\n\n\n## 假设检验\n假设检验通常用来根据样本数据推断总体的某些性质，先对总体的参数提出某种假设，然后利用样本数据判断假设是否成立。在A/B测试中，通常我们希望推断的性质是优化指标的总体期望，即实验组对应的总体的某个优化指标的均值是否优于对照组的相应总体指标。\n\n假设检验运用了反证法，其一般流程是\n\n- 提出原假设和备择假设，原假设的内容一般是希望被证明为错误的假设或者需要着重考虑的假设。与原假设相对的是备择假设，即希望被证明是正确的另一种可能\n- 选择检验方法和检验统计量\n- 在原假设下推导统计量的分布，比如正态分布或t分布等\n- 选择显著性水平\n- 计算拒绝域，如果统计量未落在拒绝域，则接受原假设，如果统计量落在拒绝域，则接受备择假设。\n\n### 显著性检验\n拒绝域即拒绝原假设的区域，其概率即为显著性水平。常用显著性水平如5%、1%等，即在原假设成立的条件下，样本值落在拒绝域的概率很低，是一个小概率事件，按照实际推断原理，小概率事件在一次抽样中一般是不会发生的，因为我们有理由认为样本值落在拒绝域的时候，原假设是不成立的。\n\n不过实际推断原理只是说在一次抽样中，小概率事件可以认为是不会发生的，而不能肯定绝对不发生。因此，有一定概率在原假设成立的情况下，统计量落入拒绝域，导致我们拒绝原假设。这种情况实际上是一种错误，在假设检验中，称这种错误为第一类错误，也就是“弃真”错误，发生的概率记作 $\\alpha$，即显著性水平。另一种错误是原假设不成立，但是接受了原假设，称为第二类错误，即“受伪”错误，它发生的概率记作 $\\beta$。\n\n由于抽样的随机性，我们不可能完全排除这两类错误的发生，因此只能把这两类错误控制在一定的范围之内。当样本容量 n 确定之后，犯两类错误的概率不可能同时降低，通常我们会用一个较小的显著性水平 $\\alpha$ 来控制第一类错误的发生，因为原假设一般是结合问题特点提出的，需要着重考虑的假设，不应该轻易拒绝，所以第一类错误的概率要控制得较小。这种只控制犯第一类错误的概率，而不考虑犯第二类错误的概率的检验，称为显著性检验。\n\n### 双侧检验，单侧检验\n实际应用中，我们经常会区分双侧检验和单侧检验，这是根据备择假设的定义选定的，即：\n\n- 双侧检验：如果备择假设没有特定的方向性，这样的检验称为双侧检验，对于正态分布而言，拒绝域分布在曲线的两端\n- 单侧检验：如果备择假设具有特定的方向性，这样的检验称为单侧检验，对于正态分布而言，拒绝域在曲线的一侧\n![](http://course.cau-edu.net.cn/course/Z0193/ch06/se01/content/htmlimages/index_3.gif \"hypothesis testing\")\n\n### 检验方法\n上述流程中，有一步选择检验方法，在A/B测试中，我们通常计算的统计量都服从正态分布或t分布，这里以此为例进行展开。\n\n比较常用的检验方法包括Z检验和t检验，选择取决于总体方差和样本量。\n\n- 总体方差已知：Z检验\n- 总体方差未知，样本量大于30：t检验，或者Z检验，用样本方差近似代替总体方差\n- 总体方差未知，样本量小于30：t检验\n\n\n#### Z检验\nZ检验适用于大样本的两平均数之间差异显著性检验的方法，它是通过计算两个平均数之间差的Z分数来与规定的理论Z值相比较，从而判定两平均数的差异是否显著的一种差异显著性检验方法。\n\nZ统计量的计算公式为：\n$$Z = \\frac{X - \\mu}{\\sigma}$$\n\nZ统计量用来度量观测到的统计量和假设总体参数之间的差值，以标准差为单位，可以看做使用总体的期望和标准差对随机变量 X 进行标准化的结果。当随机变量 X 无法确定时，则为样本的平均数，Z 统计量的计算公式修改为：\n$$Z = \\frac{\\bar X - \\mu}{\\frac{\\sigma}{\\sqrt n}}$$\n\n其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，$\\sigma$ 是总体标准差，n 是样本数量，$\\frac{\\sigma}{\\sqrt n}$ 是样本标准误差。样本的标准误差用来估计来自于同一总体的多个样本所得到的样本均值之间的差异性。使用均值的标准误差可以确定样本均值的评估精确度。标准误差的值越小，表示对总体的评估越精确。\n\n\n#### t检验\nt检验是用t分布理论来推断两个平均数差异的显著性检验。常用于根据小样本来估计呈正态分布且方差未知的总体的均值，如果方差已知，应该用正态分布来估计总体均值。t检验是对Z检验的改进，因为Z检验的前提是总体的标准差已知，虽然在样本数量大(通常是30)的时候，可以用Z检验求得近似值，但样本量小的时候，误差较大，因此要改用t检验以求准确。\n\nt统计量的计算公式为：\n$$t = \\frac{\\bar X - \\mu}{\\frac{S}{\\sqrt n}}$$\n\n其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，n 是样本数量，S 是样本标准差，计算公式为 $S=\\sqrt {\\frac{\\sum_{i=0}^n (x_i - \\bar x)^2}{n-1}}$，$\\frac{S}{\\sqrt n}$ 是样本标准误差。\n\n这个时候，我们说统计量满足自由度为(n-1)的t分布。其中自由度是指当以样本的统计量来估计总体的参数时，样本中能独立或能自由变化的数据的个数。在使用样本均值近似替代总体期望计算样本方差的过程中，因为样本均值已经确定了，所以样本方差的自由度是 n-1 。\n\nt统计量以标准误差的单位度量观测的样本统计量与其假设的总体参数之差，t检验将此观测的t统计量与自由度为 n-1 的 t 分布中的临界值进行比较，以确定估计和假设的总体参数值之差是否在统计意义上显著。\n\n常用t检验的情况：\n\n- 单样本检验：检验一个正态分布的总体的均值是否满足原假设\n- 双样本检验：检验两个正态分布的总体均值之差是否满足原假设\n- 配对t检验：检验一个正态分布的两组配对样本的总体均值之差或一组样本的前后两次测量的总体均值之差是否满足原假设\n\n我们实际应用的时候，对比实验组和对照组的统计量差异的时候，符合配对t检验的情况，此时，t统计量的公式为\n$$t = \\frac{\\bar d - \\mu}{\\frac{S_d}{\\sqrt n}}$$\n\n其中，n是样本数量，n-1是自由度，$d_i = x_{1i} - x_{2i}$ 是样本元素，$\\bar d = \\frac{\\sum_{i=0}^n d_i}{n}$ 是样本均值，$S_d = \\sqrt{\\frac{\\sum_{i=0}^n (d_i - \\bar d)^2}{n-1}}$ 是样本标准差。\n\n\n### p-value\n在假设检验的过程中，我们经常听到 p 值这个名词，它的含义是：在原假设成立的条件下，我们观察到计算所得样本数据特征的概率，通常将 p 值和显著性水平进行比较以判断是否拒绝原假设。如果 p 值小于显著性水平，说明我们在原假设的条件下几乎不会得到这样的数据，所以我们应该拒绝原假设。\n\n![](http://7xiium.com1.z0.glb.clouddn.com/p-value.png)\n\n\n## 示例\n下面我们通过一个例子梳理一下。假设我们设计了一个实验，通过随机抽样选出了样本，经过一段时间的实验，收集到了一批样本的数据。为了比较实验组和对照组的差异，我们首先提出原假设和备择假设：\n\n- 原假设 H0：实验组与对照组的统计指标没有差异，即 $\\mu_d = 0$\n- 备择假设 H1：实验组与对照组的统计指标有明显差异，即 $\\mu_d \\neq 0$\n\n然后我们定义实验组和对照组之间统计量的差异为 $d_i= x_{1i} - x_{2i}$, 现在假设我们的统计量服从正态分布，这样 $d_i$ 也服从正态分布，分布的方差未知。接下来我们根据样本数量选择使用Z检验或者t检验，假设我们样本量不足，使用t检验。这时我们可以先计算得到样本数据的均值 $\\bar d$，然后根据样本均值计算样本方差，公式为：\n$$S^2 = \\frac{\\sum_{i=0}^n (d_i - \\bar d)^2}{n-1}$$\n\n根据样本均值和标准差可以计算t统计量，计算公式为：\n$$t = \\frac{\\bar d - \\mu_0}{\\frac{S_d}{\\sqrt n}}$$\n\n此时，t统计量服从自由度为 n-1 的t分布。因为我们的原假设是 $\\mu_d = 0$，所以此处取 $\\mu_0 = 0$。\n\n然后我们选择显著性水平为5%，即 $\\alpha = 0.05$，根据自由度和显著性水平，我们可以得到，原假设的拒绝域为\n$$ \\lvert t \\rvert = \\left| \\frac{\\bar d}{\\frac{S_d}{\\sqrt n}} \\right| \\gt t_{\\frac{\\alpha}{2}} (n-1) $$\n\n我们查表或者通过t分布的累积概率密度函数计算得到 $t_{\\frac{\\alpha}{2}} (n-1)$ 的值，或者将不等式展开，转化为对 $\\bar d$ 限定的形式：\n$$ \\lvert{\\bar d}\\rvert \\gt \\frac{S_d}{\\sqrt n} \\cdot t_{\\frac{\\alpha}{2}} (n-1)$$\n\n然后我们可以判断是否拒绝原假设。此外，我们可以计算 $\\mu_d$ 的置信区间。假设我们需要计算置信度为95%的置信区间，则 $\\alpha = 0.05$，相应的置信区间为：\n$$ \\bar d \\pm \\frac{S_d}{\\sqrt n} \\cdot t_{\\frac{\\alpha}{2}} (n-1)$$\n\n在实际应用的时候，往往还会需要pm提供一个差异的心里预期值，比如 1% 或 5% 等，通过检查两组数据差异的置信区间是否在预期值之上，可以进一步评估实验的效果。\n\n## 结语\n以上就是我这一段时间接触到的A/B测试中用到的主要统计学原理，主要是针对单个统计量的情况，而实际的实验中我们往往需要通过评估多个统计量的变化来对比两组样本的效果差异。如何根据多个统计指标设计评估模型，是我们面对的下一个问题。\n\n## References\n[A/B Testing](https://en.wikipedia.org/wiki/A/B_testing)\n\n[抽样](https://zh.wikipedia.org/wiki/%E6%8A%BD%E6%A8%A3)\n\n[正态分布](https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83)\n\n[t分布](https://zh.wikipedia.org/wiki/%E5%AD%A6%E7%94%9Ft-%E5%88%86%E5%B8%83)\n\n[吆喝科技帮助手册](http://doc.appadhoc.com/dataDecision/interpret.html)\n\n[什么是t值——Minitab](http://support.minitab.com/zh-cn/minitab/17/topic-library/basic-statistics-and-graphs/hypothesis-tests/tests-of-means/what-is-a-t-value/)\n\n[Hypothesis Testing -- uncfsu](http://faculty.uncfsu.edu/dwallace/shyp.html)\n","slug":"simple-stats-in-abtesting","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910u000c6bk2squnszl4","content":"<h2 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h2><p>最近做了一个 A/B 测试相关的项目，填补了这部分知识的空白。以前只知道 A/B 测试的大概机制，对原理并没有什么了解，通过这个项目，对 A/B 测试的统计学原理有了一点了解，遂决定记录成文，顺便更新下大半年没动过的博客……<br><a id=\"more\"></a></p>\n<h2 id=\"A-B-testing\"><a href=\"#A-B-testing\" class=\"headerlink\" title=\"A/B testing\"></a>A/B testing</h2><p>A/B 测试大家应该都有所了解，所以就简单引用一下定义：</p>\n<blockquote>\n<p>In marketing and business intelligence, A/B testing is a term for a randomized experiment with two variants, A and B, which are the control and variation in the controlled experiment.[1]<br>A/B testing is a form of statistical hypothesis testing with two variants leading to the technical term, two-sample hypothesis testing, used in the field of statistics.<br>– <a href=\"https://en.wikipedia.org/wiki/A/B_testing\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>\n</blockquote>\n<p>即，A/B 测试是一种两样本的随机对照试验，在统计学上是一种两样本的假设检验。在计算机方面，A/B 测试通常是为了通过评估对照组和实验组之间的差异，决定产品迭代的方向。A/B 测试的概念也被扩展到多样本的实验方式上。</p>\n<p>我之前对 A/B 测试的理解仅限于大概流程，实验设计-&gt;流量划分-&gt;实验进行-&gt;数据采集-&gt;数据分析-&gt;结论产出，但是一直没想过数据分析是如何进行的，这次主要填补的就是这部分的内容。</p>\n<h2 id=\"总体与样本\"><a href=\"#总体与样本\" class=\"headerlink\" title=\"总体与样本\"></a>总体与样本</h2><p>总体即研究对象的某项数量指标的全体。总体中个每个元素称为个体。在A/B测试中，我们产品的所有用户的某项指标构成总体，例如用户的付款转化率等。</p>\n<p>实际应用中，通常总体的量级可能会非常大，不适于直接在总体上做实验并分析数据；或者不希望过多的用户参与到 A/B 测试中，避免对大部分用户造成打扰，所以一般做 A/B 测试都是使用小流量进行的，即流量划分这一步会决定哪部分流量进行实验，根据对这一部分流量的实验数据进行分析，将结论推广到全部流量。流量划分即通过抽样来从总体中划定实验范围的过程。</p>\n<p>抽样，是指按照一定规则从总体中抽取若干个体进行观察试验，以推断总体的分布及特征等信息的方式。最常用的抽样方法是随机抽样，即从总体中随机抽取n个个体作为样本，使得每一个个体都有相同的概率被抽中。常用于个体间差异较小，且互相独立的情况。此外使用较多的还有分层抽样，即将个体按照某种特征或规则划分为不同的层，然后从不同的层中独立、随机地抽取样本，从而保证样本的结构和总体的结构相近。</p>\n<p>抽样最重要的一点就是要尽量保证样本具有代表性，避免样本误差对实验结论的影响，否则根据有偏差的样本得出的数据和结论可能会带来误导。</p>\n<h2 id=\"统计量及其分布\"><a href=\"#统计量及其分布\" class=\"headerlink\" title=\"统计量及其分布\"></a>统计量及其分布</h2><p>在选择完抽样方法后，还需要选择适当的统计指标来评估对照组和实验组的表现。通常，我们选择的都是一维连续随机变量，例如pv、uv、点击率等，随机变量的分布函数描述了随机变量的概率分布的情况。我们实际常用的分布主要是正态分布和t分布。</p>\n<h3 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h3><p>正态分布是一种应用非常广泛的概率分布，正态分布的密度曲线是一条关于 $x = \\mu$ 对称的钟形曲线，方差 $\\sigma ^{2}$ 决定了曲线中峰的陡峭程度。其中，$\\mu$ 是正态分布的数学期望，$\\sigma ^{2}$ 是正态分布的方差，正态分布记为 $X \\sim N(\\mu,\\sigma ^ {2})$。$\\mu = 0$ 且 $\\sigma ^{2} = 1$ 时的正态分布称为标准正态分布，记为 $X \\sim N(0,1)$。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Normal_Distribution_PDF.svg/350px-Normal_Distribution_PDF.svg.png\" alt=\"\" title=\"normal distribution\"></p>\n<p>根据中心极限定理，一个变量如果是由大量微小的、独立的随机因素叠加的结果，那么当样本量足够大的时候，这个变量近似服从正态分布。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/0/06/De_moivre-laplace.gif\" alt=\"\" title=\"central limit theorem\"></p>\n<h3 id=\"t分布\"><a href=\"#t分布\" class=\"headerlink\" title=\"t分布\"></a>t分布</h3><p>通常情况下，我们无法知道正态分布的总体的方差，只能用样本方差近似的代替总体方差进行计算，当样本量比较大的时候，我们可以取到比较好的近似值，但是当样本量不足的时候，误差较大，所以需要应用t分布来计算。</p>\n<p>t分布曲线和标准正态分布曲线非常接近，t分布的最大值比标准正态分布略小，尾部的概率比标准正态分布大一些。样本量越大，t分布的越接近标准正态分布，当样本量充分大的时候，t分布可以近似看作是标准正态分布。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/TStudent.png/325px-TStudent.png\" alt=\"\" title=\"student distribution\"></p>\n<h2 id=\"参数估计\"><a href=\"#参数估计\" class=\"headerlink\" title=\"参数估计\"></a>参数估计</h2><p>根据采集到的样本数据，可以计算样本的均值、方差、标准差等分布特征。但是根据对样本数据的计算得到的特征值存在一定的偏差，并不能准确反应总体分布特征，因此需要根据样本特征值对总体进行估计。</p>\n<p>参数估计的形式有两种：</p>\n<ul>\n<li>点估计：根据样本估计参数的近似值</li>\n<li>区间估计：根据样本构造一个参数的取值范围，使得待估参数落在这个范围中的可信程度较高</li>\n</ul>\n<h3 id=\"置信区间\"><a href=\"#置信区间\" class=\"headerlink\" title=\"置信区间\"></a>置信区间</h3><p>置信区间是区间估计的一种，是指在样本量不变的前提下，我们重复抽样，用同样的方法构造置信区间，有95%的置信区间会包含真实值，所以当我们只构造一次置信区间的时候，我们也认为这个区间是可信的，是包含了总体参数真实值的。这个概率也被称为置信度。置信度越高，结果的可靠性也就越高，但是置信度的提高往往伴随着区间的扩大。</p>\n<p><img src=\"http://zy.swust.net.cn/14/1/dzclyyb/kcxx/z2/image/5_clip_image011.jpg\" alt=\"\" title=\"confidence interval\"></p>\n<h2 id=\"假设检验\"><a href=\"#假设检验\" class=\"headerlink\" title=\"假设检验\"></a>假设检验</h2><p>假设检验通常用来根据样本数据推断总体的某些性质，先对总体的参数提出某种假设，然后利用样本数据判断假设是否成立。在A/B测试中，通常我们希望推断的性质是优化指标的总体期望，即实验组对应的总体的某个优化指标的均值是否优于对照组的相应总体指标。</p>\n<p>假设检验运用了反证法，其一般流程是</p>\n<ul>\n<li>提出原假设和备择假设，原假设的内容一般是希望被证明为错误的假设或者需要着重考虑的假设。与原假设相对的是备择假设，即希望被证明是正确的另一种可能</li>\n<li>选择检验方法和检验统计量</li>\n<li>在原假设下推导统计量的分布，比如正态分布或t分布等</li>\n<li>选择显著性水平</li>\n<li>计算拒绝域，如果统计量未落在拒绝域，则接受原假设，如果统计量落在拒绝域，则接受备择假设。</li>\n</ul>\n<h3 id=\"显著性检验\"><a href=\"#显著性检验\" class=\"headerlink\" title=\"显著性检验\"></a>显著性检验</h3><p>拒绝域即拒绝原假设的区域，其概率即为显著性水平。常用显著性水平如5%、1%等，即在原假设成立的条件下，样本值落在拒绝域的概率很低，是一个小概率事件，按照实际推断原理，小概率事件在一次抽样中一般是不会发生的，因为我们有理由认为样本值落在拒绝域的时候，原假设是不成立的。</p>\n<p>不过实际推断原理只是说在一次抽样中，小概率事件可以认为是不会发生的，而不能肯定绝对不发生。因此，有一定概率在原假设成立的情况下，统计量落入拒绝域，导致我们拒绝原假设。这种情况实际上是一种错误，在假设检验中，称这种错误为第一类错误，也就是“弃真”错误，发生的概率记作 $\\alpha$，即显著性水平。另一种错误是原假设不成立，但是接受了原假设，称为第二类错误，即“受伪”错误，它发生的概率记作 $\\beta$。</p>\n<p>由于抽样的随机性，我们不可能完全排除这两类错误的发生，因此只能把这两类错误控制在一定的范围之内。当样本容量 n 确定之后，犯两类错误的概率不可能同时降低，通常我们会用一个较小的显著性水平 $\\alpha$ 来控制第一类错误的发生，因为原假设一般是结合问题特点提出的，需要着重考虑的假设，不应该轻易拒绝，所以第一类错误的概率要控制得较小。这种只控制犯第一类错误的概率，而不考虑犯第二类错误的概率的检验，称为显著性检验。</p>\n<h3 id=\"双侧检验，单侧检验\"><a href=\"#双侧检验，单侧检验\" class=\"headerlink\" title=\"双侧检验，单侧检验\"></a>双侧检验，单侧检验</h3><p>实际应用中，我们经常会区分双侧检验和单侧检验，这是根据备择假设的定义选定的，即：</p>\n<ul>\n<li>双侧检验：如果备择假设没有特定的方向性，这样的检验称为双侧检验，对于正态分布而言，拒绝域分布在曲线的两端</li>\n<li>单侧检验：如果备择假设具有特定的方向性，这样的检验称为单侧检验，对于正态分布而言，拒绝域在曲线的一侧<br><img src=\"http://course.cau-edu.net.cn/course/Z0193/ch06/se01/content/htmlimages/index_3.gif\" alt=\"\" title=\"hypothesis testing\"></li>\n</ul>\n<h3 id=\"检验方法\"><a href=\"#检验方法\" class=\"headerlink\" title=\"检验方法\"></a>检验方法</h3><p>上述流程中，有一步选择检验方法，在A/B测试中，我们通常计算的统计量都服从正态分布或t分布，这里以此为例进行展开。</p>\n<p>比较常用的检验方法包括Z检验和t检验，选择取决于总体方差和样本量。</p>\n<ul>\n<li>总体方差已知：Z检验</li>\n<li>总体方差未知，样本量大于30：t检验，或者Z检验，用样本方差近似代替总体方差</li>\n<li>总体方差未知，样本量小于30：t检验</li>\n</ul>\n<h4 id=\"Z检验\"><a href=\"#Z检验\" class=\"headerlink\" title=\"Z检验\"></a>Z检验</h4><p>Z检验适用于大样本的两平均数之间差异显著性检验的方法，它是通过计算两个平均数之间差的Z分数来与规定的理论Z值相比较，从而判定两平均数的差异是否显著的一种差异显著性检验方法。</p>\n<p>Z统计量的计算公式为：<br>$$Z = \\frac{X - \\mu}{\\sigma}$$</p>\n<p>Z统计量用来度量观测到的统计量和假设总体参数之间的差值，以标准差为单位，可以看做使用总体的期望和标准差对随机变量 X 进行标准化的结果。当随机变量 X 无法确定时，则为样本的平均数，Z 统计量的计算公式修改为：<br>$$Z = \\frac{\\bar X - \\mu}{\\frac{\\sigma}{\\sqrt n}}$$</p>\n<p>其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，$\\sigma$ 是总体标准差，n 是样本数量，$\\frac{\\sigma}{\\sqrt n}$ 是样本标准误差。样本的标准误差用来估计来自于同一总体的多个样本所得到的样本均值之间的差异性。使用均值的标准误差可以确定样本均值的评估精确度。标准误差的值越小，表示对总体的评估越精确。</p>\n<h4 id=\"t检验\"><a href=\"#t检验\" class=\"headerlink\" title=\"t检验\"></a>t检验</h4><p>t检验是用t分布理论来推断两个平均数差异的显著性检验。常用于根据小样本来估计呈正态分布且方差未知的总体的均值，如果方差已知，应该用正态分布来估计总体均值。t检验是对Z检验的改进，因为Z检验的前提是总体的标准差已知，虽然在样本数量大(通常是30)的时候，可以用Z检验求得近似值，但样本量小的时候，误差较大，因此要改用t检验以求准确。</p>\n<p>t统计量的计算公式为：<br>$$t = \\frac{\\bar X - \\mu}{\\frac{S}{\\sqrt n}}$$</p>\n<p>其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，n 是样本数量，S 是样本标准差，计算公式为 $S=\\sqrt {\\frac{\\sum_{i=0}^n (x_i - \\bar x)^2}{n-1}}$，$\\frac{S}{\\sqrt n}$ 是样本标准误差。</p>\n<p>这个时候，我们说统计量满足自由度为(n-1)的t分布。其中自由度是指当以样本的统计量来估计总体的参数时，样本中能独立或能自由变化的数据的个数。在使用样本均值近似替代总体期望计算样本方差的过程中，因为样本均值已经确定了，所以样本方差的自由度是 n-1 。</p>\n<p>t统计量以标准误差的单位度量观测的样本统计量与其假设的总体参数之差，t检验将此观测的t统计量与自由度为 n-1 的 t 分布中的临界值进行比较，以确定估计和假设的总体参数值之差是否在统计意义上显著。</p>\n<p>常用t检验的情况：</p>\n<ul>\n<li>单样本检验：检验一个正态分布的总体的均值是否满足原假设</li>\n<li>双样本检验：检验两个正态分布的总体均值之差是否满足原假设</li>\n<li>配对t检验：检验一个正态分布的两组配对样本的总体均值之差或一组样本的前后两次测量的总体均值之差是否满足原假设</li>\n</ul>\n<p>我们实际应用的时候，对比实验组和对照组的统计量差异的时候，符合配对t检验的情况，此时，t统计量的公式为<br>$$t = \\frac{\\bar d - \\mu}{\\frac{S_d}{\\sqrt n}}$$</p>\n<p>其中，n是样本数量，n-1是自由度，$d<em>i = x</em>{1i} - x<em>{2i}$ 是样本元素，$\\bar d = \\frac{\\sum</em>{i=0}^n d_i}{n}$ 是样本均值，$S<em>d = \\sqrt{\\frac{\\sum</em>{i=0}^n (d_i - \\bar d)^2}{n-1}}$ 是样本标准差。</p>\n<h3 id=\"p-value\"><a href=\"#p-value\" class=\"headerlink\" title=\"p-value\"></a>p-value</h3><p>在假设检验的过程中，我们经常听到 p 值这个名词，它的含义是：在原假设成立的条件下，我们观察到计算所得样本数据特征的概率，通常将 p 值和显著性水平进行比较以判断是否拒绝原假设。如果 p 值小于显著性水平，说明我们在原假设的条件下几乎不会得到这样的数据，所以我们应该拒绝原假设。</p>\n<p><img src=\"http://7xiium.com1.z0.glb.clouddn.com/p-value.png\" alt=\"\"></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>下面我们通过一个例子梳理一下。假设我们设计了一个实验，通过随机抽样选出了样本，经过一段时间的实验，收集到了一批样本的数据。为了比较实验组和对照组的差异，我们首先提出原假设和备择假设：</p>\n<ul>\n<li>原假设 H0：实验组与对照组的统计指标没有差异，即 $\\mu_d = 0$</li>\n<li>备择假设 H1：实验组与对照组的统计指标有明显差异，即 $\\mu_d \\neq 0$</li>\n</ul>\n<p>然后我们定义实验组和对照组之间统计量的差异为 $d<em>i= x</em>{1i} - x_{2i}$, 现在假设我们的统计量服从正态分布，这样 $d<em>i$ 也服从正态分布，分布的方差未知。接下来我们根据样本数量选择使用Z检验或者t检验，假设我们样本量不足，使用t检验。这时我们可以先计算得到样本数据的均值 $\\bar d$，然后根据样本均值计算样本方差，公式为：<br>$$S^2 = \\frac{\\sum</em>{i=0}^n (d_i - \\bar d)^2}{n-1}$$</p>\n<p>根据样本均值和标准差可以计算t统计量，计算公式为：<br>$$t = \\frac{\\bar d - \\mu_0}{\\frac{S_d}{\\sqrt n}}$$</p>\n<p>此时，t统计量服从自由度为 n-1 的t分布。因为我们的原假设是 $\\mu_d = 0$，所以此处取 $\\mu_0 = 0$。</p>\n<p>然后我们选择显著性水平为5%，即 $\\alpha = 0.05$，根据自由度和显著性水平，我们可以得到，原假设的拒绝域为<br>$$ \\lvert t \\rvert = \\left| \\frac{\\bar d}{\\frac{S<em>d}{\\sqrt n}} \\right| \\gt t</em>{\\frac{\\alpha}{2}} (n-1) $$</p>\n<p>我们查表或者通过t分布的累积概率密度函数计算得到 $t_{\\frac{\\alpha}{2}} (n-1)$ 的值，或者将不等式展开，转化为对 $\\bar d$ 限定的形式：<br>$$ \\lvert{\\bar d}\\rvert \\gt \\frac{S<em>d}{\\sqrt n} \\cdot t</em>{\\frac{\\alpha}{2}} (n-1)$$</p>\n<p>然后我们可以判断是否拒绝原假设。此外，我们可以计算 $\\mu_d$ 的置信区间。假设我们需要计算置信度为95%的置信区间，则 $\\alpha = 0.05$，相应的置信区间为：<br>$$ \\bar d \\pm \\frac{S<em>d}{\\sqrt n} \\cdot t</em>{\\frac{\\alpha}{2}} (n-1)$$</p>\n<p>在实际应用的时候，往往还会需要pm提供一个差异的心里预期值，比如 1% 或 5% 等，通过检查两组数据差异的置信区间是否在预期值之上，可以进一步评估实验的效果。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>以上就是我这一段时间接触到的A/B测试中用到的主要统计学原理，主要是针对单个统计量的情况，而实际的实验中我们往往需要通过评估多个统计量的变化来对比两组样本的效果差异。如何根据多个统计指标设计评估模型，是我们面对的下一个问题。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://en.wikipedia.org/wiki/A/B_testing\" target=\"_blank\" rel=\"noopener\">A/B Testing</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%8A%BD%E6%A8%A3\" target=\"_blank\" rel=\"noopener\">抽样</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">正态分布</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%AD%A6%E7%94%9Ft-%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">t分布</a></p>\n<p><a href=\"http://doc.appadhoc.com/dataDecision/interpret.html\" target=\"_blank\" rel=\"noopener\">吆喝科技帮助手册</a></p>\n<p><a href=\"http://support.minitab.com/zh-cn/minitab/17/topic-library/basic-statistics-and-graphs/hypothesis-tests/tests-of-means/what-is-a-t-value/\" target=\"_blank\" rel=\"noopener\">什么是t值——Minitab</a></p>\n<p><a href=\"http://faculty.uncfsu.edu/dwallace/shyp.html\" target=\"_blank\" rel=\"noopener\">Hypothesis Testing – uncfsu</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h2><p>最近做了一个 A/B 测试相关的项目，填补了这部分知识的空白。以前只知道 A/B 测试的大概机制，对原理并没有什么了解，通过这个项目，对 A/B 测试的统计学原理有了一点了解，遂决定记录成文，顺便更新下大半年没动过的博客……<br>","more":"</p>\n<h2 id=\"A-B-testing\"><a href=\"#A-B-testing\" class=\"headerlink\" title=\"A/B testing\"></a>A/B testing</h2><p>A/B 测试大家应该都有所了解，所以就简单引用一下定义：</p>\n<blockquote>\n<p>In marketing and business intelligence, A/B testing is a term for a randomized experiment with two variants, A and B, which are the control and variation in the controlled experiment.[1]<br>A/B testing is a form of statistical hypothesis testing with two variants leading to the technical term, two-sample hypothesis testing, used in the field of statistics.<br>– <a href=\"https://en.wikipedia.org/wiki/A/B_testing\" target=\"_blank\" rel=\"noopener\">wikipedia</a></p>\n</blockquote>\n<p>即，A/B 测试是一种两样本的随机对照试验，在统计学上是一种两样本的假设检验。在计算机方面，A/B 测试通常是为了通过评估对照组和实验组之间的差异，决定产品迭代的方向。A/B 测试的概念也被扩展到多样本的实验方式上。</p>\n<p>我之前对 A/B 测试的理解仅限于大概流程，实验设计-&gt;流量划分-&gt;实验进行-&gt;数据采集-&gt;数据分析-&gt;结论产出，但是一直没想过数据分析是如何进行的，这次主要填补的就是这部分的内容。</p>\n<h2 id=\"总体与样本\"><a href=\"#总体与样本\" class=\"headerlink\" title=\"总体与样本\"></a>总体与样本</h2><p>总体即研究对象的某项数量指标的全体。总体中个每个元素称为个体。在A/B测试中，我们产品的所有用户的某项指标构成总体，例如用户的付款转化率等。</p>\n<p>实际应用中，通常总体的量级可能会非常大，不适于直接在总体上做实验并分析数据；或者不希望过多的用户参与到 A/B 测试中，避免对大部分用户造成打扰，所以一般做 A/B 测试都是使用小流量进行的，即流量划分这一步会决定哪部分流量进行实验，根据对这一部分流量的实验数据进行分析，将结论推广到全部流量。流量划分即通过抽样来从总体中划定实验范围的过程。</p>\n<p>抽样，是指按照一定规则从总体中抽取若干个体进行观察试验，以推断总体的分布及特征等信息的方式。最常用的抽样方法是随机抽样，即从总体中随机抽取n个个体作为样本，使得每一个个体都有相同的概率被抽中。常用于个体间差异较小，且互相独立的情况。此外使用较多的还有分层抽样，即将个体按照某种特征或规则划分为不同的层，然后从不同的层中独立、随机地抽取样本，从而保证样本的结构和总体的结构相近。</p>\n<p>抽样最重要的一点就是要尽量保证样本具有代表性，避免样本误差对实验结论的影响，否则根据有偏差的样本得出的数据和结论可能会带来误导。</p>\n<h2 id=\"统计量及其分布\"><a href=\"#统计量及其分布\" class=\"headerlink\" title=\"统计量及其分布\"></a>统计量及其分布</h2><p>在选择完抽样方法后，还需要选择适当的统计指标来评估对照组和实验组的表现。通常，我们选择的都是一维连续随机变量，例如pv、uv、点击率等，随机变量的分布函数描述了随机变量的概率分布的情况。我们实际常用的分布主要是正态分布和t分布。</p>\n<h3 id=\"正态分布\"><a href=\"#正态分布\" class=\"headerlink\" title=\"正态分布\"></a>正态分布</h3><p>正态分布是一种应用非常广泛的概率分布，正态分布的密度曲线是一条关于 $x = \\mu$ 对称的钟形曲线，方差 $\\sigma ^{2}$ 决定了曲线中峰的陡峭程度。其中，$\\mu$ 是正态分布的数学期望，$\\sigma ^{2}$ 是正态分布的方差，正态分布记为 $X \\sim N(\\mu,\\sigma ^ {2})$。$\\mu = 0$ 且 $\\sigma ^{2} = 1$ 时的正态分布称为标准正态分布，记为 $X \\sim N(0,1)$。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Normal_Distribution_PDF.svg/350px-Normal_Distribution_PDF.svg.png\" alt=\"\" title=\"normal distribution\"></p>\n<p>根据中心极限定理，一个变量如果是由大量微小的、独立的随机因素叠加的结果，那么当样本量足够大的时候，这个变量近似服从正态分布。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/0/06/De_moivre-laplace.gif\" alt=\"\" title=\"central limit theorem\"></p>\n<h3 id=\"t分布\"><a href=\"#t分布\" class=\"headerlink\" title=\"t分布\"></a>t分布</h3><p>通常情况下，我们无法知道正态分布的总体的方差，只能用样本方差近似的代替总体方差进行计算，当样本量比较大的时候，我们可以取到比较好的近似值，但是当样本量不足的时候，误差较大，所以需要应用t分布来计算。</p>\n<p>t分布曲线和标准正态分布曲线非常接近，t分布的最大值比标准正态分布略小，尾部的概率比标准正态分布大一些。样本量越大，t分布的越接近标准正态分布，当样本量充分大的时候，t分布可以近似看作是标准正态分布。</p>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/TStudent.png/325px-TStudent.png\" alt=\"\" title=\"student distribution\"></p>\n<h2 id=\"参数估计\"><a href=\"#参数估计\" class=\"headerlink\" title=\"参数估计\"></a>参数估计</h2><p>根据采集到的样本数据，可以计算样本的均值、方差、标准差等分布特征。但是根据对样本数据的计算得到的特征值存在一定的偏差，并不能准确反应总体分布特征，因此需要根据样本特征值对总体进行估计。</p>\n<p>参数估计的形式有两种：</p>\n<ul>\n<li>点估计：根据样本估计参数的近似值</li>\n<li>区间估计：根据样本构造一个参数的取值范围，使得待估参数落在这个范围中的可信程度较高</li>\n</ul>\n<h3 id=\"置信区间\"><a href=\"#置信区间\" class=\"headerlink\" title=\"置信区间\"></a>置信区间</h3><p>置信区间是区间估计的一种，是指在样本量不变的前提下，我们重复抽样，用同样的方法构造置信区间，有95%的置信区间会包含真实值，所以当我们只构造一次置信区间的时候，我们也认为这个区间是可信的，是包含了总体参数真实值的。这个概率也被称为置信度。置信度越高，结果的可靠性也就越高，但是置信度的提高往往伴随着区间的扩大。</p>\n<p><img src=\"http://zy.swust.net.cn/14/1/dzclyyb/kcxx/z2/image/5_clip_image011.jpg\" alt=\"\" title=\"confidence interval\"></p>\n<h2 id=\"假设检验\"><a href=\"#假设检验\" class=\"headerlink\" title=\"假设检验\"></a>假设检验</h2><p>假设检验通常用来根据样本数据推断总体的某些性质，先对总体的参数提出某种假设，然后利用样本数据判断假设是否成立。在A/B测试中，通常我们希望推断的性质是优化指标的总体期望，即实验组对应的总体的某个优化指标的均值是否优于对照组的相应总体指标。</p>\n<p>假设检验运用了反证法，其一般流程是</p>\n<ul>\n<li>提出原假设和备择假设，原假设的内容一般是希望被证明为错误的假设或者需要着重考虑的假设。与原假设相对的是备择假设，即希望被证明是正确的另一种可能</li>\n<li>选择检验方法和检验统计量</li>\n<li>在原假设下推导统计量的分布，比如正态分布或t分布等</li>\n<li>选择显著性水平</li>\n<li>计算拒绝域，如果统计量未落在拒绝域，则接受原假设，如果统计量落在拒绝域，则接受备择假设。</li>\n</ul>\n<h3 id=\"显著性检验\"><a href=\"#显著性检验\" class=\"headerlink\" title=\"显著性检验\"></a>显著性检验</h3><p>拒绝域即拒绝原假设的区域，其概率即为显著性水平。常用显著性水平如5%、1%等，即在原假设成立的条件下，样本值落在拒绝域的概率很低，是一个小概率事件，按照实际推断原理，小概率事件在一次抽样中一般是不会发生的，因为我们有理由认为样本值落在拒绝域的时候，原假设是不成立的。</p>\n<p>不过实际推断原理只是说在一次抽样中，小概率事件可以认为是不会发生的，而不能肯定绝对不发生。因此，有一定概率在原假设成立的情况下，统计量落入拒绝域，导致我们拒绝原假设。这种情况实际上是一种错误，在假设检验中，称这种错误为第一类错误，也就是“弃真”错误，发生的概率记作 $\\alpha$，即显著性水平。另一种错误是原假设不成立，但是接受了原假设，称为第二类错误，即“受伪”错误，它发生的概率记作 $\\beta$。</p>\n<p>由于抽样的随机性，我们不可能完全排除这两类错误的发生，因此只能把这两类错误控制在一定的范围之内。当样本容量 n 确定之后，犯两类错误的概率不可能同时降低，通常我们会用一个较小的显著性水平 $\\alpha$ 来控制第一类错误的发生，因为原假设一般是结合问题特点提出的，需要着重考虑的假设，不应该轻易拒绝，所以第一类错误的概率要控制得较小。这种只控制犯第一类错误的概率，而不考虑犯第二类错误的概率的检验，称为显著性检验。</p>\n<h3 id=\"双侧检验，单侧检验\"><a href=\"#双侧检验，单侧检验\" class=\"headerlink\" title=\"双侧检验，单侧检验\"></a>双侧检验，单侧检验</h3><p>实际应用中，我们经常会区分双侧检验和单侧检验，这是根据备择假设的定义选定的，即：</p>\n<ul>\n<li>双侧检验：如果备择假设没有特定的方向性，这样的检验称为双侧检验，对于正态分布而言，拒绝域分布在曲线的两端</li>\n<li>单侧检验：如果备择假设具有特定的方向性，这样的检验称为单侧检验，对于正态分布而言，拒绝域在曲线的一侧<br><img src=\"http://course.cau-edu.net.cn/course/Z0193/ch06/se01/content/htmlimages/index_3.gif\" alt=\"\" title=\"hypothesis testing\"></li>\n</ul>\n<h3 id=\"检验方法\"><a href=\"#检验方法\" class=\"headerlink\" title=\"检验方法\"></a>检验方法</h3><p>上述流程中，有一步选择检验方法，在A/B测试中，我们通常计算的统计量都服从正态分布或t分布，这里以此为例进行展开。</p>\n<p>比较常用的检验方法包括Z检验和t检验，选择取决于总体方差和样本量。</p>\n<ul>\n<li>总体方差已知：Z检验</li>\n<li>总体方差未知，样本量大于30：t检验，或者Z检验，用样本方差近似代替总体方差</li>\n<li>总体方差未知，样本量小于30：t检验</li>\n</ul>\n<h4 id=\"Z检验\"><a href=\"#Z检验\" class=\"headerlink\" title=\"Z检验\"></a>Z检验</h4><p>Z检验适用于大样本的两平均数之间差异显著性检验的方法，它是通过计算两个平均数之间差的Z分数来与规定的理论Z值相比较，从而判定两平均数的差异是否显著的一种差异显著性检验方法。</p>\n<p>Z统计量的计算公式为：<br>$$Z = \\frac{X - \\mu}{\\sigma}$$</p>\n<p>Z统计量用来度量观测到的统计量和假设总体参数之间的差值，以标准差为单位，可以看做使用总体的期望和标准差对随机变量 X 进行标准化的结果。当随机变量 X 无法确定时，则为样本的平均数，Z 统计量的计算公式修改为：<br>$$Z = \\frac{\\bar X - \\mu}{\\frac{\\sigma}{\\sqrt n}}$$</p>\n<p>其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，$\\sigma$ 是总体标准差，n 是样本数量，$\\frac{\\sigma}{\\sqrt n}$ 是样本标准误差。样本的标准误差用来估计来自于同一总体的多个样本所得到的样本均值之间的差异性。使用均值的标准误差可以确定样本均值的评估精确度。标准误差的值越小，表示对总体的评估越精确。</p>\n<h4 id=\"t检验\"><a href=\"#t检验\" class=\"headerlink\" title=\"t检验\"></a>t检验</h4><p>t检验是用t分布理论来推断两个平均数差异的显著性检验。常用于根据小样本来估计呈正态分布且方差未知的总体的均值，如果方差已知，应该用正态分布来估计总体均值。t检验是对Z检验的改进，因为Z检验的前提是总体的标准差已知，虽然在样本数量大(通常是30)的时候，可以用Z检验求得近似值，但样本量小的时候，误差较大，因此要改用t检验以求准确。</p>\n<p>t统计量的计算公式为：<br>$$t = \\frac{\\bar X - \\mu}{\\frac{S}{\\sqrt n}}$$</p>\n<p>其中，$\\bar X$ 是样本均值，$\\mu$ 是总体期望，n 是样本数量，S 是样本标准差，计算公式为 $S=\\sqrt {\\frac{\\sum_{i=0}^n (x_i - \\bar x)^2}{n-1}}$，$\\frac{S}{\\sqrt n}$ 是样本标准误差。</p>\n<p>这个时候，我们说统计量满足自由度为(n-1)的t分布。其中自由度是指当以样本的统计量来估计总体的参数时，样本中能独立或能自由变化的数据的个数。在使用样本均值近似替代总体期望计算样本方差的过程中，因为样本均值已经确定了，所以样本方差的自由度是 n-1 。</p>\n<p>t统计量以标准误差的单位度量观测的样本统计量与其假设的总体参数之差，t检验将此观测的t统计量与自由度为 n-1 的 t 分布中的临界值进行比较，以确定估计和假设的总体参数值之差是否在统计意义上显著。</p>\n<p>常用t检验的情况：</p>\n<ul>\n<li>单样本检验：检验一个正态分布的总体的均值是否满足原假设</li>\n<li>双样本检验：检验两个正态分布的总体均值之差是否满足原假设</li>\n<li>配对t检验：检验一个正态分布的两组配对样本的总体均值之差或一组样本的前后两次测量的总体均值之差是否满足原假设</li>\n</ul>\n<p>我们实际应用的时候，对比实验组和对照组的统计量差异的时候，符合配对t检验的情况，此时，t统计量的公式为<br>$$t = \\frac{\\bar d - \\mu}{\\frac{S_d}{\\sqrt n}}$$</p>\n<p>其中，n是样本数量，n-1是自由度，$d<em>i = x</em>{1i} - x<em>{2i}$ 是样本元素，$\\bar d = \\frac{\\sum</em>{i=0}^n d_i}{n}$ 是样本均值，$S<em>d = \\sqrt{\\frac{\\sum</em>{i=0}^n (d_i - \\bar d)^2}{n-1}}$ 是样本标准差。</p>\n<h3 id=\"p-value\"><a href=\"#p-value\" class=\"headerlink\" title=\"p-value\"></a>p-value</h3><p>在假设检验的过程中，我们经常听到 p 值这个名词，它的含义是：在原假设成立的条件下，我们观察到计算所得样本数据特征的概率，通常将 p 值和显著性水平进行比较以判断是否拒绝原假设。如果 p 值小于显著性水平，说明我们在原假设的条件下几乎不会得到这样的数据，所以我们应该拒绝原假设。</p>\n<p><img src=\"http://7xiium.com1.z0.glb.clouddn.com/p-value.png\" alt=\"\"></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>下面我们通过一个例子梳理一下。假设我们设计了一个实验，通过随机抽样选出了样本，经过一段时间的实验，收集到了一批样本的数据。为了比较实验组和对照组的差异，我们首先提出原假设和备择假设：</p>\n<ul>\n<li>原假设 H0：实验组与对照组的统计指标没有差异，即 $\\mu_d = 0$</li>\n<li>备择假设 H1：实验组与对照组的统计指标有明显差异，即 $\\mu_d \\neq 0$</li>\n</ul>\n<p>然后我们定义实验组和对照组之间统计量的差异为 $d<em>i= x</em>{1i} - x_{2i}$, 现在假设我们的统计量服从正态分布，这样 $d<em>i$ 也服从正态分布，分布的方差未知。接下来我们根据样本数量选择使用Z检验或者t检验，假设我们样本量不足，使用t检验。这时我们可以先计算得到样本数据的均值 $\\bar d$，然后根据样本均值计算样本方差，公式为：<br>$$S^2 = \\frac{\\sum</em>{i=0}^n (d_i - \\bar d)^2}{n-1}$$</p>\n<p>根据样本均值和标准差可以计算t统计量，计算公式为：<br>$$t = \\frac{\\bar d - \\mu_0}{\\frac{S_d}{\\sqrt n}}$$</p>\n<p>此时，t统计量服从自由度为 n-1 的t分布。因为我们的原假设是 $\\mu_d = 0$，所以此处取 $\\mu_0 = 0$。</p>\n<p>然后我们选择显著性水平为5%，即 $\\alpha = 0.05$，根据自由度和显著性水平，我们可以得到，原假设的拒绝域为<br>$$ \\lvert t \\rvert = \\left| \\frac{\\bar d}{\\frac{S<em>d}{\\sqrt n}} \\right| \\gt t</em>{\\frac{\\alpha}{2}} (n-1) $$</p>\n<p>我们查表或者通过t分布的累积概率密度函数计算得到 $t_{\\frac{\\alpha}{2}} (n-1)$ 的值，或者将不等式展开，转化为对 $\\bar d$ 限定的形式：<br>$$ \\lvert{\\bar d}\\rvert \\gt \\frac{S<em>d}{\\sqrt n} \\cdot t</em>{\\frac{\\alpha}{2}} (n-1)$$</p>\n<p>然后我们可以判断是否拒绝原假设。此外，我们可以计算 $\\mu_d$ 的置信区间。假设我们需要计算置信度为95%的置信区间，则 $\\alpha = 0.05$，相应的置信区间为：<br>$$ \\bar d \\pm \\frac{S<em>d}{\\sqrt n} \\cdot t</em>{\\frac{\\alpha}{2}} (n-1)$$</p>\n<p>在实际应用的时候，往往还会需要pm提供一个差异的心里预期值，比如 1% 或 5% 等，通过检查两组数据差异的置信区间是否在预期值之上，可以进一步评估实验的效果。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>以上就是我这一段时间接触到的A/B测试中用到的主要统计学原理，主要是针对单个统计量的情况，而实际的实验中我们往往需要通过评估多个统计量的变化来对比两组样本的效果差异。如何根据多个统计指标设计评估模型，是我们面对的下一个问题。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://en.wikipedia.org/wiki/A/B_testing\" target=\"_blank\" rel=\"noopener\">A/B Testing</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%8A%BD%E6%A8%A3\" target=\"_blank\" rel=\"noopener\">抽样</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">正态分布</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%AD%A6%E7%94%9Ft-%E5%88%86%E5%B8%83\" target=\"_blank\" rel=\"noopener\">t分布</a></p>\n<p><a href=\"http://doc.appadhoc.com/dataDecision/interpret.html\" target=\"_blank\" rel=\"noopener\">吆喝科技帮助手册</a></p>\n<p><a href=\"http://support.minitab.com/zh-cn/minitab/17/topic-library/basic-statistics-and-graphs/hypothesis-tests/tests-of-means/what-is-a-t-value/\" target=\"_blank\" rel=\"noopener\">什么是t值——Minitab</a></p>\n<p><a href=\"http://faculty.uncfsu.edu/dwallace/shyp.html\" target=\"_blank\" rel=\"noopener\">Hypothesis Testing – uncfsu</a></p>"},{"title":"svn工作流管理个人实践","date":"2015-05-04T08:42:51.000Z","_content":"\n## 起\n这篇博客起源于一次发布事故的反思。五一之前因为修复一个线上bug，紧急发布了一个补丁，结果发布的代码中包含了正在开发中的新功能的代码，导致了线上部分功能受影响，服务出错不可用。\n\n<!-- more -->\n\n## 承\n在回滚线上代码并紧急修复了bug之后，我们有必要重新思考一下这次出现的问题。\n- 代码没有做有效的管理，修复bug的时候没有从trunk新建issue分支\n- 发布代码上线的时候没有经过充分的测试\n- 因为是内部产品且所修复模块用户量不大，工程师略有松懈，发布比较仓促\n- 发布的时候线上代码没有进行备份\n\n## 转\n经过反思，我们重新梳理了对svn工作流的管理。\n\n![](http://nvie.com/img/git-model@2x.png \"Vincent Driessen - a-successful-git-branching-model\")\n\n借鉴 Vincent Driessen 的[a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model/)，我们将svn的工作流分为以下几个部分。\n\n### 发布\ntrunk作为项目的主分支，只维护可发布的稳定代码。开发不在trunk上进行，只有要发布的时候才把代码合并到trunk。\n\n所有发布都基于trunk的代码进行，发布时新建tag以标记发布代码的快照。\n\n### 开发\n除了trunk以外，版本库最重要的一个分支是dev分支。dev分支主要用于日常的开发工作。除了release和fix bug的分支，其他的分支不直接合并到trunk，而是合并到dev分支。\n\n### 预发布\n当dev分支的代码处在某个逻辑闭环的稳定状态时，可以基于dev分支新建预发布分支，可以命名为release-\\*，其中\\*为要发布的版本号。\n\n预发布分支经过测试和bug修复稳定下来以后，需要合并回dev分支和trunk，然后trunk的代码可以用于正式发布新的版本。\n\n### bug修复\n当在线上版本发现bug后，基于trunk新建修复特定bug的分支，可以命名为issue-\\*，其中\\*部分使用bug追踪系统的bug编号。\n\nbug修复并测试通过以后，将issue分支合并回trunk和dev分支。\n\n### 新特性开发\n当有某种特定的新功能需要开发时，可以在基于dev新建的特定分支上进行，这样的分支可以命名为feature-\\*，其中\\*为新特性的代号。\n\n如果需要包括新特性，则将其合并到dev分支。如果最终不需要的话可以删除此分支。\n\n## 合\n基于svn的工作流有很多种，以上只是其中一种实践。这样可以充分隔离开不同的功能和版本之间的代码，在保证开发效率的同时，确保发布代码的稳定性。\n\nGit的branch和tag、merge操作都更简洁高效，不过目前公司使用的主流工具还是svn，所以本篇博客主要基于svn，不足之处还请大家指出。\n\n## reference\n1. Vincent Driessen [a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model/)\n2. ruanyifeng [Git分支管理策略](http://www.ruanyifeng.com/blog/2012/07/git.html)\n3. oldratlee [Git工作流指南](https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/README.md)\n","source":"_posts/svn-workflow-management.md","raw":"title: \"svn工作流管理个人实践\"\ndate: 2015-05-04 16:42:51\ncategories:\n- 工程\ntags:\n- svn\n- git\n- 工程\n---\n\n## 起\n这篇博客起源于一次发布事故的反思。五一之前因为修复一个线上bug，紧急发布了一个补丁，结果发布的代码中包含了正在开发中的新功能的代码，导致了线上部分功能受影响，服务出错不可用。\n\n<!-- more -->\n\n## 承\n在回滚线上代码并紧急修复了bug之后，我们有必要重新思考一下这次出现的问题。\n- 代码没有做有效的管理，修复bug的时候没有从trunk新建issue分支\n- 发布代码上线的时候没有经过充分的测试\n- 因为是内部产品且所修复模块用户量不大，工程师略有松懈，发布比较仓促\n- 发布的时候线上代码没有进行备份\n\n## 转\n经过反思，我们重新梳理了对svn工作流的管理。\n\n![](http://nvie.com/img/git-model@2x.png \"Vincent Driessen - a-successful-git-branching-model\")\n\n借鉴 Vincent Driessen 的[a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model/)，我们将svn的工作流分为以下几个部分。\n\n### 发布\ntrunk作为项目的主分支，只维护可发布的稳定代码。开发不在trunk上进行，只有要发布的时候才把代码合并到trunk。\n\n所有发布都基于trunk的代码进行，发布时新建tag以标记发布代码的快照。\n\n### 开发\n除了trunk以外，版本库最重要的一个分支是dev分支。dev分支主要用于日常的开发工作。除了release和fix bug的分支，其他的分支不直接合并到trunk，而是合并到dev分支。\n\n### 预发布\n当dev分支的代码处在某个逻辑闭环的稳定状态时，可以基于dev分支新建预发布分支，可以命名为release-\\*，其中\\*为要发布的版本号。\n\n预发布分支经过测试和bug修复稳定下来以后，需要合并回dev分支和trunk，然后trunk的代码可以用于正式发布新的版本。\n\n### bug修复\n当在线上版本发现bug后，基于trunk新建修复特定bug的分支，可以命名为issue-\\*，其中\\*部分使用bug追踪系统的bug编号。\n\nbug修复并测试通过以后，将issue分支合并回trunk和dev分支。\n\n### 新特性开发\n当有某种特定的新功能需要开发时，可以在基于dev新建的特定分支上进行，这样的分支可以命名为feature-\\*，其中\\*为新特性的代号。\n\n如果需要包括新特性，则将其合并到dev分支。如果最终不需要的话可以删除此分支。\n\n## 合\n基于svn的工作流有很多种，以上只是其中一种实践。这样可以充分隔离开不同的功能和版本之间的代码，在保证开发效率的同时，确保发布代码的稳定性。\n\nGit的branch和tag、merge操作都更简洁高效，不过目前公司使用的主流工具还是svn，所以本篇博客主要基于svn，不足之处还请大家指出。\n\n## reference\n1. Vincent Driessen [a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model/)\n2. ruanyifeng [Git分支管理策略](http://www.ruanyifeng.com/blog/2012/07/git.html)\n3. oldratlee [Git工作流指南](https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/README.md)\n","slug":"svn-workflow-management","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910v000d6bk2gelhet5o","content":"<h2 id=\"起\"><a href=\"#起\" class=\"headerlink\" title=\"起\"></a>起</h2><p>这篇博客起源于一次发布事故的反思。五一之前因为修复一个线上bug，紧急发布了一个补丁，结果发布的代码中包含了正在开发中的新功能的代码，导致了线上部分功能受影响，服务出错不可用。</p>\n<a id=\"more\"></a>\n<h2 id=\"承\"><a href=\"#承\" class=\"headerlink\" title=\"承\"></a>承</h2><p>在回滚线上代码并紧急修复了bug之后，我们有必要重新思考一下这次出现的问题。</p>\n<ul>\n<li>代码没有做有效的管理，修复bug的时候没有从trunk新建issue分支</li>\n<li>发布代码上线的时候没有经过充分的测试</li>\n<li>因为是内部产品且所修复模块用户量不大，工程师略有松懈，发布比较仓促</li>\n<li>发布的时候线上代码没有进行备份</li>\n</ul>\n<h2 id=\"转\"><a href=\"#转\" class=\"headerlink\" title=\"转\"></a>转</h2><p>经过反思，我们重新梳理了对svn工作流的管理。</p>\n<p><img src=\"http://nvie.com/img/git-model@2x.png\" alt=\"\" title=\"Vincent Driessen - a-successful-git-branching-model\"></p>\n<p>借鉴 Vincent Driessen 的<a href=\"http://nvie.com/posts/a-successful-git-branching-model/\" target=\"_blank\" rel=\"noopener\">a-successful-git-branching-model</a>，我们将svn的工作流分为以下几个部分。</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>trunk作为项目的主分支，只维护可发布的稳定代码。开发不在trunk上进行，只有要发布的时候才把代码合并到trunk。</p>\n<p>所有发布都基于trunk的代码进行，发布时新建tag以标记发布代码的快照。</p>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>除了trunk以外，版本库最重要的一个分支是dev分支。dev分支主要用于日常的开发工作。除了release和fix bug的分支，其他的分支不直接合并到trunk，而是合并到dev分支。</p>\n<h3 id=\"预发布\"><a href=\"#预发布\" class=\"headerlink\" title=\"预发布\"></a>预发布</h3><p>当dev分支的代码处在某个逻辑闭环的稳定状态时，可以基于dev分支新建预发布分支，可以命名为release-*，其中*为要发布的版本号。</p>\n<p>预发布分支经过测试和bug修复稳定下来以后，需要合并回dev分支和trunk，然后trunk的代码可以用于正式发布新的版本。</p>\n<h3 id=\"bug修复\"><a href=\"#bug修复\" class=\"headerlink\" title=\"bug修复\"></a>bug修复</h3><p>当在线上版本发现bug后，基于trunk新建修复特定bug的分支，可以命名为issue-*，其中*部分使用bug追踪系统的bug编号。</p>\n<p>bug修复并测试通过以后，将issue分支合并回trunk和dev分支。</p>\n<h3 id=\"新特性开发\"><a href=\"#新特性开发\" class=\"headerlink\" title=\"新特性开发\"></a>新特性开发</h3><p>当有某种特定的新功能需要开发时，可以在基于dev新建的特定分支上进行，这样的分支可以命名为feature-*，其中*为新特性的代号。</p>\n<p>如果需要包括新特性，则将其合并到dev分支。如果最终不需要的话可以删除此分支。</p>\n<h2 id=\"合\"><a href=\"#合\" class=\"headerlink\" title=\"合\"></a>合</h2><p>基于svn的工作流有很多种，以上只是其中一种实践。这样可以充分隔离开不同的功能和版本之间的代码，在保证开发效率的同时，确保发布代码的稳定性。</p>\n<p>Git的branch和tag、merge操作都更简洁高效，不过目前公司使用的主流工具还是svn，所以本篇博客主要基于svn，不足之处还请大家指出。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ol>\n<li>Vincent Driessen <a href=\"http://nvie.com/posts/a-successful-git-branching-model/\" target=\"_blank\" rel=\"noopener\">a-successful-git-branching-model</a></li>\n<li>ruanyifeng <a href=\"http://www.ruanyifeng.com/blog/2012/07/git.html\" target=\"_blank\" rel=\"noopener\">Git分支管理策略</a></li>\n<li>oldratlee <a href=\"https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/README.md\" target=\"_blank\" rel=\"noopener\">Git工作流指南</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"起\"><a href=\"#起\" class=\"headerlink\" title=\"起\"></a>起</h2><p>这篇博客起源于一次发布事故的反思。五一之前因为修复一个线上bug，紧急发布了一个补丁，结果发布的代码中包含了正在开发中的新功能的代码，导致了线上部分功能受影响，服务出错不可用。</p>","more":"<h2 id=\"承\"><a href=\"#承\" class=\"headerlink\" title=\"承\"></a>承</h2><p>在回滚线上代码并紧急修复了bug之后，我们有必要重新思考一下这次出现的问题。</p>\n<ul>\n<li>代码没有做有效的管理，修复bug的时候没有从trunk新建issue分支</li>\n<li>发布代码上线的时候没有经过充分的测试</li>\n<li>因为是内部产品且所修复模块用户量不大，工程师略有松懈，发布比较仓促</li>\n<li>发布的时候线上代码没有进行备份</li>\n</ul>\n<h2 id=\"转\"><a href=\"#转\" class=\"headerlink\" title=\"转\"></a>转</h2><p>经过反思，我们重新梳理了对svn工作流的管理。</p>\n<p><img src=\"http://nvie.com/img/git-model@2x.png\" alt=\"\" title=\"Vincent Driessen - a-successful-git-branching-model\"></p>\n<p>借鉴 Vincent Driessen 的<a href=\"http://nvie.com/posts/a-successful-git-branching-model/\" target=\"_blank\" rel=\"noopener\">a-successful-git-branching-model</a>，我们将svn的工作流分为以下几个部分。</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>trunk作为项目的主分支，只维护可发布的稳定代码。开发不在trunk上进行，只有要发布的时候才把代码合并到trunk。</p>\n<p>所有发布都基于trunk的代码进行，发布时新建tag以标记发布代码的快照。</p>\n<h3 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h3><p>除了trunk以外，版本库最重要的一个分支是dev分支。dev分支主要用于日常的开发工作。除了release和fix bug的分支，其他的分支不直接合并到trunk，而是合并到dev分支。</p>\n<h3 id=\"预发布\"><a href=\"#预发布\" class=\"headerlink\" title=\"预发布\"></a>预发布</h3><p>当dev分支的代码处在某个逻辑闭环的稳定状态时，可以基于dev分支新建预发布分支，可以命名为release-*，其中*为要发布的版本号。</p>\n<p>预发布分支经过测试和bug修复稳定下来以后，需要合并回dev分支和trunk，然后trunk的代码可以用于正式发布新的版本。</p>\n<h3 id=\"bug修复\"><a href=\"#bug修复\" class=\"headerlink\" title=\"bug修复\"></a>bug修复</h3><p>当在线上版本发现bug后，基于trunk新建修复特定bug的分支，可以命名为issue-*，其中*部分使用bug追踪系统的bug编号。</p>\n<p>bug修复并测试通过以后，将issue分支合并回trunk和dev分支。</p>\n<h3 id=\"新特性开发\"><a href=\"#新特性开发\" class=\"headerlink\" title=\"新特性开发\"></a>新特性开发</h3><p>当有某种特定的新功能需要开发时，可以在基于dev新建的特定分支上进行，这样的分支可以命名为feature-*，其中*为新特性的代号。</p>\n<p>如果需要包括新特性，则将其合并到dev分支。如果最终不需要的话可以删除此分支。</p>\n<h2 id=\"合\"><a href=\"#合\" class=\"headerlink\" title=\"合\"></a>合</h2><p>基于svn的工作流有很多种，以上只是其中一种实践。这样可以充分隔离开不同的功能和版本之间的代码，在保证开发效率的同时，确保发布代码的稳定性。</p>\n<p>Git的branch和tag、merge操作都更简洁高效，不过目前公司使用的主流工具还是svn，所以本篇博客主要基于svn，不足之处还请大家指出。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ol>\n<li>Vincent Driessen <a href=\"http://nvie.com/posts/a-successful-git-branching-model/\" target=\"_blank\" rel=\"noopener\">a-successful-git-branching-model</a></li>\n<li>ruanyifeng <a href=\"http://www.ruanyifeng.com/blog/2012/07/git.html\" target=\"_blank\" rel=\"noopener\">Git分支管理策略</a></li>\n<li>oldratlee <a href=\"https://github.com/oldratlee/translations/blob/master/git-workflows-and-tutorials/README.md\" target=\"_blank\" rel=\"noopener\">Git工作流指南</a></li>\n</ol>"},{"title":"写在2016年的开始","date":"2016-02-19T03:30:05.000Z","_content":"\n## 牢骚\n一晃已经2016年了，又有很长时间没写博客了。\n\n<!-- more -->\n\n这次倒也不是因为什么拖延症或者懒癌之类的，主要是因为自己偷懒，用空闲时间补番了。*(进击的巨人和一拳超人都追上进度了，看完了Fate Stay Night的UBW线，轻松向的看了小埋和南家三姐妹，暗杀教师和路人女主的养成方法也很棒，感谢陪伴我走过2015年的动漫 ~)*，所以一些练手的业余项目没有什么进展，也没学多少东西...而我又不太想写一些自己都觉得没什么意思的内容来凑数，所以就一直放到了现在。\n\n不过一直这么放着我也有点过意不去，毕竟当初搭这个博客的时候，还是抱着很多的期望的，希望自己能坚持学一些东西，并把这个过程记录下来。\n\n写博客也是督促自己的一种方式，也希望通过把知识转化成文字这个过程加深一些理解，毕竟如果要把学到的东西写出来的话，我肯定会把一些比较模糊和不能确定的地方弄清楚才敢写，也不知道这算是优点还是缺点吧。还有就是希望通过博客和别人交流，学习更多的东西，也让自己的内心更加强大。在知乎也遇到过上来就喷的人，开始心里会很不舒服，现在已经看得比较淡了。\n\n既然开头已经写了这么多牢骚，不如这一篇就全写技术无关的吐槽好了。\n\n过去的2015年，我觉得自己的成长还是不小的，技术面扩展了一些，视野更好了一点，现在回头看自己15年初绕的一些弯路觉得也有些可笑，可能是因为起点低吧。不过我已经找到了自己的下一步方向，准备先着手学一些数据分析、Machine Learning相关的东西，还有就是在保证基本的娱乐需求得到满足的情况下，多做一些个人的练习项目，锻炼一下执行力，2015年自己挖的golang的坑还没有填，希望2016年可以填上吧。\n\n过去的2015年，我没有写总结，不过还是努力保证了每个月写几篇日记，大概记录一下自己的生活和想法，再过些年拿出来看想必会很有意思吧。\n\n## 希望\n虽然已经决定要灌一些水进来了，不过还是希望能有一些沉淀下来的东西，正好最近过年有空再看MySQL High Availability,不如就先把学到的东西记录下来写成博客吧。虽然内容会很浅，不过就当是慢慢培养写博客的习惯吧。恩，用这样的理由安慰自己的话，貌似也可以接受了。\n\n希望2016年有一个好的开始。\n","source":"_posts/start-of-2016.md","raw":"title: \"写在2016年的开始\"\ndate: 2016-02-19 11:30:05\ncategories:\n- Life\n---\n\n## 牢骚\n一晃已经2016年了，又有很长时间没写博客了。\n\n<!-- more -->\n\n这次倒也不是因为什么拖延症或者懒癌之类的，主要是因为自己偷懒，用空闲时间补番了。*(进击的巨人和一拳超人都追上进度了，看完了Fate Stay Night的UBW线，轻松向的看了小埋和南家三姐妹，暗杀教师和路人女主的养成方法也很棒，感谢陪伴我走过2015年的动漫 ~)*，所以一些练手的业余项目没有什么进展，也没学多少东西...而我又不太想写一些自己都觉得没什么意思的内容来凑数，所以就一直放到了现在。\n\n不过一直这么放着我也有点过意不去，毕竟当初搭这个博客的时候，还是抱着很多的期望的，希望自己能坚持学一些东西，并把这个过程记录下来。\n\n写博客也是督促自己的一种方式，也希望通过把知识转化成文字这个过程加深一些理解，毕竟如果要把学到的东西写出来的话，我肯定会把一些比较模糊和不能确定的地方弄清楚才敢写，也不知道这算是优点还是缺点吧。还有就是希望通过博客和别人交流，学习更多的东西，也让自己的内心更加强大。在知乎也遇到过上来就喷的人，开始心里会很不舒服，现在已经看得比较淡了。\n\n既然开头已经写了这么多牢骚，不如这一篇就全写技术无关的吐槽好了。\n\n过去的2015年，我觉得自己的成长还是不小的，技术面扩展了一些，视野更好了一点，现在回头看自己15年初绕的一些弯路觉得也有些可笑，可能是因为起点低吧。不过我已经找到了自己的下一步方向，准备先着手学一些数据分析、Machine Learning相关的东西，还有就是在保证基本的娱乐需求得到满足的情况下，多做一些个人的练习项目，锻炼一下执行力，2015年自己挖的golang的坑还没有填，希望2016年可以填上吧。\n\n过去的2015年，我没有写总结，不过还是努力保证了每个月写几篇日记，大概记录一下自己的生活和想法，再过些年拿出来看想必会很有意思吧。\n\n## 希望\n虽然已经决定要灌一些水进来了，不过还是希望能有一些沉淀下来的东西，正好最近过年有空再看MySQL High Availability,不如就先把学到的东西记录下来写成博客吧。虽然内容会很浅，不过就当是慢慢培养写博客的习惯吧。恩，用这样的理由安慰自己的话，貌似也可以接受了。\n\n希望2016年有一个好的开始。\n","slug":"start-of-2016","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o910y000h6bk20kyfqgeq","content":"<h2 id=\"牢骚\"><a href=\"#牢骚\" class=\"headerlink\" title=\"牢骚\"></a>牢骚</h2><p>一晃已经2016年了，又有很长时间没写博客了。</p>\n<a id=\"more\"></a>\n<p>这次倒也不是因为什么拖延症或者懒癌之类的，主要是因为自己偷懒，用空闲时间补番了。<em>(进击的巨人和一拳超人都追上进度了，看完了Fate Stay Night的UBW线，轻松向的看了小埋和南家三姐妹，暗杀教师和路人女主的养成方法也很棒，感谢陪伴我走过2015年的动漫 ~)</em>，所以一些练手的业余项目没有什么进展，也没学多少东西…而我又不太想写一些自己都觉得没什么意思的内容来凑数，所以就一直放到了现在。</p>\n<p>不过一直这么放着我也有点过意不去，毕竟当初搭这个博客的时候，还是抱着很多的期望的，希望自己能坚持学一些东西，并把这个过程记录下来。</p>\n<p>写博客也是督促自己的一种方式，也希望通过把知识转化成文字这个过程加深一些理解，毕竟如果要把学到的东西写出来的话，我肯定会把一些比较模糊和不能确定的地方弄清楚才敢写，也不知道这算是优点还是缺点吧。还有就是希望通过博客和别人交流，学习更多的东西，也让自己的内心更加强大。在知乎也遇到过上来就喷的人，开始心里会很不舒服，现在已经看得比较淡了。</p>\n<p>既然开头已经写了这么多牢骚，不如这一篇就全写技术无关的吐槽好了。</p>\n<p>过去的2015年，我觉得自己的成长还是不小的，技术面扩展了一些，视野更好了一点，现在回头看自己15年初绕的一些弯路觉得也有些可笑，可能是因为起点低吧。不过我已经找到了自己的下一步方向，准备先着手学一些数据分析、Machine Learning相关的东西，还有就是在保证基本的娱乐需求得到满足的情况下，多做一些个人的练习项目，锻炼一下执行力，2015年自己挖的golang的坑还没有填，希望2016年可以填上吧。</p>\n<p>过去的2015年，我没有写总结，不过还是努力保证了每个月写几篇日记，大概记录一下自己的生活和想法，再过些年拿出来看想必会很有意思吧。</p>\n<h2 id=\"希望\"><a href=\"#希望\" class=\"headerlink\" title=\"希望\"></a>希望</h2><p>虽然已经决定要灌一些水进来了，不过还是希望能有一些沉淀下来的东西，正好最近过年有空再看MySQL High Availability,不如就先把学到的东西记录下来写成博客吧。虽然内容会很浅，不过就当是慢慢培养写博客的习惯吧。恩，用这样的理由安慰自己的话，貌似也可以接受了。</p>\n<p>希望2016年有一个好的开始。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"牢骚\"><a href=\"#牢骚\" class=\"headerlink\" title=\"牢骚\"></a>牢骚</h2><p>一晃已经2016年了，又有很长时间没写博客了。</p>","more":"<p>这次倒也不是因为什么拖延症或者懒癌之类的，主要是因为自己偷懒，用空闲时间补番了。<em>(进击的巨人和一拳超人都追上进度了，看完了Fate Stay Night的UBW线，轻松向的看了小埋和南家三姐妹，暗杀教师和路人女主的养成方法也很棒，感谢陪伴我走过2015年的动漫 ~)</em>，所以一些练手的业余项目没有什么进展，也没学多少东西…而我又不太想写一些自己都觉得没什么意思的内容来凑数，所以就一直放到了现在。</p>\n<p>不过一直这么放着我也有点过意不去，毕竟当初搭这个博客的时候，还是抱着很多的期望的，希望自己能坚持学一些东西，并把这个过程记录下来。</p>\n<p>写博客也是督促自己的一种方式，也希望通过把知识转化成文字这个过程加深一些理解，毕竟如果要把学到的东西写出来的话，我肯定会把一些比较模糊和不能确定的地方弄清楚才敢写，也不知道这算是优点还是缺点吧。还有就是希望通过博客和别人交流，学习更多的东西，也让自己的内心更加强大。在知乎也遇到过上来就喷的人，开始心里会很不舒服，现在已经看得比较淡了。</p>\n<p>既然开头已经写了这么多牢骚，不如这一篇就全写技术无关的吐槽好了。</p>\n<p>过去的2015年，我觉得自己的成长还是不小的，技术面扩展了一些，视野更好了一点，现在回头看自己15年初绕的一些弯路觉得也有些可笑，可能是因为起点低吧。不过我已经找到了自己的下一步方向，准备先着手学一些数据分析、Machine Learning相关的东西，还有就是在保证基本的娱乐需求得到满足的情况下，多做一些个人的练习项目，锻炼一下执行力，2015年自己挖的golang的坑还没有填，希望2016年可以填上吧。</p>\n<p>过去的2015年，我没有写总结，不过还是努力保证了每个月写几篇日记，大概记录一下自己的生活和想法，再过些年拿出来看想必会很有意思吧。</p>\n<h2 id=\"希望\"><a href=\"#希望\" class=\"headerlink\" title=\"希望\"></a>希望</h2><p>虽然已经决定要灌一些水进来了，不过还是希望能有一些沉淀下来的东西，正好最近过年有空再看MySQL High Availability,不如就先把学到的东西记录下来写成博客吧。虽然内容会很浅，不过就当是慢慢培养写博客的习惯吧。恩，用这样的理由安慰自己的话，貌似也可以接受了。</p>\n<p>希望2016年有一个好的开始。</p>"},{"title":"taskgo开发手册 -1- 项目结构与命令行参数解析","date":"2015-10-23T02:25:49.000Z","_content":"\n\n## 项目结构\n在设计命令行参数之前，我先折腾了一番项目结构。因为是第一次做GO的项目，所以对build方式不太熟悉，只是知道main包会生成可执行程序，其他的包会生成库。这样的结构对一个只有一个可执行程序的项目来说已经足够了，但是我希望在taskgo的项目中包含server、worker、client三种可执行程序，就需要调整一下项目结构。\n\n<!-- more -->\n\n开始的时候，我给server、worker、client各自创建了一个目录，准备每个目录下面创建一个main package，但是这样的结构因为在项目目录下没有扩展名是go的程序文件，所以没办法直接使用go install构建，也没办法通过go get安装，需要自己写安装脚本，用户安装的时候也更麻烦一些。这和我期望的简单易用不太符合，所以这种方案被暂时搁置。\n\n然后，我参考了etcd的项目结构，准备以server作为项目的主程序，将server的main包放在项目的根目录中。然后server、worker、client的具体实现分别写在对应的库中，worker和client单独创建main包生成工具程序。server可以用go install直接构建，worker和client使用命令单独构建。这样项目的逻辑就更加清晰，单独拆分出来的server、worker、client也更便于复用。\n\n## 命令行参数设计目标\n设计命令行参数的时候，我参考了之前用过的gearman，再结合自己对server的设想，草拟了一份参数表。\n预期的参数包含：\n- h: --help, 输出帮助信息\n- V: --version, 输出版本信息\n- v: --verbose, 调试信息等级，等级越高输出信息越具体。\n- h: --host, server的主机名或ip地址\n- p: --port, server监听的端口号\n- u: --user, 以特定用户的权限执行\n- d: --deamon, 以deamon程序方式运行\n- l: --log, 日志文件路径\n- P: --pid-file, pid文件路径\n- s: --signal, 信号，reload，stop， start\n- r: --retry, job执行失败的重试次数\n- S: --save < seconds > < changes >, 持久化设置\n- 后续待补充\n\n目前只想到了上述的参数，计划按照顺序依次实现。后续持续添加其他需要的参数。\n\n## 实现\n参数解析使用flag包实现，声明一个server config的结构体，然后使用flag解析命令行参数填充。用flagSet定义可能更清楚一些，不过我准备先用flag.xxx的方式实现了。\nflag包貌似不支持‘--xxx’的形式，更复杂的命令行参数解析可以使用[gooptions](https://github.com/voxelbrain/goptions)实现。\n\n之前计划写taskgo的时候是想按照模块设计和记录的，不过拖延症发作，半年一直没有进展，我觉得还是先写一个demo，然后不断调整更实际一些，最近用了Quartz，觉得有很多可以借鉴的地方，后面如果有合适的特性会尽量加进来。\n","source":"_posts/taskgo-dev-note-1.md","raw":"title: \"taskgo开发手册 -1- 项目结构与命令行参数解析\"\ndate: 2015-10-23 10:25:49\ncategories:\n- 开发手册\ntags:\n- golang\n---\n\n\n## 项目结构\n在设计命令行参数之前，我先折腾了一番项目结构。因为是第一次做GO的项目，所以对build方式不太熟悉，只是知道main包会生成可执行程序，其他的包会生成库。这样的结构对一个只有一个可执行程序的项目来说已经足够了，但是我希望在taskgo的项目中包含server、worker、client三种可执行程序，就需要调整一下项目结构。\n\n<!-- more -->\n\n开始的时候，我给server、worker、client各自创建了一个目录，准备每个目录下面创建一个main package，但是这样的结构因为在项目目录下没有扩展名是go的程序文件，所以没办法直接使用go install构建，也没办法通过go get安装，需要自己写安装脚本，用户安装的时候也更麻烦一些。这和我期望的简单易用不太符合，所以这种方案被暂时搁置。\n\n然后，我参考了etcd的项目结构，准备以server作为项目的主程序，将server的main包放在项目的根目录中。然后server、worker、client的具体实现分别写在对应的库中，worker和client单独创建main包生成工具程序。server可以用go install直接构建，worker和client使用命令单独构建。这样项目的逻辑就更加清晰，单独拆分出来的server、worker、client也更便于复用。\n\n## 命令行参数设计目标\n设计命令行参数的时候，我参考了之前用过的gearman，再结合自己对server的设想，草拟了一份参数表。\n预期的参数包含：\n- h: --help, 输出帮助信息\n- V: --version, 输出版本信息\n- v: --verbose, 调试信息等级，等级越高输出信息越具体。\n- h: --host, server的主机名或ip地址\n- p: --port, server监听的端口号\n- u: --user, 以特定用户的权限执行\n- d: --deamon, 以deamon程序方式运行\n- l: --log, 日志文件路径\n- P: --pid-file, pid文件路径\n- s: --signal, 信号，reload，stop， start\n- r: --retry, job执行失败的重试次数\n- S: --save < seconds > < changes >, 持久化设置\n- 后续待补充\n\n目前只想到了上述的参数，计划按照顺序依次实现。后续持续添加其他需要的参数。\n\n## 实现\n参数解析使用flag包实现，声明一个server config的结构体，然后使用flag解析命令行参数填充。用flagSet定义可能更清楚一些，不过我准备先用flag.xxx的方式实现了。\nflag包貌似不支持‘--xxx’的形式，更复杂的命令行参数解析可以使用[gooptions](https://github.com/voxelbrain/goptions)实现。\n\n之前计划写taskgo的时候是想按照模块设计和记录的，不过拖延症发作，半年一直没有进展，我觉得还是先写一个demo，然后不断调整更实际一些，最近用了Quartz，觉得有很多可以借鉴的地方，后面如果有合适的特性会尽量加进来。\n","slug":"taskgo-dev-note-1","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o9110000i6bk2uw1ny0np","content":"<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>在设计命令行参数之前，我先折腾了一番项目结构。因为是第一次做GO的项目，所以对build方式不太熟悉，只是知道main包会生成可执行程序，其他的包会生成库。这样的结构对一个只有一个可执行程序的项目来说已经足够了，但是我希望在taskgo的项目中包含server、worker、client三种可执行程序，就需要调整一下项目结构。</p>\n<a id=\"more\"></a>\n<p>开始的时候，我给server、worker、client各自创建了一个目录，准备每个目录下面创建一个main package，但是这样的结构因为在项目目录下没有扩展名是go的程序文件，所以没办法直接使用go install构建，也没办法通过go get安装，需要自己写安装脚本，用户安装的时候也更麻烦一些。这和我期望的简单易用不太符合，所以这种方案被暂时搁置。</p>\n<p>然后，我参考了etcd的项目结构，准备以server作为项目的主程序，将server的main包放在项目的根目录中。然后server、worker、client的具体实现分别写在对应的库中，worker和client单独创建main包生成工具程序。server可以用go install直接构建，worker和client使用命令单独构建。这样项目的逻辑就更加清晰，单独拆分出来的server、worker、client也更便于复用。</p>\n<h2 id=\"命令行参数设计目标\"><a href=\"#命令行参数设计目标\" class=\"headerlink\" title=\"命令行参数设计目标\"></a>命令行参数设计目标</h2><p>设计命令行参数的时候，我参考了之前用过的gearman，再结合自己对server的设想，草拟了一份参数表。<br>预期的参数包含：</p>\n<ul>\n<li>h: –help, 输出帮助信息</li>\n<li>V: –version, 输出版本信息</li>\n<li>v: –verbose, 调试信息等级，等级越高输出信息越具体。</li>\n<li>h: –host, server的主机名或ip地址</li>\n<li>p: –port, server监听的端口号</li>\n<li>u: –user, 以特定用户的权限执行</li>\n<li>d: –deamon, 以deamon程序方式运行</li>\n<li>l: –log, 日志文件路径</li>\n<li>P: –pid-file, pid文件路径</li>\n<li>s: –signal, 信号，reload，stop， start</li>\n<li>r: –retry, job执行失败的重试次数</li>\n<li>S: –save &lt; seconds &gt; &lt; changes &gt;, 持久化设置</li>\n<li>后续待补充</li>\n</ul>\n<p>目前只想到了上述的参数，计划按照顺序依次实现。后续持续添加其他需要的参数。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>参数解析使用flag包实现，声明一个server config的结构体，然后使用flag解析命令行参数填充。用flagSet定义可能更清楚一些，不过我准备先用flag.xxx的方式实现了。<br>flag包貌似不支持‘–xxx’的形式，更复杂的命令行参数解析可以使用<a href=\"https://github.com/voxelbrain/goptions\" target=\"_blank\" rel=\"noopener\">gooptions</a>实现。</p>\n<p>之前计划写taskgo的时候是想按照模块设计和记录的，不过拖延症发作，半年一直没有进展，我觉得还是先写一个demo，然后不断调整更实际一些，最近用了Quartz，觉得有很多可以借鉴的地方，后面如果有合适的特性会尽量加进来。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h2><p>在设计命令行参数之前，我先折腾了一番项目结构。因为是第一次做GO的项目，所以对build方式不太熟悉，只是知道main包会生成可执行程序，其他的包会生成库。这样的结构对一个只有一个可执行程序的项目来说已经足够了，但是我希望在taskgo的项目中包含server、worker、client三种可执行程序，就需要调整一下项目结构。</p>","more":"<p>开始的时候，我给server、worker、client各自创建了一个目录，准备每个目录下面创建一个main package，但是这样的结构因为在项目目录下没有扩展名是go的程序文件，所以没办法直接使用go install构建，也没办法通过go get安装，需要自己写安装脚本，用户安装的时候也更麻烦一些。这和我期望的简单易用不太符合，所以这种方案被暂时搁置。</p>\n<p>然后，我参考了etcd的项目结构，准备以server作为项目的主程序，将server的main包放在项目的根目录中。然后server、worker、client的具体实现分别写在对应的库中，worker和client单独创建main包生成工具程序。server可以用go install直接构建，worker和client使用命令单独构建。这样项目的逻辑就更加清晰，单独拆分出来的server、worker、client也更便于复用。</p>\n<h2 id=\"命令行参数设计目标\"><a href=\"#命令行参数设计目标\" class=\"headerlink\" title=\"命令行参数设计目标\"></a>命令行参数设计目标</h2><p>设计命令行参数的时候，我参考了之前用过的gearman，再结合自己对server的设想，草拟了一份参数表。<br>预期的参数包含：</p>\n<ul>\n<li>h: –help, 输出帮助信息</li>\n<li>V: –version, 输出版本信息</li>\n<li>v: –verbose, 调试信息等级，等级越高输出信息越具体。</li>\n<li>h: –host, server的主机名或ip地址</li>\n<li>p: –port, server监听的端口号</li>\n<li>u: –user, 以特定用户的权限执行</li>\n<li>d: –deamon, 以deamon程序方式运行</li>\n<li>l: –log, 日志文件路径</li>\n<li>P: –pid-file, pid文件路径</li>\n<li>s: –signal, 信号，reload，stop， start</li>\n<li>r: –retry, job执行失败的重试次数</li>\n<li>S: –save &lt; seconds &gt; &lt; changes &gt;, 持久化设置</li>\n<li>后续待补充</li>\n</ul>\n<p>目前只想到了上述的参数，计划按照顺序依次实现。后续持续添加其他需要的参数。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>参数解析使用flag包实现，声明一个server config的结构体，然后使用flag解析命令行参数填充。用flagSet定义可能更清楚一些，不过我准备先用flag.xxx的方式实现了。<br>flag包貌似不支持‘–xxx’的形式，更复杂的命令行参数解析可以使用<a href=\"https://github.com/voxelbrain/goptions\" target=\"_blank\" rel=\"noopener\">gooptions</a>实现。</p>\n<p>之前计划写taskgo的时候是想按照模块设计和记录的，不过拖延症发作，半年一直没有进展，我觉得还是先写一个demo，然后不断调整更实际一些，最近用了Quartz，觉得有很多可以借鉴的地方，后面如果有合适的特性会尽量加进来。</p>"},{"title":"taskgo开发手册 -0- origin","date":"2015-05-03T03:17:47.000Z","_content":"\n## 缘起\n很早以前就听过Go，不过一直没有接触过。最近我听了一次Go实践的分享，发现Go做偏底层的开发也很适合，比C/C++更简单易用，性能损失也不大，于是决定补一下自己的短板，用Go写一个软件。经过一番考虑，我决定用Go仿写Gearman。所以就有了这个taskgo开发手册系列。\n\n<!-- more -->\n## 思路\n之所以选择仿写Gearman，一方面是觉得这个软件涵盖了我想练习的几个方面，包括类似master-slave的拓扑结构维护、消息队列、数据持久化、多语言兼容协议等。另一方面也觉得这个软件的核心功能实现起来应该不太难，比较适合上手，而如果完成了基本的功能，又有可扩展的空间。\n\n根据我现在的设想，taskgo的基本功能如下：\n- 单task server，多task worker模式\n- task server 维护单任务队列\n\n\n扩展功能可能包括：\n- 多task server，多task server模式\n- 多任务队列\n- 多种优先级\n- 数据持久化\n- 外部产品数据持久化支持（例如redis，mysql）\n- 二进制日志、故障恢复\n- task monitor（task server 和 task worker状态监控）\n- 其他后续补充\n\n## 启航\n虽然这可能是一个很漫长的过程，但是我希望可以一边开发一边学习，最终把这篇博客挖出来的坑填上。希望在这个过程中有所收获，一路坚持下去！\n\\#2015 我的Go语言之旅\\#\n","source":"_posts/taskgo-dev-note-0.md","raw":"title: \"taskgo开发手册 -0- origin\"\ndate: 2015-05-03 11:17:47\ncategories:\n- 开发手册\ntags:\n- golang\n---\n\n## 缘起\n很早以前就听过Go，不过一直没有接触过。最近我听了一次Go实践的分享，发现Go做偏底层的开发也很适合，比C/C++更简单易用，性能损失也不大，于是决定补一下自己的短板，用Go写一个软件。经过一番考虑，我决定用Go仿写Gearman。所以就有了这个taskgo开发手册系列。\n\n<!-- more -->\n## 思路\n之所以选择仿写Gearman，一方面是觉得这个软件涵盖了我想练习的几个方面，包括类似master-slave的拓扑结构维护、消息队列、数据持久化、多语言兼容协议等。另一方面也觉得这个软件的核心功能实现起来应该不太难，比较适合上手，而如果完成了基本的功能，又有可扩展的空间。\n\n根据我现在的设想，taskgo的基本功能如下：\n- 单task server，多task worker模式\n- task server 维护单任务队列\n\n\n扩展功能可能包括：\n- 多task server，多task server模式\n- 多任务队列\n- 多种优先级\n- 数据持久化\n- 外部产品数据持久化支持（例如redis，mysql）\n- 二进制日志、故障恢复\n- task monitor（task server 和 task worker状态监控）\n- 其他后续补充\n\n## 启航\n虽然这可能是一个很漫长的过程，但是我希望可以一边开发一边学习，最终把这篇博客挖出来的坑填上。希望在这个过程中有所收获，一路坚持下去！\n\\#2015 我的Go语言之旅\\#\n","slug":"taskgo-dev-note-0","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o9113000m6bk2pr5e1b7b","content":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>很早以前就听过Go，不过一直没有接触过。最近我听了一次Go实践的分享，发现Go做偏底层的开发也很适合，比C/C++更简单易用，性能损失也不大，于是决定补一下自己的短板，用Go写一个软件。经过一番考虑，我决定用Go仿写Gearman。所以就有了这个taskgo开发手册系列。</p>\n<a id=\"more\"></a>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>之所以选择仿写Gearman，一方面是觉得这个软件涵盖了我想练习的几个方面，包括类似master-slave的拓扑结构维护、消息队列、数据持久化、多语言兼容协议等。另一方面也觉得这个软件的核心功能实现起来应该不太难，比较适合上手，而如果完成了基本的功能，又有可扩展的空间。</p>\n<p>根据我现在的设想，taskgo的基本功能如下：</p>\n<ul>\n<li>单task server，多task worker模式</li>\n<li>task server 维护单任务队列</li>\n</ul>\n<p>扩展功能可能包括：</p>\n<ul>\n<li>多task server，多task server模式</li>\n<li>多任务队列</li>\n<li>多种优先级</li>\n<li>数据持久化</li>\n<li>外部产品数据持久化支持（例如redis，mysql）</li>\n<li>二进制日志、故障恢复</li>\n<li>task monitor（task server 和 task worker状态监控）</li>\n<li>其他后续补充</li>\n</ul>\n<h2 id=\"启航\"><a href=\"#启航\" class=\"headerlink\" title=\"启航\"></a>启航</h2><p>虽然这可能是一个很漫长的过程，但是我希望可以一边开发一边学习，最终把这篇博客挖出来的坑填上。希望在这个过程中有所收获，一路坚持下去！<br>#2015 我的Go语言之旅#</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>很早以前就听过Go，不过一直没有接触过。最近我听了一次Go实践的分享，发现Go做偏底层的开发也很适合，比C/C++更简单易用，性能损失也不大，于是决定补一下自己的短板，用Go写一个软件。经过一番考虑，我决定用Go仿写Gearman。所以就有了这个taskgo开发手册系列。</p>","more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>之所以选择仿写Gearman，一方面是觉得这个软件涵盖了我想练习的几个方面，包括类似master-slave的拓扑结构维护、消息队列、数据持久化、多语言兼容协议等。另一方面也觉得这个软件的核心功能实现起来应该不太难，比较适合上手，而如果完成了基本的功能，又有可扩展的空间。</p>\n<p>根据我现在的设想，taskgo的基本功能如下：</p>\n<ul>\n<li>单task server，多task worker模式</li>\n<li>task server 维护单任务队列</li>\n</ul>\n<p>扩展功能可能包括：</p>\n<ul>\n<li>多task server，多task server模式</li>\n<li>多任务队列</li>\n<li>多种优先级</li>\n<li>数据持久化</li>\n<li>外部产品数据持久化支持（例如redis，mysql）</li>\n<li>二进制日志、故障恢复</li>\n<li>task monitor（task server 和 task worker状态监控）</li>\n<li>其他后续补充</li>\n</ul>\n<h2 id=\"启航\"><a href=\"#启航\" class=\"headerlink\" title=\"启航\"></a>启航</h2><p>虽然这可能是一个很漫长的过程，但是我希望可以一边开发一边学习，最终把这篇博客挖出来的坑填上。希望在这个过程中有所收获，一路坚持下去！<br>#2015 我的Go语言之旅#</p>"},{"title":"tmux安装配置记录","date":"2015-07-22T08:52:16.000Z","_content":"\n之前早就听过screen，一直没有尝试，今天有空准备试用一下。然而搜索screen相关教程的时候，看到很多tmux和screen的对比<sup>[\\[1\\]](#ref1) [\\[2\\]](#ref2)</sup>，大家普遍对tmux评价很高，认为可以作为screen的替代品，而且tmux的pane划分也很吸引我，于是我决定直接从tmux开始上手。\n\n<!-- more -->\n\n之前我也在James Pan的博客<sup>[\\[3\\]](#ref3)</sup>和其他别的博客里面看到过tmux相关的文章，不过一直没有什么直观的感受，这次一边安装配置，一边又重新看了之前读过的博客。感觉之前看过的东西完全没有留下印象，直到这一次动手试了才有比较直观的感受，果然是生命在于折腾。\n\ntmux最吸引我的地方是session deattch和attach。因为工作过程中需要保持多个ssh连接，每天上班开始都要新建这些连接，而且往往吃完午饭回来就发现都断开了，又要重新连接，之前的工作状态完全被打断。所以希望通过tmux保留工作环境。其次才是pane分块带来的一些效率提升和乐趣。\n\n## 安装\n我在自己用的Ubuntu上面用apt-get安装的tmux，比较简单。但是公司的CentOS上的yum没有找到tmux，所以使用源码安装。\n\ntmux需要libeven2.0.10以上版本，所以我先安装了libevent2.0.22，然后在tmux目录执行configure的时候指明了gcc compiler的include路径和linker的library路径，具体命令如下：\n```\nCFLAGS=\"-I/usr/local/libevent2/include\" LDFLAGS=\"-L/usr/local/libevent2/lib\" ./configure --prefix=/usr/local/tmux\n```\n\n执行tmux的时候找不到libevent2.so.5，在/usr/lib64建立了软连接后运行成功。\n\n\n## 配置\ntmux的默认配置文件在~/.tmux.conf，已经有很多人提供了自己的配置，我参考了几份配置文件以后整理了一份还算易用的配置。\n\n```\n#此类配置可以在命令行模式中输入show-options -g查询\nset-option -g base-index 1                        #窗口的初始序号；默认为0，这里设置为1\nset-option -g display-time 5000                   #提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒\nset-option -g repeat-time 1000                    #控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒\n#set-option -g status-interval 1                  #状态栏刷新频率\nset-option -g status-keys vi                      #操作状态栏时的默认键盘布局；可以设置为vi或emacs\nset-option -g status-utf8 on                      #开启状态栏的UTF-8支持\nset-option -g history-limit 65535                 #历史行数\nset-option -g status on                           #显示状态栏\nset-option -g mouse-select-pane on                #鼠标可以选中pane\nset-option -g status-bg black                     #状态栏背景色\nset-option -g status-fg cyan                      #状态栏前景色\nset-option -g message-attr dim                    #\n\n\n#此类设置可以在命令行模式中输入show-window-options -g查询\nset-window-option -g mode-keys vi                 #复制模式中的默认键盘布局；可以设置为vi或emacs\nset-window-option -g utf8 on                      #开启窗口的UTF-8支持\nset-window-option -g pane-base-index 1            #pane初始序号，默认为0，设置为1\nset-window-option -g mode-mouse on                #鼠标滚轮可以使用\nset-window-option -g window-status-fg red         #窗口状态栏前景色\nset-window-option -g window-status-bg default     #窗口状态栏背景色\nset-window-option -g window-status-attr dim       #\n\n#-- colorscheme --#\n# statusbar\nset-option -g status-left '#[fg=red] [#[fg=blue]#I #[fg=red]]#[default]'\nset-option -g status-right \"#[fg=red][ #[fg=green]%H:%M #[fg=blue]%a %m-%d #[fg=red]] #[default]\"\nset-window-option -g window-status-format '#[fg=blue,bold]#I #T#[default] '\nset-window-option -g window-status-current-format '#[fg=red] [#[fg=green]#I #T#[fg=red]]#[default] '\nset-option -g status-left-length 40\nset-option -g status-right-length 25\n\n\n#-- bindkeys --#\n# prefix key (Ctrl+a)\nset-option -g prefix ^a\nunbind ^b\nbind a send-prefix\n\n# select pane\nbind k selectp -U # above (prefix k)\nbind j selectp -D # below (prefix j)\nbind h selectp -L # left (prefix h)\nbind l selectp -R # right (prefix l)\n```\n\n## 脚本\ntmux可以进入命令行模式，快捷键为:，详细的可用命令与说明可以参考man page<sup>[\\[4\\]](#4)</sup>。\n\ntmux命令可以写成脚本，并通过配置文件将执行脚本命令（source-file）绑定到某个按键，从而实现快速设置工作环境等目标。\n\n此外，tmux的命令也支持通过tmux + command的方式在shell环境调用，所以也可以将一系列tmux命令写为bash脚本的方式简化常用的初始化类操作。\n\n## ending\n在写这篇博客的时候，通过James Pan的文章发现了[Poweline-vim](https://github.com/Lokaltog/vim-powerline)，一款很强大很漂亮的vim工具栏插件，tmux貌似也能用上。我是个不折不扣的工具控，比较喜欢折腾，一定要找机会试一试。不过现在已经用了不少时间了，堆了一些待办的事情，只能往后推一推了。\n\n\n## reference\n<span id=\"ref1\">1.toy [从 screen 切换到 tmux](https://linuxtoy.org/archives/from-screen-to-tmux.html)</span>\n<span id=\"ref2\">2.foocoder [终端环境之tmux](http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/)</span>\n<span id=\"ref3\">3.James Pan [Tmux、Luit 杂谈](http://blog.jamespan.me/2015/06/12/luit-with-tmux/)</span>\n<span id=\"ref4\">4.[linux man page](http://linux.die.net/man/1/tmux)</span>","source":"_posts/tmux-install-and-config.md","raw":"title: \"tmux安装配置记录\"\ndate: 2015-07-22 16:52:16\ncategories:\n- study\ntags:\n- tools\n---\n\n之前早就听过screen，一直没有尝试，今天有空准备试用一下。然而搜索screen相关教程的时候，看到很多tmux和screen的对比<sup>[\\[1\\]](#ref1) [\\[2\\]](#ref2)</sup>，大家普遍对tmux评价很高，认为可以作为screen的替代品，而且tmux的pane划分也很吸引我，于是我决定直接从tmux开始上手。\n\n<!-- more -->\n\n之前我也在James Pan的博客<sup>[\\[3\\]](#ref3)</sup>和其他别的博客里面看到过tmux相关的文章，不过一直没有什么直观的感受，这次一边安装配置，一边又重新看了之前读过的博客。感觉之前看过的东西完全没有留下印象，直到这一次动手试了才有比较直观的感受，果然是生命在于折腾。\n\ntmux最吸引我的地方是session deattch和attach。因为工作过程中需要保持多个ssh连接，每天上班开始都要新建这些连接，而且往往吃完午饭回来就发现都断开了，又要重新连接，之前的工作状态完全被打断。所以希望通过tmux保留工作环境。其次才是pane分块带来的一些效率提升和乐趣。\n\n## 安装\n我在自己用的Ubuntu上面用apt-get安装的tmux，比较简单。但是公司的CentOS上的yum没有找到tmux，所以使用源码安装。\n\ntmux需要libeven2.0.10以上版本，所以我先安装了libevent2.0.22，然后在tmux目录执行configure的时候指明了gcc compiler的include路径和linker的library路径，具体命令如下：\n```\nCFLAGS=\"-I/usr/local/libevent2/include\" LDFLAGS=\"-L/usr/local/libevent2/lib\" ./configure --prefix=/usr/local/tmux\n```\n\n执行tmux的时候找不到libevent2.so.5，在/usr/lib64建立了软连接后运行成功。\n\n\n## 配置\ntmux的默认配置文件在~/.tmux.conf，已经有很多人提供了自己的配置，我参考了几份配置文件以后整理了一份还算易用的配置。\n\n```\n#此类配置可以在命令行模式中输入show-options -g查询\nset-option -g base-index 1                        #窗口的初始序号；默认为0，这里设置为1\nset-option -g display-time 5000                   #提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒\nset-option -g repeat-time 1000                    #控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒\n#set-option -g status-interval 1                  #状态栏刷新频率\nset-option -g status-keys vi                      #操作状态栏时的默认键盘布局；可以设置为vi或emacs\nset-option -g status-utf8 on                      #开启状态栏的UTF-8支持\nset-option -g history-limit 65535                 #历史行数\nset-option -g status on                           #显示状态栏\nset-option -g mouse-select-pane on                #鼠标可以选中pane\nset-option -g status-bg black                     #状态栏背景色\nset-option -g status-fg cyan                      #状态栏前景色\nset-option -g message-attr dim                    #\n\n\n#此类设置可以在命令行模式中输入show-window-options -g查询\nset-window-option -g mode-keys vi                 #复制模式中的默认键盘布局；可以设置为vi或emacs\nset-window-option -g utf8 on                      #开启窗口的UTF-8支持\nset-window-option -g pane-base-index 1            #pane初始序号，默认为0，设置为1\nset-window-option -g mode-mouse on                #鼠标滚轮可以使用\nset-window-option -g window-status-fg red         #窗口状态栏前景色\nset-window-option -g window-status-bg default     #窗口状态栏背景色\nset-window-option -g window-status-attr dim       #\n\n#-- colorscheme --#\n# statusbar\nset-option -g status-left '#[fg=red] [#[fg=blue]#I #[fg=red]]#[default]'\nset-option -g status-right \"#[fg=red][ #[fg=green]%H:%M #[fg=blue]%a %m-%d #[fg=red]] #[default]\"\nset-window-option -g window-status-format '#[fg=blue,bold]#I #T#[default] '\nset-window-option -g window-status-current-format '#[fg=red] [#[fg=green]#I #T#[fg=red]]#[default] '\nset-option -g status-left-length 40\nset-option -g status-right-length 25\n\n\n#-- bindkeys --#\n# prefix key (Ctrl+a)\nset-option -g prefix ^a\nunbind ^b\nbind a send-prefix\n\n# select pane\nbind k selectp -U # above (prefix k)\nbind j selectp -D # below (prefix j)\nbind h selectp -L # left (prefix h)\nbind l selectp -R # right (prefix l)\n```\n\n## 脚本\ntmux可以进入命令行模式，快捷键为:，详细的可用命令与说明可以参考man page<sup>[\\[4\\]](#4)</sup>。\n\ntmux命令可以写成脚本，并通过配置文件将执行脚本命令（source-file）绑定到某个按键，从而实现快速设置工作环境等目标。\n\n此外，tmux的命令也支持通过tmux + command的方式在shell环境调用，所以也可以将一系列tmux命令写为bash脚本的方式简化常用的初始化类操作。\n\n## ending\n在写这篇博客的时候，通过James Pan的文章发现了[Poweline-vim](https://github.com/Lokaltog/vim-powerline)，一款很强大很漂亮的vim工具栏插件，tmux貌似也能用上。我是个不折不扣的工具控，比较喜欢折腾，一定要找机会试一试。不过现在已经用了不少时间了，堆了一些待办的事情，只能往后推一推了。\n\n\n## reference\n<span id=\"ref1\">1.toy [从 screen 切换到 tmux](https://linuxtoy.org/archives/from-screen-to-tmux.html)</span>\n<span id=\"ref2\">2.foocoder [终端环境之tmux](http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/)</span>\n<span id=\"ref3\">3.James Pan [Tmux、Luit 杂谈](http://blog.jamespan.me/2015/06/12/luit-with-tmux/)</span>\n<span id=\"ref4\">4.[linux man page](http://linux.die.net/man/1/tmux)</span>","slug":"tmux-install-and-config","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o9114000n6bk2qv5yzeht","content":"<p>之前早就听过screen，一直没有尝试，今天有空准备试用一下。然而搜索screen相关教程的时候，看到很多tmux和screen的对比<sup><a href=\"#ref1\">[1]</a> <a href=\"#ref2\">[2]</a></sup>，大家普遍对tmux评价很高，认为可以作为screen的替代品，而且tmux的pane划分也很吸引我，于是我决定直接从tmux开始上手。</p>\n<a id=\"more\"></a>\n<p>之前我也在James Pan的博客<sup><a href=\"#ref3\">[3]</a></sup>和其他别的博客里面看到过tmux相关的文章，不过一直没有什么直观的感受，这次一边安装配置，一边又重新看了之前读过的博客。感觉之前看过的东西完全没有留下印象，直到这一次动手试了才有比较直观的感受，果然是生命在于折腾。</p>\n<p>tmux最吸引我的地方是session deattch和attach。因为工作过程中需要保持多个ssh连接，每天上班开始都要新建这些连接，而且往往吃完午饭回来就发现都断开了，又要重新连接，之前的工作状态完全被打断。所以希望通过tmux保留工作环境。其次才是pane分块带来的一些效率提升和乐趣。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我在自己用的Ubuntu上面用apt-get安装的tmux，比较简单。但是公司的CentOS上的yum没有找到tmux，所以使用源码安装。</p>\n<p>tmux需要libeven2.0.10以上版本，所以我先安装了libevent2.0.22，然后在tmux目录执行configure的时候指明了gcc compiler的include路径和linker的library路径，具体命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFLAGS=&quot;-I/usr/local/libevent2/include&quot; LDFLAGS=&quot;-L/usr/local/libevent2/lib&quot; ./configure --prefix=/usr/local/tmux</span><br></pre></td></tr></table></figure></p>\n<p>执行tmux的时候找不到libevent2.so.5，在/usr/lib64建立了软连接后运行成功。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>tmux的默认配置文件在~/.tmux.conf，已经有很多人提供了自己的配置，我参考了几份配置文件以后整理了一份还算易用的配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#此类配置可以在命令行模式中输入show-options -g查询</span><br><span class=\"line\">set-option -g base-index 1                        #窗口的初始序号；默认为0，这里设置为1</span><br><span class=\"line\">set-option -g display-time 5000                   #提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒</span><br><span class=\"line\">set-option -g repeat-time 1000                    #控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒</span><br><span class=\"line\">#set-option -g status-interval 1                  #状态栏刷新频率</span><br><span class=\"line\">set-option -g status-keys vi                      #操作状态栏时的默认键盘布局；可以设置为vi或emacs</span><br><span class=\"line\">set-option -g status-utf8 on                      #开启状态栏的UTF-8支持</span><br><span class=\"line\">set-option -g history-limit 65535                 #历史行数</span><br><span class=\"line\">set-option -g status on                           #显示状态栏</span><br><span class=\"line\">set-option -g mouse-select-pane on                #鼠标可以选中pane</span><br><span class=\"line\">set-option -g status-bg black                     #状态栏背景色</span><br><span class=\"line\">set-option -g status-fg cyan                      #状态栏前景色</span><br><span class=\"line\">set-option -g message-attr dim                    #</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#此类设置可以在命令行模式中输入show-window-options -g查询</span><br><span class=\"line\">set-window-option -g mode-keys vi                 #复制模式中的默认键盘布局；可以设置为vi或emacs</span><br><span class=\"line\">set-window-option -g utf8 on                      #开启窗口的UTF-8支持</span><br><span class=\"line\">set-window-option -g pane-base-index 1            #pane初始序号，默认为0，设置为1</span><br><span class=\"line\">set-window-option -g mode-mouse on                #鼠标滚轮可以使用</span><br><span class=\"line\">set-window-option -g window-status-fg red         #窗口状态栏前景色</span><br><span class=\"line\">set-window-option -g window-status-bg default     #窗口状态栏背景色</span><br><span class=\"line\">set-window-option -g window-status-attr dim       #</span><br><span class=\"line\"></span><br><span class=\"line\">#-- colorscheme --#</span><br><span class=\"line\"># statusbar</span><br><span class=\"line\">set-option -g status-left &apos;#[fg=red] [#[fg=blue]#I #[fg=red]]#[default]&apos;</span><br><span class=\"line\">set-option -g status-right &quot;#[fg=red][ #[fg=green]%H:%M #[fg=blue]%a %m-%d #[fg=red]] #[default]&quot;</span><br><span class=\"line\">set-window-option -g window-status-format &apos;#[fg=blue,bold]#I #T#[default] &apos;</span><br><span class=\"line\">set-window-option -g window-status-current-format &apos;#[fg=red] [#[fg=green]#I #T#[fg=red]]#[default] &apos;</span><br><span class=\"line\">set-option -g status-left-length 40</span><br><span class=\"line\">set-option -g status-right-length 25</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#-- bindkeys --#</span><br><span class=\"line\"># prefix key (Ctrl+a)</span><br><span class=\"line\">set-option -g prefix ^a</span><br><span class=\"line\">unbind ^b</span><br><span class=\"line\">bind a send-prefix</span><br><span class=\"line\"></span><br><span class=\"line\"># select pane</span><br><span class=\"line\">bind k selectp -U # above (prefix k)</span><br><span class=\"line\">bind j selectp -D # below (prefix j)</span><br><span class=\"line\">bind h selectp -L # left (prefix h)</span><br><span class=\"line\">bind l selectp -R # right (prefix l)</span><br></pre></td></tr></table></figure>\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><p>tmux可以进入命令行模式，快捷键为:，详细的可用命令与说明可以参考man page<sup><a href=\"#4\">[4]</a></sup>。</p>\n<p>tmux命令可以写成脚本，并通过配置文件将执行脚本命令（source-file）绑定到某个按键，从而实现快速设置工作环境等目标。</p>\n<p>此外，tmux的命令也支持通过tmux + command的方式在shell环境调用，所以也可以将一系列tmux命令写为bash脚本的方式简化常用的初始化类操作。</p>\n<h2 id=\"ending\"><a href=\"#ending\" class=\"headerlink\" title=\"ending\"></a>ending</h2><p>在写这篇博客的时候，通过James Pan的文章发现了<a href=\"https://github.com/Lokaltog/vim-powerline\" target=\"_blank\" rel=\"noopener\">Poweline-vim</a>，一款很强大很漂亮的vim工具栏插件，tmux貌似也能用上。我是个不折不扣的工具控，比较喜欢折腾，一定要找机会试一试。不过现在已经用了不少时间了，堆了一些待办的事情，只能往后推一推了。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><span id=\"ref1\">1.toy <a href=\"https://linuxtoy.org/archives/from-screen-to-tmux.html\" target=\"_blank\" rel=\"noopener\">从 screen 切换到 tmux</a></span><br><span id=\"ref2\">2.foocoder <a href=\"http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/\" target=\"_blank\" rel=\"noopener\">终端环境之tmux</a></span><br><span id=\"ref3\">3.James Pan <a href=\"http://blog.jamespan.me/2015/06/12/luit-with-tmux/\" target=\"_blank\" rel=\"noopener\">Tmux、Luit 杂谈</a></span><br><span id=\"ref4\">4.<a href=\"http://linux.die.net/man/1/tmux\" target=\"_blank\" rel=\"noopener\">linux man page</a></span></p>\n","site":{"data":{}},"excerpt":"<p>之前早就听过screen，一直没有尝试，今天有空准备试用一下。然而搜索screen相关教程的时候，看到很多tmux和screen的对比<sup><a href=\"#ref1\">[1]</a> <a href=\"#ref2\">[2]</a></sup>，大家普遍对tmux评价很高，认为可以作为screen的替代品，而且tmux的pane划分也很吸引我，于是我决定直接从tmux开始上手。</p>","more":"<p>之前我也在James Pan的博客<sup><a href=\"#ref3\">[3]</a></sup>和其他别的博客里面看到过tmux相关的文章，不过一直没有什么直观的感受，这次一边安装配置，一边又重新看了之前读过的博客。感觉之前看过的东西完全没有留下印象，直到这一次动手试了才有比较直观的感受，果然是生命在于折腾。</p>\n<p>tmux最吸引我的地方是session deattch和attach。因为工作过程中需要保持多个ssh连接，每天上班开始都要新建这些连接，而且往往吃完午饭回来就发现都断开了，又要重新连接，之前的工作状态完全被打断。所以希望通过tmux保留工作环境。其次才是pane分块带来的一些效率提升和乐趣。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>我在自己用的Ubuntu上面用apt-get安装的tmux，比较简单。但是公司的CentOS上的yum没有找到tmux，所以使用源码安装。</p>\n<p>tmux需要libeven2.0.10以上版本，所以我先安装了libevent2.0.22，然后在tmux目录执行configure的时候指明了gcc compiler的include路径和linker的library路径，具体命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFLAGS=&quot;-I/usr/local/libevent2/include&quot; LDFLAGS=&quot;-L/usr/local/libevent2/lib&quot; ./configure --prefix=/usr/local/tmux</span><br></pre></td></tr></table></figure></p>\n<p>执行tmux的时候找不到libevent2.so.5，在/usr/lib64建立了软连接后运行成功。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>tmux的默认配置文件在~/.tmux.conf，已经有很多人提供了自己的配置，我参考了几份配置文件以后整理了一份还算易用的配置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#此类配置可以在命令行模式中输入show-options -g查询</span><br><span class=\"line\">set-option -g base-index 1                        #窗口的初始序号；默认为0，这里设置为1</span><br><span class=\"line\">set-option -g display-time 5000                   #提示信息的持续时间；设置足够的时间以避免看不清提示，单位为毫秒</span><br><span class=\"line\">set-option -g repeat-time 1000                    #控制台激活后的持续时间；设置合适的时间以避免每次操作都要先激活控制台，单位为毫秒</span><br><span class=\"line\">#set-option -g status-interval 1                  #状态栏刷新频率</span><br><span class=\"line\">set-option -g status-keys vi                      #操作状态栏时的默认键盘布局；可以设置为vi或emacs</span><br><span class=\"line\">set-option -g status-utf8 on                      #开启状态栏的UTF-8支持</span><br><span class=\"line\">set-option -g history-limit 65535                 #历史行数</span><br><span class=\"line\">set-option -g status on                           #显示状态栏</span><br><span class=\"line\">set-option -g mouse-select-pane on                #鼠标可以选中pane</span><br><span class=\"line\">set-option -g status-bg black                     #状态栏背景色</span><br><span class=\"line\">set-option -g status-fg cyan                      #状态栏前景色</span><br><span class=\"line\">set-option -g message-attr dim                    #</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#此类设置可以在命令行模式中输入show-window-options -g查询</span><br><span class=\"line\">set-window-option -g mode-keys vi                 #复制模式中的默认键盘布局；可以设置为vi或emacs</span><br><span class=\"line\">set-window-option -g utf8 on                      #开启窗口的UTF-8支持</span><br><span class=\"line\">set-window-option -g pane-base-index 1            #pane初始序号，默认为0，设置为1</span><br><span class=\"line\">set-window-option -g mode-mouse on                #鼠标滚轮可以使用</span><br><span class=\"line\">set-window-option -g window-status-fg red         #窗口状态栏前景色</span><br><span class=\"line\">set-window-option -g window-status-bg default     #窗口状态栏背景色</span><br><span class=\"line\">set-window-option -g window-status-attr dim       #</span><br><span class=\"line\"></span><br><span class=\"line\">#-- colorscheme --#</span><br><span class=\"line\"># statusbar</span><br><span class=\"line\">set-option -g status-left &apos;#[fg=red] [#[fg=blue]#I #[fg=red]]#[default]&apos;</span><br><span class=\"line\">set-option -g status-right &quot;#[fg=red][ #[fg=green]%H:%M #[fg=blue]%a %m-%d #[fg=red]] #[default]&quot;</span><br><span class=\"line\">set-window-option -g window-status-format &apos;#[fg=blue,bold]#I #T#[default] &apos;</span><br><span class=\"line\">set-window-option -g window-status-current-format &apos;#[fg=red] [#[fg=green]#I #T#[fg=red]]#[default] &apos;</span><br><span class=\"line\">set-option -g status-left-length 40</span><br><span class=\"line\">set-option -g status-right-length 25</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#-- bindkeys --#</span><br><span class=\"line\"># prefix key (Ctrl+a)</span><br><span class=\"line\">set-option -g prefix ^a</span><br><span class=\"line\">unbind ^b</span><br><span class=\"line\">bind a send-prefix</span><br><span class=\"line\"></span><br><span class=\"line\"># select pane</span><br><span class=\"line\">bind k selectp -U # above (prefix k)</span><br><span class=\"line\">bind j selectp -D # below (prefix j)</span><br><span class=\"line\">bind h selectp -L # left (prefix h)</span><br><span class=\"line\">bind l selectp -R # right (prefix l)</span><br></pre></td></tr></table></figure>\n<h2 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h2><p>tmux可以进入命令行模式，快捷键为:，详细的可用命令与说明可以参考man page<sup><a href=\"#4\">[4]</a></sup>。</p>\n<p>tmux命令可以写成脚本，并通过配置文件将执行脚本命令（source-file）绑定到某个按键，从而实现快速设置工作环境等目标。</p>\n<p>此外，tmux的命令也支持通过tmux + command的方式在shell环境调用，所以也可以将一系列tmux命令写为bash脚本的方式简化常用的初始化类操作。</p>\n<h2 id=\"ending\"><a href=\"#ending\" class=\"headerlink\" title=\"ending\"></a>ending</h2><p>在写这篇博客的时候，通过James Pan的文章发现了<a href=\"https://github.com/Lokaltog/vim-powerline\" target=\"_blank\" rel=\"noopener\">Poweline-vim</a>，一款很强大很漂亮的vim工具栏插件，tmux貌似也能用上。我是个不折不扣的工具控，比较喜欢折腾，一定要找机会试一试。不过现在已经用了不少时间了，堆了一些待办的事情，只能往后推一推了。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><p><span id=\"ref1\">1.toy <a href=\"https://linuxtoy.org/archives/from-screen-to-tmux.html\" target=\"_blank\" rel=\"noopener\">从 screen 切换到 tmux</a></span><br><span id=\"ref2\">2.foocoder <a href=\"http://foocoder.com/blog/zhong-duan-huan-jing-zhi-tmux.html/\" target=\"_blank\" rel=\"noopener\">终端环境之tmux</a></span><br><span id=\"ref3\">3.James Pan <a href=\"http://blog.jamespan.me/2015/06/12/luit-with-tmux/\" target=\"_blank\" rel=\"noopener\">Tmux、Luit 杂谈</a></span><br><span id=\"ref4\">4.<a href=\"http://linux.die.net/man/1/tmux\" target=\"_blank\" rel=\"noopener\">linux man page</a></span></p>"},{"title":"在项目中使用composer和monolog的记录","date":"2015-09-24T04:39:50.000Z","_content":"\n\n## 缘起\n目前在做一个比较独立的项目模块，有了一定的时间和自主性，所以针对目前项目开发过程中的弊端，我尝试使用一些增加对代码掌控能力的工具。\n\n<!-- more -->\n\n### PHPUnit\n首先在项目中引入的是PHPUnit，之前因为赶工期，开发过程中一直没有引入单元测试。而且因为QA资源比较紧张，所以我们的很多功能都是自己测试的，增加了很多人力成本不说，很多地方测试得还不够细致，导致漏掉了bug。\n\n在这种情况下，单元测试的环节必须得到重视。这样可以减少代码逻辑变更时的重复测试成本，大部分常见问题也可以在这一阶段被发现、解决。\n\nPHPUnit的手册很详尽的记录了不同平台的安装方法，编写测试用例的简单示例以及各种特性，就不再赘述了。\n\n### composer\n在安装PHPUnit的过程中，发现了composer。之前管理第三方库或者组件的时候，一直是手工管理的，版本更新比较麻烦，处理起依赖也不太方便，所以准备以后使用composer管理依赖，正好可以借这次机会尝试。\n\ncomposer的使用比较简单，本地安装后，在项目里增加composer.json文件，里面描述项目的依赖库，然后使用\n<code>php composer.phar install</code>即可将所需库下载到vendor目录下，然后composer会生成一个composer.lock文件，里面记录了已下载的第三方库版本。将这个文件托管到svn或者git，这样在另外一个环境部署的时候，composer会根据composer.lock文件中记录的版本下载指定的第三方库，确保项目稳定运行。\n\n这样看来，composer配合docker，将是搭建开发或测试环境的好方案，可以方便的解决软件环境和项目环境的依赖。有机会可以尝试一下。\n\n如果需要新版本的第三方库，只需执行php composer.phar update或者php composer.phar update [package name]即可更新全部库或指定库，当然不会超过composer.json文件中限制的版本范围。\n\n另外，composer还提供了ventor/autoload.php自动加载类，可以方便的加载用composer安装到ventor目录的依赖。\n\n### monolog\n在安装composer的过程中，发现了monolog，果然生命在于折腾。之前项目里面的日志实现是基于一个简单的写入本地文件的工具类实现的。服务器规模扩展的话将引起日志分散的问题，且缺少错误信息报警机制。\n\nmonolog的安装非常方便，直接使用composer安装即可。如果不使用composer，从github直接下载代码也是可以的。\n\nmonolog的逻辑并不复杂，核心概念只有几项，包括logger, channel, handler, formatter, processors等。学习过程记录如下：\n- logger是日志的记录者，每条日志生成一个record。\n- 创建logger时可以定义一个channel，体现在record的内容中，方便过滤。\n- logger可以有多个handler，通过代理将record的具体处理方法交给handler实现。handler用一个栈存储，添加record的时候由栈顶的handler先处理。每个handler判断新增的record是否符合自己的log level，设定是否允许后续的handler继续处理。\n- 每个handler有一个formatter，formatter可以将record内容清洗为符合handler需求的格式。\n- processors可以添加到logger也可以添加到handler。processor以record为参数，返回处理后的record。processor的逻辑通常是向record的extra数组添加内容。在logger中，processor在handler之前处理record，在handler中，processor在formatter之前处理record。\n\n如图所示：\n![](http://7xiium.com1.z0.glb.clouddn.com/Monolog.png)\n\n\nmonolog提供了很多handler以及相应的formatter和processor，用户还可以根据需要自己添加handler、formatter、processors等，非常灵活。\n\n\n## 后记\n这篇博客拖了好久好久才写完，一方面是因为平时杂事比较多，总觉得腾不出手来写；另一方面也是因为自己执行力不足，很多计划好的事情都没有开始，时间没有用好。\n\n不管怎样，还是要从眼前的事情一点一点做起，坚持写博客，养成总结的习惯，恢复更新，继续上路。","source":"_posts/use-composer-and-monolog-in-project.md","raw":"title: \"在项目中使用composer和monolog的记录\"\ndate: 2015-09-24 12:39:50\ncategories:\n- 工程\ntags:\n- composer\n- monolog\n---\n\n\n## 缘起\n目前在做一个比较独立的项目模块，有了一定的时间和自主性，所以针对目前项目开发过程中的弊端，我尝试使用一些增加对代码掌控能力的工具。\n\n<!-- more -->\n\n### PHPUnit\n首先在项目中引入的是PHPUnit，之前因为赶工期，开发过程中一直没有引入单元测试。而且因为QA资源比较紧张，所以我们的很多功能都是自己测试的，增加了很多人力成本不说，很多地方测试得还不够细致，导致漏掉了bug。\n\n在这种情况下，单元测试的环节必须得到重视。这样可以减少代码逻辑变更时的重复测试成本，大部分常见问题也可以在这一阶段被发现、解决。\n\nPHPUnit的手册很详尽的记录了不同平台的安装方法，编写测试用例的简单示例以及各种特性，就不再赘述了。\n\n### composer\n在安装PHPUnit的过程中，发现了composer。之前管理第三方库或者组件的时候，一直是手工管理的，版本更新比较麻烦，处理起依赖也不太方便，所以准备以后使用composer管理依赖，正好可以借这次机会尝试。\n\ncomposer的使用比较简单，本地安装后，在项目里增加composer.json文件，里面描述项目的依赖库，然后使用\n<code>php composer.phar install</code>即可将所需库下载到vendor目录下，然后composer会生成一个composer.lock文件，里面记录了已下载的第三方库版本。将这个文件托管到svn或者git，这样在另外一个环境部署的时候，composer会根据composer.lock文件中记录的版本下载指定的第三方库，确保项目稳定运行。\n\n这样看来，composer配合docker，将是搭建开发或测试环境的好方案，可以方便的解决软件环境和项目环境的依赖。有机会可以尝试一下。\n\n如果需要新版本的第三方库，只需执行php composer.phar update或者php composer.phar update [package name]即可更新全部库或指定库，当然不会超过composer.json文件中限制的版本范围。\n\n另外，composer还提供了ventor/autoload.php自动加载类，可以方便的加载用composer安装到ventor目录的依赖。\n\n### monolog\n在安装composer的过程中，发现了monolog，果然生命在于折腾。之前项目里面的日志实现是基于一个简单的写入本地文件的工具类实现的。服务器规模扩展的话将引起日志分散的问题，且缺少错误信息报警机制。\n\nmonolog的安装非常方便，直接使用composer安装即可。如果不使用composer，从github直接下载代码也是可以的。\n\nmonolog的逻辑并不复杂，核心概念只有几项，包括logger, channel, handler, formatter, processors等。学习过程记录如下：\n- logger是日志的记录者，每条日志生成一个record。\n- 创建logger时可以定义一个channel，体现在record的内容中，方便过滤。\n- logger可以有多个handler，通过代理将record的具体处理方法交给handler实现。handler用一个栈存储，添加record的时候由栈顶的handler先处理。每个handler判断新增的record是否符合自己的log level，设定是否允许后续的handler继续处理。\n- 每个handler有一个formatter，formatter可以将record内容清洗为符合handler需求的格式。\n- processors可以添加到logger也可以添加到handler。processor以record为参数，返回处理后的record。processor的逻辑通常是向record的extra数组添加内容。在logger中，processor在handler之前处理record，在handler中，processor在formatter之前处理record。\n\n如图所示：\n![](http://7xiium.com1.z0.glb.clouddn.com/Monolog.png)\n\n\nmonolog提供了很多handler以及相应的formatter和processor，用户还可以根据需要自己添加handler、formatter、processors等，非常灵活。\n\n\n## 后记\n这篇博客拖了好久好久才写完，一方面是因为平时杂事比较多，总觉得腾不出手来写；另一方面也是因为自己执行力不足，很多计划好的事情都没有开始，时间没有用好。\n\n不管怎样，还是要从眼前的事情一点一点做起，坚持写博客，养成总结的习惯，恢复更新，继续上路。","slug":"use-composer-and-monolog-in-project","published":1,"updated":"2017-11-29T07:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjd9o9115000r6bk27zgdd5dc","content":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>目前在做一个比较独立的项目模块，有了一定的时间和自主性，所以针对目前项目开发过程中的弊端，我尝试使用一些增加对代码掌控能力的工具。</p>\n<a id=\"more\"></a>\n<h3 id=\"PHPUnit\"><a href=\"#PHPUnit\" class=\"headerlink\" title=\"PHPUnit\"></a>PHPUnit</h3><p>首先在项目中引入的是PHPUnit，之前因为赶工期，开发过程中一直没有引入单元测试。而且因为QA资源比较紧张，所以我们的很多功能都是自己测试的，增加了很多人力成本不说，很多地方测试得还不够细致，导致漏掉了bug。</p>\n<p>在这种情况下，单元测试的环节必须得到重视。这样可以减少代码逻辑变更时的重复测试成本，大部分常见问题也可以在这一阶段被发现、解决。</p>\n<p>PHPUnit的手册很详尽的记录了不同平台的安装方法，编写测试用例的简单示例以及各种特性，就不再赘述了。</p>\n<h3 id=\"composer\"><a href=\"#composer\" class=\"headerlink\" title=\"composer\"></a>composer</h3><p>在安装PHPUnit的过程中，发现了composer。之前管理第三方库或者组件的时候，一直是手工管理的，版本更新比较麻烦，处理起依赖也不太方便，所以准备以后使用composer管理依赖，正好可以借这次机会尝试。</p>\n<p>composer的使用比较简单，本地安装后，在项目里增加composer.json文件，里面描述项目的依赖库，然后使用<br><code>php composer.phar install</code>即可将所需库下载到vendor目录下，然后composer会生成一个composer.lock文件，里面记录了已下载的第三方库版本。将这个文件托管到svn或者git，这样在另外一个环境部署的时候，composer会根据composer.lock文件中记录的版本下载指定的第三方库，确保项目稳定运行。</p>\n<p>这样看来，composer配合docker，将是搭建开发或测试环境的好方案，可以方便的解决软件环境和项目环境的依赖。有机会可以尝试一下。</p>\n<p>如果需要新版本的第三方库，只需执行php composer.phar update或者php composer.phar update [package name]即可更新全部库或指定库，当然不会超过composer.json文件中限制的版本范围。</p>\n<p>另外，composer还提供了ventor/autoload.php自动加载类，可以方便的加载用composer安装到ventor目录的依赖。</p>\n<h3 id=\"monolog\"><a href=\"#monolog\" class=\"headerlink\" title=\"monolog\"></a>monolog</h3><p>在安装composer的过程中，发现了monolog，果然生命在于折腾。之前项目里面的日志实现是基于一个简单的写入本地文件的工具类实现的。服务器规模扩展的话将引起日志分散的问题，且缺少错误信息报警机制。</p>\n<p>monolog的安装非常方便，直接使用composer安装即可。如果不使用composer，从github直接下载代码也是可以的。</p>\n<p>monolog的逻辑并不复杂，核心概念只有几项，包括logger, channel, handler, formatter, processors等。学习过程记录如下：</p>\n<ul>\n<li>logger是日志的记录者，每条日志生成一个record。</li>\n<li>创建logger时可以定义一个channel，体现在record的内容中，方便过滤。</li>\n<li>logger可以有多个handler，通过代理将record的具体处理方法交给handler实现。handler用一个栈存储，添加record的时候由栈顶的handler先处理。每个handler判断新增的record是否符合自己的log level，设定是否允许后续的handler继续处理。</li>\n<li>每个handler有一个formatter，formatter可以将record内容清洗为符合handler需求的格式。</li>\n<li>processors可以添加到logger也可以添加到handler。processor以record为参数，返回处理后的record。processor的逻辑通常是向record的extra数组添加内容。在logger中，processor在handler之前处理record，在handler中，processor在formatter之前处理record。</li>\n</ul>\n<p>如图所示：<br><img src=\"http://7xiium.com1.z0.glb.clouddn.com/Monolog.png\" alt=\"\"></p>\n<p>monolog提供了很多handler以及相应的formatter和processor，用户还可以根据需要自己添加handler、formatter、processors等，非常灵活。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这篇博客拖了好久好久才写完，一方面是因为平时杂事比较多，总觉得腾不出手来写；另一方面也是因为自己执行力不足，很多计划好的事情都没有开始，时间没有用好。</p>\n<p>不管怎样，还是要从眼前的事情一点一点做起，坚持写博客，养成总结的习惯，恢复更新，继续上路。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>目前在做一个比较独立的项目模块，有了一定的时间和自主性，所以针对目前项目开发过程中的弊端，我尝试使用一些增加对代码掌控能力的工具。</p>","more":"<h3 id=\"PHPUnit\"><a href=\"#PHPUnit\" class=\"headerlink\" title=\"PHPUnit\"></a>PHPUnit</h3><p>首先在项目中引入的是PHPUnit，之前因为赶工期，开发过程中一直没有引入单元测试。而且因为QA资源比较紧张，所以我们的很多功能都是自己测试的，增加了很多人力成本不说，很多地方测试得还不够细致，导致漏掉了bug。</p>\n<p>在这种情况下，单元测试的环节必须得到重视。这样可以减少代码逻辑变更时的重复测试成本，大部分常见问题也可以在这一阶段被发现、解决。</p>\n<p>PHPUnit的手册很详尽的记录了不同平台的安装方法，编写测试用例的简单示例以及各种特性，就不再赘述了。</p>\n<h3 id=\"composer\"><a href=\"#composer\" class=\"headerlink\" title=\"composer\"></a>composer</h3><p>在安装PHPUnit的过程中，发现了composer。之前管理第三方库或者组件的时候，一直是手工管理的，版本更新比较麻烦，处理起依赖也不太方便，所以准备以后使用composer管理依赖，正好可以借这次机会尝试。</p>\n<p>composer的使用比较简单，本地安装后，在项目里增加composer.json文件，里面描述项目的依赖库，然后使用<br><code>php composer.phar install</code>即可将所需库下载到vendor目录下，然后composer会生成一个composer.lock文件，里面记录了已下载的第三方库版本。将这个文件托管到svn或者git，这样在另外一个环境部署的时候，composer会根据composer.lock文件中记录的版本下载指定的第三方库，确保项目稳定运行。</p>\n<p>这样看来，composer配合docker，将是搭建开发或测试环境的好方案，可以方便的解决软件环境和项目环境的依赖。有机会可以尝试一下。</p>\n<p>如果需要新版本的第三方库，只需执行php composer.phar update或者php composer.phar update [package name]即可更新全部库或指定库，当然不会超过composer.json文件中限制的版本范围。</p>\n<p>另外，composer还提供了ventor/autoload.php自动加载类，可以方便的加载用composer安装到ventor目录的依赖。</p>\n<h3 id=\"monolog\"><a href=\"#monolog\" class=\"headerlink\" title=\"monolog\"></a>monolog</h3><p>在安装composer的过程中，发现了monolog，果然生命在于折腾。之前项目里面的日志实现是基于一个简单的写入本地文件的工具类实现的。服务器规模扩展的话将引起日志分散的问题，且缺少错误信息报警机制。</p>\n<p>monolog的安装非常方便，直接使用composer安装即可。如果不使用composer，从github直接下载代码也是可以的。</p>\n<p>monolog的逻辑并不复杂，核心概念只有几项，包括logger, channel, handler, formatter, processors等。学习过程记录如下：</p>\n<ul>\n<li>logger是日志的记录者，每条日志生成一个record。</li>\n<li>创建logger时可以定义一个channel，体现在record的内容中，方便过滤。</li>\n<li>logger可以有多个handler，通过代理将record的具体处理方法交给handler实现。handler用一个栈存储，添加record的时候由栈顶的handler先处理。每个handler判断新增的record是否符合自己的log level，设定是否允许后续的handler继续处理。</li>\n<li>每个handler有一个formatter，formatter可以将record内容清洗为符合handler需求的格式。</li>\n<li>processors可以添加到logger也可以添加到handler。processor以record为参数，返回处理后的record。processor的逻辑通常是向record的extra数组添加内容。在logger中，processor在handler之前处理record，在handler中，processor在formatter之前处理record。</li>\n</ul>\n<p>如图所示：<br><img src=\"http://7xiium.com1.z0.glb.clouddn.com/Monolog.png\" alt=\"\"></p>\n<p>monolog提供了很多handler以及相应的formatter和processor，用户还可以根据需要自己添加handler、formatter、processors等，非常灵活。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这篇博客拖了好久好久才写完，一方面是因为平时杂事比较多，总觉得腾不出手来写；另一方面也是因为自己执行力不足，很多计划好的事情都没有开始，时间没有用好。</p>\n<p>不管怎样，还是要从眼前的事情一点一点做起，坚持写博客，养成总结的习惯，恢复更新，继续上路。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjd9o910f00016bk2sd1fl0me","category_id":"cjd9o910o00046bk2hsm0khjb","_id":"cjd9o910w000e6bk2ls282szn"},{"post_id":"cjd9o910l00036bk2g5505cm3","category_id":"cjd9o910t00096bk2ryopf3u7","_id":"cjd9o9112000k6bk218qul0ah"},{"post_id":"cjd9o910y000h6bk20kyfqgeq","category_id":"cjd9o910o00046bk2hsm0khjb","_id":"cjd9o9115000o6bk2bkz7h8ir"},{"post_id":"cjd9o910p00066bk247c4oals","category_id":"cjd9o910t00096bk2ryopf3u7","_id":"cjd9o9116000s6bk2n7793oah"},{"post_id":"cjd9o910r00076bk2zvobuwen","category_id":"cjd9o910t00096bk2ryopf3u7","_id":"cjd9o9116000t6bk22iyfi3xo"},{"post_id":"cjd9o9114000n6bk2qv5yzeht","category_id":"cjd9o910t00096bk2ryopf3u7","_id":"cjd9o9117000w6bk2u9ypic7s"},{"post_id":"cjd9o910s00086bk2i820083t","category_id":"cjd9o9115000p6bk2s2iednp0","_id":"cjd9o9117000z6bk2ohby9kbf"},{"post_id":"cjd9o910u000c6bk2squnszl4","category_id":"cjd9o9115000p6bk2s2iednp0","_id":"cjd9o911800136bk26yorv5oe"},{"post_id":"cjd9o910v000d6bk2gelhet5o","category_id":"cjd9o9117000y6bk2vgstbmvg","_id":"cjd9o911900186bk2m45am8yl"},{"post_id":"cjd9o9110000i6bk2uw1ny0np","category_id":"cjd9o911800146bk2b0oqywmd","_id":"cjd9o911a001d6bk2xw0iulku"},{"post_id":"cjd9o9113000m6bk2pr5e1b7b","category_id":"cjd9o911800146bk2b0oqywmd","_id":"cjd9o911a001g6bk2npyusetj"},{"post_id":"cjd9o9115000r6bk27zgdd5dc","category_id":"cjd9o9117000y6bk2vgstbmvg","_id":"cjd9o911b001j6bk2p1zd7lgh"}],"PostTag":[{"post_id":"cjd9o910f00016bk2sd1fl0me","tag_id":"cjd9o910p00056bk26imv2h7m","_id":"cjd9o910u000b6bk2z38ox0ye"},{"post_id":"cjd9o910l00036bk2g5505cm3","tag_id":"cjd9o910t000a6bk2f9ml619a","_id":"cjd9o9117000x6bk2tple767a"},{"post_id":"cjd9o910l00036bk2g5505cm3","tag_id":"cjd9o910x000g6bk23xerh3j3","_id":"cjd9o911700106bk2m4zf586a"},{"post_id":"cjd9o910l00036bk2g5505cm3","tag_id":"cjd9o9113000l6bk23egu6z1r","_id":"cjd9o911800126bk2p1p7m319"},{"post_id":"cjd9o910l00036bk2g5505cm3","tag_id":"cjd9o9115000q6bk2wwnd653s","_id":"cjd9o911800156bk2d0iawp0n"},{"post_id":"cjd9o910p00066bk247c4oals","tag_id":"cjd9o9117000v6bk2jc5qaf3f","_id":"cjd9o911900176bk2d5l398i3"},{"post_id":"cjd9o910r00076bk2zvobuwen","tag_id":"cjd9o910x000g6bk23xerh3j3","_id":"cjd9o9119001b6bk2kqdburjw"},{"post_id":"cjd9o910r00076bk2zvobuwen","tag_id":"cjd9o911800166bk2jhgc0ljo","_id":"cjd9o911a001e6bk2synmqnpf"},{"post_id":"cjd9o910s00086bk2i820083t","tag_id":"cjd9o9119001a6bk2el2tp0ta","_id":"cjd9o911b001i6bk2suu4mts6"},{"post_id":"cjd9o910s00086bk2i820083t","tag_id":"cjd9o911a001f6bk22dpb5sl2","_id":"cjd9o911b001k6bk2kz6ozn8x"},{"post_id":"cjd9o910u000c6bk2squnszl4","tag_id":"cjd9o911a001h6bk24d7cwqvb","_id":"cjd9o911c001o6bk2hfc0nq5i"},{"post_id":"cjd9o910u000c6bk2squnszl4","tag_id":"cjd9o911a001f6bk22dpb5sl2","_id":"cjd9o911c001p6bk292ium6zn"},{"post_id":"cjd9o910u000c6bk2squnszl4","tag_id":"cjd9o911b001m6bk2xsil7d5l","_id":"cjd9o911c001r6bk2xowcxza1"},{"post_id":"cjd9o910v000d6bk2gelhet5o","tag_id":"cjd9o911b001n6bk2hihefm8x","_id":"cjd9o911c001u6bk2nxxl69vb"},{"post_id":"cjd9o910v000d6bk2gelhet5o","tag_id":"cjd9o911c001q6bk2upxqhol7","_id":"cjd9o911c001v6bk2bgubup2u"},{"post_id":"cjd9o910v000d6bk2gelhet5o","tag_id":"cjd9o911c001s6bk2pbskzxtx","_id":"cjd9o911d001x6bk2hgcvd4ki"},{"post_id":"cjd9o9110000i6bk2uw1ny0np","tag_id":"cjd9o911c001t6bk2l1rx44i9","_id":"cjd9o911d001y6bk2i7ata14p"},{"post_id":"cjd9o9113000m6bk2pr5e1b7b","tag_id":"cjd9o911c001t6bk2l1rx44i9","_id":"cjd9o911d00206bk2wi3gy5au"},{"post_id":"cjd9o9114000n6bk2qv5yzeht","tag_id":"cjd9o911d001z6bk2mtbspoty","_id":"cjd9o911e00226bk2dn9anxi6"},{"post_id":"cjd9o9115000r6bk27zgdd5dc","tag_id":"cjd9o911d00216bk2w91bclto","_id":"cjd9o911e00246bk2eew9zmk9"},{"post_id":"cjd9o9115000r6bk27zgdd5dc","tag_id":"cjd9o911e00236bk2cuauawki","_id":"cjd9o911e00256bk2qmmc7oz5"}],"Tag":[{"name":"hello world","_id":"cjd9o910p00056bk26imv2h7m"},{"name":"php","_id":"cjd9o910t000a6bk2f9ml619a"},{"name":"mysql","_id":"cjd9o910x000g6bk23xerh3j3"},{"name":"swoole","_id":"cjd9o9113000l6bk23egu6z1r"},{"name":"workerman","_id":"cjd9o9115000q6bk2wwnd653s"},{"name":"Quartz","_id":"cjd9o9117000v6bk2jc5qaf3f"},{"name":"mysql replication","_id":"cjd9o911800166bk2jhgc0ljo"},{"name":"素数","_id":"cjd9o9119001a6bk2el2tp0ta"},{"name":"数学","_id":"cjd9o911a001f6bk22dpb5sl2"},{"name":"统计学","_id":"cjd9o911a001h6bk24d7cwqvb"},{"name":"A/B testing","_id":"cjd9o911b001m6bk2xsil7d5l"},{"name":"svn","_id":"cjd9o911b001n6bk2hihefm8x"},{"name":"git","_id":"cjd9o911c001q6bk2upxqhol7"},{"name":"工程","_id":"cjd9o911c001s6bk2pbskzxtx"},{"name":"golang","_id":"cjd9o911c001t6bk2l1rx44i9"},{"name":"tools","_id":"cjd9o911d001z6bk2mtbspoty"},{"name":"composer","_id":"cjd9o911d00216bk2w91bclto"},{"name":"monolog","_id":"cjd9o911e00236bk2cuauawki"}]}}